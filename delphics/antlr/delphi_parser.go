// Code generated from Delphi.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // Delphi

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type DelphiParser struct {
	*antlr.BaseParser
}

var DelphiParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func delphiParserInit() {
	staticData := &DelphiParserStaticData
	staticData.LiteralNames = []string{
		"", "'abekat'", "'absolute'", "'abstract'", "'add'", "'and'", "'ansistring'",
		"'array'", "'as'", "'asm'", "'assembler'", "'assembly'", "'at'", "'automated'",
		"'begin'", "'break'", "'case'", "'cdecl'", "'class'", "'const'", "'constructor'",
		"'contains'", "'continue'", "'default'", "'deprecated'", "'destructor'",
		"'dispid'", "'dispinterface'", "'div'", "'do'", "'downto'", "'dq'",
		"'dw'", "'dynamic'", "'else'", "'end'", "'except'", "'exit'", "'experimental'",
		"'export'", "'exports'", "'external'", "'far'", "'file'", "'final'",
		"'finalization'", "'finally'", "'for'", "'forward'", "'function'", "'goto'",
		"'helper'", "'if'", "'implementation'", "'implements'", "'in'", "'index'",
		"'inherited'", "'initialization'", "'inline'", "'interface'", "'is'",
		"'label'", "'library'", "'local'", "'message'", "'mod'", "'name'", "'near'",
		"'nil'", "'nodefault'", "'not'", "'object'", "'of'", "'on'", "'operator'",
		"'or'", "'out'", "'overload'", "'override'", "'package'", "'packed'",
		"'pascal'", "'platform'", "'pointer'", "'private'", "'procedure'", "'program'",
		"'property'", "'protected'", "'public'", "'published'", "'raise'", "'read'",
		"'readonly'", "'record'", "'reference'", "'register'", "'reintroduce'",
		"'remove'", "'repeat'", "'requires'", "'resident'", "'resourcestring'",
		"'safecall'", "'sealed'", "'set'", "'shl'", "'shr'", "'static'", "'stdcall'",
		"'stored'", "'strict'", "'string'", "'then'", "'threadvar'", "'to'",
		"'try'", "'type'", "'unit'", "'unsafe'", "'until'", "'uses'", "'var'",
		"'varargs'", "'variant'", "'virtual'", "'while'", "'with'", "'write'",
		"'writeonly'", "'xor'", "'false'", "'true'", "'+'", "'-'", "'*'", "'/'",
		"':='", "','", "';'", "':'", "'='", "'<>'", "'<'", "'<='", "'>='", "'>'",
		"'('", "')'", "'['", "'(.'", "']'", "'.)'", "'^'", "'@'", "'.'", "'..'",
		"'{'", "'}'", "'&'", "'@@'", "'FUNCTION_GLOBAL'", "'FUNCTION_NAME'",
		"'FUNCTION_ARGS'", "'FUNCTION_BODY'", "'FUNCTION_RETURN'", "'CUSTOM_ATTRIBUTE'",
		"'CUSTOM_ATTRIBUTE_ARGS'", "'NEW_TYPE'", "'CLASS'", "'RECORD_TYPE'",
		"'RECORD_HELPER'", "'INTERFACE_TYPE'", "'OBJECT_TYPE'", "'CLASS_OF_TYPE'",
		"'VARIABLE_TYPE'", "'VARIABLE_IDENTS'", "'VARIABLE_PARAM'", "'INTERFACE_GUID'",
		"'CLASS_PARENTS'", "'CLASS_FIELD'", "'ANONYMOUS_EXPRESSION'", "", "",
		"", "", "", "", "", "", "", "", "", "'\\uFEFF'",
	}
	staticData.SymbolicNames = []string{
		"", "", "ABSOLUTE", "ABSTRACT", "ADD", "AND", "ANSISTRING", "ARRAY",
		"AS", "ASM", "ASSEMBLER", "ASSEMBLY", "AT", "AUTOMATED", "BEGIN", "BREAK",
		"CASE", "CDECL", "CLASS", "CONST", "CONSTRUCTOR", "CONTAINS", "CONTINUE",
		"DEFAULT", "DEPRECATED", "DESTRUCTOR", "DISPID", "DISPINTERFACE", "DIV",
		"DO", "DOWNTO", "DQ", "DW", "DYNAMIC", "ELSE", "END", "EXCEPT", "EXIT",
		"EXPERIMENTAL", "EXPORT", "EXPORTS", "EXTERNAL", "FAR", "FILE", "FINAL",
		"FINALIZATION", "FINALLY", "FOR", "FORWARD", "FUNCTION", "GOTO", "HELPER",
		"IF", "IMPLEMENTATION", "IMPLEMENTS", "IN", "INDEX", "INHERITED", "INITIALIZATION",
		"INLINE", "INTERFACE", "IS", "LABEL", "LIBRARY", "LOCAL", "MESSAGE",
		"MOD", "NAME", "NEAR", "NIL", "NODEFAULT", "NOT", "OBJECT", "OF", "ON",
		"OPERATOR", "OR", "OUT", "OVERLOAD", "OVERRIDE", "PACKAGE", "PACKED",
		"PASCAL", "PLATFORM", "POINTER", "PRIVATE", "PROCEDURE", "PROGRAM",
		"PROPERTY", "PROTECTED", "PUBLIC", "PUBLISHED", "RAISE", "READ", "READONLY",
		"RECORD", "REFERENCE", "REGISTER", "REINTRODUCE", "REMOVE", "REPEAT",
		"REQUIRES", "RESIDENT", "RESOURCESTRING", "SAFECALL", "SEALED", "SET",
		"SHL", "SHR", "STATIC", "STDCALL", "STORED", "STRICT", "STRING", "THEN",
		"THREADVAR", "TO", "TRY", "TYPE", "UNIT", "UNSAFE", "UNTIL", "USES",
		"VAR", "VARARGS", "VARIANT", "VIRTUAL", "WHILE", "WITH", "WRITE", "WRITEONLY",
		"XOR", "FALSE", "TRUE", "PLUS", "MINUS", "STAR", "SLASH", "ASSIGN",
		"COMMA", "SEMI", "COLON", "EQUAL", "NOT_EQUAL", "LT", "LE", "GE", "GT",
		"LPAREN", "RPAREN", "LBRACK", "LBRACK2", "RBRACK", "RBRACK2", "POINTER2",
		"AT2", "DOT", "DOTDOT", "LCURLY", "RCURLY", "AMBER", "DOUBLEAT", "TkGlobalFunction",
		"TkFunctionName", "TkFunctionArgs", "TkFunctionBody", "TkFunctionReturn",
		"TkCustomAttribute", "TkCustomAttributeArgs", "TkNewType", "TkClass",
		"TkRecord", "TkRecordHelper", "TkInterface", "TkObject", "TkClassOfType",
		"TkVariableType", "TkVariableIdents", "TkVariableParam", "TkGuid", "TkClassParents",
		"TkClassField", "TkAnonymousExpression", "TkIdentifier", "TkIntNum",
		"TkRealNum", "TkHexNum", "TkAsmHexNum", "TkAsmHexLabel", "QuotedString",
		"ControlString", "Hexdigitseq", "COMMENT", "WS", "UnicodeBOM",
	}
	staticData.RuleNames = []string{
		"file", "program", "programHead", "programParmSeq", "library", "libraryHead",
		"packageE", "packageHead", "unit", "unitHead", "unitInterface", "unitImplementation",
		"unitBlock", "unitInitialization", "unitFinalization", "containsClause",
		"requiresClause", "usesClause", "usesFileClause", "namespaceFileNameList",
		"namespaceFileName", "namespaceNameList", "block", "blockBody", "declSection",
		"interfaceDecl", "labelDeclSection", "constSection", "constKey", "constDeclaration",
		"typeSection", "typeDeclaration", "varSection", "varKey", "varDeclaration",
		"varValueSpec", "exportsSection", "exportItem", "typeDecl", "strucType",
		"strucTypePart", "arrayType", "arrayIndex", "arraySubType", "setType",
		"fileType", "pointerType", "stringType", "codePageNumber", "procedureType",
		"methodType", "simpleProcedureType", "procedureReference", "procedureTypeHeading",
		"variantType", "simpleType", "subRangeType", "enumType", "typeId", "genericTypeIdent",
		"genericDefinition", "simpleGenericDefinition", "constrainedGenericDefinition",
		"constrainedGeneric", "genericConstraint", "genericPostfix", "classDecl",
		"classTypeTypeDecl", "classTypeDecl", "classState", "classParent", "classItem",
		"classHelperDecl", "classHelperItem", "interfaceTypeDecl", "interfaceKey",
		"interfaceGuid", "interfaceItem", "objectDecl", "objectItem", "recordDecl",
		"simpleRecord", "variantRecord", "recordItem", "recordField", "recordVariantField",
		"recordVariantSection", "recordVariant", "recordHelperDecl", "recordHelperItem",
		"classMethod", "classField", "classProperty", "classPropertyArray",
		"classPropertyIndex", "classPropertySpecifier", "classPropertyEndSpecifier",
		"classPropertyReadWrite", "classPropertyDispInterface", "visibility",
		"exportedProcHeading", "methodDecl", "methodDeclHeading", "methodKey",
		"methodName", "procDecl", "procDeclHeading", "formalParameterSection",
		"formalParameterList", "formalParameter", "parmType", "methodBody",
		"procBody", "customAttribute", "customAttributeList", "customAttributeDecl",
		"expression", "anonymousExpression", "simpleExpression", "factor", "stringFactor",
		"setSection", "designator", "designatorItem", "expressionList", "colonConstruct",
		"operator", "relOp", "statement", "ifStatement", "caseStatement", "caseItem",
		"caseLabel", "repeatStatement", "whileStatement", "forStatement", "withStatement",
		"withItem", "compoundStatement", "statementList", "simpleStatement",
		"gotoStatement", "constExpression", "recordConstExpression", "tryStatement",
		"handlerList", "handler", "handlerIdent", "handlerStatement", "raiseStatement",
		"assemblerStatement", "methodDirective", "functionDirective", "reintroduceDirective",
		"overloadDirective", "bindingDirective", "abstractDirective", "inlineDirective",
		"callConvention", "callConventionNoSemi", "oldCallConventionDirective",
		"hintingDirective", "externalDirective", "externalSpecifier", "dispIDDirective",
		"ident", "usedKeywordsAsNames", "identList", "identListFlat", "label",
		"intNum", "realNum", "namespacedQualifiedIdent", "namespaceName", "qualifiedIdent",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 194, 2143, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 1, 0, 1, 0, 1, 0,
		1, 0, 3, 0, 355, 8, 0, 1, 1, 3, 1, 358, 8, 1, 1, 1, 3, 1, 361, 8, 1, 1,
		1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 3, 2, 369, 8, 2, 1, 2, 1, 2, 1, 3, 1,
		3, 1, 3, 1, 3, 5, 3, 377, 8, 3, 10, 3, 12, 3, 380, 9, 3, 3, 3, 382, 8,
		3, 1, 3, 1, 3, 1, 4, 1, 4, 3, 4, 388, 8, 4, 1, 4, 1, 4, 1, 4, 1, 5, 1,
		5, 1, 5, 5, 5, 396, 8, 5, 10, 5, 12, 5, 399, 9, 5, 1, 5, 1, 5, 1, 6, 1,
		6, 1, 6, 3, 6, 406, 8, 6, 1, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 5, 9, 424, 8, 9, 10,
		9, 12, 9, 427, 9, 9, 1, 9, 1, 9, 1, 10, 1, 10, 3, 10, 433, 8, 10, 1, 10,
		5, 10, 436, 8, 10, 10, 10, 12, 10, 439, 9, 10, 1, 11, 1, 11, 3, 11, 443,
		8, 11, 1, 11, 5, 11, 446, 8, 11, 10, 11, 12, 11, 449, 9, 11, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 3, 12, 456, 8, 12, 1, 13, 1, 13, 1, 13, 3, 13,
		461, 8, 13, 1, 14, 1, 14, 1, 14, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16, 1,
		16, 1, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 5, 19,
		481, 8, 19, 10, 19, 12, 19, 484, 9, 19, 1, 19, 1, 19, 1, 20, 1, 20, 1,
		20, 3, 20, 491, 8, 20, 1, 21, 1, 21, 1, 21, 5, 21, 496, 8, 21, 10, 21,
		12, 21, 499, 9, 21, 1, 21, 1, 21, 1, 22, 5, 22, 504, 8, 22, 10, 22, 12,
		22, 507, 9, 22, 1, 22, 3, 22, 510, 8, 22, 1, 23, 1, 23, 3, 23, 514, 8,
		23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 524,
		8, 24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 533, 8,
		25, 1, 26, 1, 26, 1, 26, 1, 26, 5, 26, 539, 8, 26, 10, 26, 12, 26, 542,
		9, 26, 1, 26, 1, 26, 1, 27, 1, 27, 5, 27, 548, 8, 27, 10, 27, 12, 27, 551,
		9, 27, 1, 28, 1, 28, 1, 29, 3, 29, 556, 8, 29, 1, 29, 1, 29, 1, 29, 3,
		29, 561, 8, 29, 1, 29, 1, 29, 1, 29, 5, 29, 566, 8, 29, 10, 29, 12, 29,
		569, 9, 29, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 5, 30, 576, 8, 30, 10, 30,
		12, 30, 579, 9, 30, 1, 31, 3, 31, 582, 8, 31, 1, 31, 1, 31, 1, 31, 1, 31,
		5, 31, 588, 8, 31, 10, 31, 12, 31, 591, 9, 31, 1, 31, 1, 31, 1, 32, 1,
		32, 1, 32, 5, 32, 598, 8, 32, 10, 32, 12, 32, 601, 9, 32, 1, 33, 1, 33,
		1, 34, 3, 34, 606, 8, 34, 1, 34, 1, 34, 1, 34, 1, 34, 3, 34, 612, 8, 34,
		1, 34, 5, 34, 615, 8, 34, 10, 34, 12, 34, 618, 9, 34, 1, 34, 1, 34, 1,
		35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 628, 8, 35, 1, 36, 1, 36,
		1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 5, 36, 637, 8, 36, 10, 36, 12, 36, 640,
		9, 36, 1, 36, 1, 36, 1, 37, 1, 37, 3, 37, 646, 8, 37, 1, 37, 3, 37, 649,
		8, 37, 1, 37, 1, 37, 3, 37, 653, 8, 37, 1, 37, 1, 37, 3, 37, 657, 8, 37,
		1, 37, 3, 37, 660, 8, 37, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 3,
		38, 668, 8, 38, 1, 38, 1, 38, 3, 38, 672, 8, 38, 1, 38, 3, 38, 675, 8,
		38, 1, 39, 3, 39, 678, 8, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 40,
		3, 40, 686, 8, 40, 1, 41, 1, 41, 1, 41, 3, 41, 691, 8, 41, 1, 41, 1, 41,
		3, 41, 695, 8, 41, 5, 41, 697, 8, 41, 10, 41, 12, 41, 700, 9, 41, 1, 41,
		3, 41, 703, 8, 41, 1, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1,
		42, 3, 42, 713, 8, 42, 1, 43, 1, 43, 3, 43, 717, 8, 43, 1, 44, 1, 44, 1,
		44, 1, 44, 1, 45, 1, 45, 1, 45, 3, 45, 726, 8, 45, 1, 46, 1, 46, 1, 46,
		3, 46, 731, 8, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 738, 8, 47,
		1, 47, 3, 47, 741, 8, 47, 1, 47, 1, 47, 3, 47, 745, 8, 47, 3, 47, 747,
		8, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49, 3, 49, 756, 8,
		49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 51, 1, 51, 3, 51, 764, 8, 51, 1, 51,
		3, 51, 767, 8, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 3, 53, 775,
		8, 53, 1, 53, 1, 53, 3, 53, 779, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 784,
		8, 53, 3, 53, 786, 8, 53, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 3, 55, 793,
		8, 55, 1, 56, 1, 56, 1, 56, 3, 56, 798, 8, 56, 1, 57, 1, 57, 1, 57, 1,
		57, 3, 57, 804, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 810, 8, 57, 5,
		57, 812, 8, 57, 10, 57, 12, 57, 815, 9, 57, 1, 57, 1, 57, 1, 58, 1, 58,
		1, 59, 1, 59, 3, 59, 823, 8, 59, 1, 60, 1, 60, 3, 60, 827, 8, 60, 1, 61,
		1, 61, 1, 61, 1, 61, 5, 61, 833, 8, 61, 10, 61, 12, 61, 836, 9, 61, 1,
		61, 1, 61, 1, 62, 1, 62, 1, 62, 1, 62, 5, 62, 844, 8, 62, 10, 62, 12, 62,
		847, 9, 62, 1, 62, 1, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 5, 63, 856,
		8, 63, 10, 63, 12, 63, 859, 9, 63, 3, 63, 861, 8, 63, 1, 64, 1, 64, 3,
		64, 865, 8, 64, 1, 65, 1, 65, 1, 65, 1, 65, 5, 65, 871, 8, 65, 10, 65,
		12, 65, 874, 9, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1,
		66, 1, 66, 3, 66, 885, 8, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 68, 1, 68,
		3, 68, 893, 8, 68, 1, 68, 3, 68, 896, 8, 68, 1, 68, 5, 68, 899, 8, 68,
		10, 68, 12, 68, 902, 9, 68, 1, 68, 1, 68, 1, 68, 3, 68, 907, 8, 68, 3,
		68, 909, 8, 68, 1, 69, 1, 69, 1, 70, 1, 70, 1, 70, 1, 70, 5, 70, 917, 8,
		70, 10, 70, 12, 70, 920, 9, 70, 1, 70, 1, 70, 1, 71, 1, 71, 1, 71, 1, 71,
		1, 71, 1, 71, 1, 71, 3, 71, 931, 8, 71, 1, 71, 3, 71, 934, 8, 71, 1, 72,
		1, 72, 1, 72, 3, 72, 939, 8, 72, 1, 72, 1, 72, 1, 72, 5, 72, 944, 8, 72,
		10, 72, 12, 72, 947, 9, 72, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 1, 73, 3,
		73, 955, 8, 73, 1, 73, 3, 73, 958, 8, 73, 1, 74, 1, 74, 3, 74, 962, 8,
		74, 1, 74, 3, 74, 965, 8, 74, 1, 74, 5, 74, 968, 8, 74, 10, 74, 12, 74,
		971, 9, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 977, 8, 74, 3, 74, 979,
		8, 74, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76, 1, 76, 1, 77, 1, 77, 3, 77, 989,
		8, 77, 1, 77, 3, 77, 992, 8, 77, 1, 78, 1, 78, 3, 78, 996, 8, 78, 1, 78,
		5, 78, 999, 8, 78, 10, 78, 12, 78, 1002, 9, 78, 1, 78, 1, 78, 1, 79, 1,
		79, 1, 79, 3, 79, 1009, 8, 79, 1, 80, 1, 80, 3, 80, 1013, 8, 80, 1, 81,
		1, 81, 5, 81, 1017, 8, 81, 10, 81, 12, 81, 1020, 9, 81, 1, 81, 5, 81, 1023,
		8, 81, 10, 81, 12, 81, 1026, 9, 81, 1, 81, 1, 81, 1, 82, 1, 82, 5, 82,
		1032, 8, 82, 10, 82, 12, 82, 1035, 9, 82, 1, 82, 1, 82, 1, 82, 1, 83, 1,
		83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 1047, 8, 83, 1, 83, 3, 83,
		1050, 8, 83, 1, 84, 1, 84, 1, 84, 1, 84, 5, 84, 1056, 8, 84, 10, 84, 12,
		84, 1059, 9, 84, 1, 84, 3, 84, 1062, 8, 84, 1, 85, 1, 85, 1, 85, 1, 85,
		5, 85, 1068, 8, 85, 10, 85, 12, 85, 1071, 9, 85, 1, 85, 3, 85, 1074, 8,
		85, 1, 86, 1, 86, 1, 86, 1, 86, 3, 86, 1080, 8, 86, 1, 86, 1, 86, 1, 86,
		1, 86, 3, 86, 1086, 8, 86, 1, 86, 1, 86, 5, 86, 1090, 8, 86, 10, 86, 12,
		86, 1093, 9, 86, 1, 87, 1, 87, 1, 87, 5, 87, 1098, 8, 87, 10, 87, 12, 87,
		1101, 9, 87, 1, 87, 1, 87, 1, 87, 5, 87, 1106, 8, 87, 10, 87, 12, 87, 1109,
		9, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 5, 88, 1118, 8,
		88, 10, 88, 12, 88, 1121, 9, 88, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89, 3,
		89, 1128, 8, 89, 1, 90, 3, 90, 1131, 8, 90, 1, 90, 3, 90, 1134, 8, 90,
		1, 90, 1, 90, 1, 90, 3, 90, 1139, 8, 90, 1, 90, 3, 90, 1142, 8, 90, 1,
		90, 1, 90, 5, 90, 1146, 8, 90, 10, 90, 12, 90, 1149, 9, 90, 1, 90, 3, 90,
		1152, 8, 90, 1, 90, 3, 90, 1155, 8, 90, 1, 90, 1, 90, 1, 90, 3, 90, 1160,
		8, 90, 1, 90, 3, 90, 1163, 8, 90, 1, 90, 1, 90, 3, 90, 1167, 8, 90, 1,
		90, 1, 90, 1, 90, 5, 90, 1172, 8, 90, 10, 90, 12, 90, 1175, 9, 90, 1, 90,
		3, 90, 1178, 8, 90, 1, 90, 3, 90, 1181, 8, 90, 1, 90, 1, 90, 1, 90, 3,
		90, 1186, 8, 90, 1, 90, 3, 90, 1189, 8, 90, 1, 90, 1, 90, 3, 90, 1193,
		8, 90, 1, 90, 1, 90, 1, 90, 3, 90, 1198, 8, 90, 1, 91, 3, 91, 1201, 8,
		91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 5, 91, 1208, 8, 91, 10, 91, 12,
		91, 1211, 9, 91, 1, 92, 3, 92, 1214, 8, 92, 1, 92, 3, 92, 1217, 8, 92,
		1, 92, 1, 92, 1, 92, 3, 92, 1222, 8, 92, 1, 92, 1, 92, 3, 92, 1226, 8,
		92, 1, 92, 3, 92, 1229, 8, 92, 1, 92, 5, 92, 1232, 8, 92, 10, 92, 12, 92,
		1235, 9, 92, 1, 92, 1, 92, 5, 92, 1239, 8, 92, 10, 92, 12, 92, 1242, 9,
		92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 94, 1, 94, 1, 94, 3, 94, 1251, 8, 94,
		1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 3, 95, 1262,
		8, 95, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1,
		96, 1, 96, 1, 96, 3, 96, 1276, 8, 96, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97,
		1, 97, 3, 97, 1284, 8, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 3,
		97, 1292, 8, 97, 3, 97, 1294, 8, 97, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98,
		3, 98, 1301, 8, 98, 1, 99, 3, 99, 1304, 8, 99, 1, 99, 1, 99, 3, 99, 1308,
		8, 99, 1, 99, 1, 99, 3, 99, 1312, 8, 99, 1, 100, 1, 100, 1, 100, 3, 100,
		1317, 8, 100, 1, 100, 1, 100, 3, 100, 1321, 8, 100, 1, 100, 1, 100, 1,
		100, 5, 100, 1326, 8, 100, 10, 100, 12, 100, 1329, 9, 100, 1, 100, 1, 100,
		1, 100, 3, 100, 1334, 8, 100, 1, 100, 1, 100, 5, 100, 1338, 8, 100, 10,
		100, 12, 100, 1341, 9, 100, 3, 100, 1343, 8, 100, 1, 101, 1, 101, 1, 101,
		5, 101, 1348, 8, 101, 10, 101, 12, 101, 1351, 9, 101, 1, 101, 3, 101, 1354,
		8, 101, 1, 102, 3, 102, 1357, 8, 102, 1, 102, 3, 102, 1360, 8, 102, 1,
		102, 1, 102, 1, 102, 3, 102, 1365, 8, 102, 1, 102, 3, 102, 1368, 8, 102,
		1, 102, 3, 102, 1371, 8, 102, 1, 102, 1, 102, 1, 102, 3, 102, 1376, 8,
		102, 1, 102, 1, 102, 3, 102, 1380, 8, 102, 1, 102, 3, 102, 1383, 8, 102,
		1, 102, 3, 102, 1386, 8, 102, 1, 102, 1, 102, 1, 102, 1, 102, 3, 102, 1392,
		8, 102, 1, 102, 1, 102, 3, 102, 1396, 8, 102, 1, 102, 3, 102, 1399, 8,
		102, 3, 102, 1401, 8, 102, 1, 103, 1, 103, 1, 104, 1, 104, 3, 104, 1407,
		8, 104, 1, 104, 1, 104, 1, 104, 3, 104, 1412, 8, 104, 3, 104, 1414, 8,
		104, 1, 104, 1, 104, 1, 104, 3, 104, 1419, 8, 104, 1, 105, 1, 105, 1, 105,
		5, 105, 1424, 8, 105, 10, 105, 12, 105, 1427, 9, 105, 1, 105, 3, 105, 1430,
		8, 105, 1, 106, 3, 106, 1433, 8, 106, 1, 106, 1, 106, 1, 106, 3, 106, 1438,
		8, 106, 1, 106, 3, 106, 1441, 8, 106, 1, 106, 1, 106, 1, 106, 3, 106, 1446,
		8, 106, 1, 106, 1, 106, 1, 106, 3, 106, 1451, 8, 106, 1, 107, 1, 107, 3,
		107, 1455, 8, 107, 1, 107, 1, 107, 1, 108, 1, 108, 1, 108, 5, 108, 1462,
		8, 108, 10, 108, 12, 108, 1465, 9, 108, 1, 109, 3, 109, 1468, 8, 109, 1,
		109, 1, 109, 1, 109, 3, 109, 1473, 8, 109, 1, 109, 1, 109, 3, 109, 1477,
		8, 109, 1, 110, 1, 110, 1, 111, 1, 111, 1, 111, 1, 112, 1, 112, 1, 112,
		5, 112, 1487, 8, 112, 10, 112, 12, 112, 1490, 9, 112, 1, 112, 1, 112, 1,
		112, 1, 112, 1, 112, 5, 112, 1497, 8, 112, 10, 112, 12, 112, 1500, 9, 112,
		1, 112, 5, 112, 1503, 8, 112, 10, 112, 12, 112, 1506, 9, 112, 1, 112, 1,
		112, 1, 112, 3, 112, 1511, 8, 112, 1, 113, 1, 113, 1, 114, 5, 114, 1516,
		8, 114, 10, 114, 12, 114, 1519, 9, 114, 1, 115, 1, 115, 1, 115, 1, 115,
		3, 115, 1525, 8, 115, 1, 115, 3, 115, 1528, 8, 115, 1, 115, 1, 115, 1,
		116, 1, 116, 1, 116, 1, 116, 1, 116, 3, 116, 1537, 8, 116, 1, 116, 1, 116,
		3, 116, 1541, 8, 116, 3, 116, 1543, 8, 116, 1, 117, 1, 117, 3, 117, 1547,
		8, 117, 1, 117, 1, 117, 1, 117, 3, 117, 1552, 8, 117, 1, 117, 1, 117, 1,
		117, 1, 117, 3, 117, 1558, 8, 117, 1, 118, 1, 118, 1, 118, 1, 118, 5, 118,
		1564, 8, 118, 10, 118, 12, 118, 1567, 9, 118, 1, 119, 1, 119, 1, 119, 1,
		119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1,
		119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 3, 119, 1588, 8, 119,
		1, 119, 1, 119, 3, 119, 1592, 8, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1,
		119, 1, 119, 1, 119, 1, 119, 3, 119, 1602, 8, 119, 1, 120, 1, 120, 1, 120,
		5, 120, 1607, 8, 120, 10, 120, 12, 120, 1610, 9, 120, 1, 120, 3, 120, 1613,
		8, 120, 1, 120, 1, 120, 1, 120, 5, 120, 1618, 8, 120, 10, 120, 12, 120,
		1621, 9, 120, 1, 120, 3, 120, 1624, 8, 120, 3, 120, 1626, 8, 120, 1, 121,
		1, 121, 1, 121, 1, 121, 5, 121, 1632, 8, 121, 10, 121, 12, 121, 1635, 9,
		121, 3, 121, 1637, 8, 121, 1, 121, 1, 121, 1, 122, 3, 122, 1642, 8, 122,
		1, 122, 1, 122, 3, 122, 1646, 8, 122, 3, 122, 1648, 8, 122, 1, 122, 5,
		122, 1651, 8, 122, 10, 122, 12, 122, 1654, 9, 122, 1, 123, 1, 123, 1, 123,
		1, 123, 1, 123, 1, 123, 1, 123, 5, 123, 1663, 8, 123, 10, 123, 12, 123,
		1666, 9, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1,
		123, 1, 123, 3, 123, 1677, 8, 123, 1, 123, 1, 123, 1, 123, 3, 123, 1682,
		8, 123, 5, 123, 1684, 8, 123, 10, 123, 12, 123, 1687, 9, 123, 3, 123, 1689,
		8, 123, 1, 123, 3, 123, 1692, 8, 123, 1, 124, 1, 124, 1, 124, 5, 124, 1697,
		8, 124, 10, 124, 12, 124, 1700, 9, 124, 1, 125, 1, 125, 1, 125, 1, 125,
		3, 125, 1706, 8, 125, 1, 126, 1, 126, 1, 127, 1, 127, 1, 128, 1, 128, 1,
		128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1,
		128, 1, 128, 1, 128, 1, 128, 3, 128, 1727, 8, 128, 1, 129, 1, 129, 1, 129,
		1, 129, 1, 129, 1, 129, 3, 129, 1735, 8, 129, 1, 130, 1, 130, 1, 130, 1,
		130, 5, 130, 1741, 8, 130, 10, 130, 12, 130, 1744, 9, 130, 1, 130, 1, 130,
		1, 130, 3, 130, 1749, 8, 130, 3, 130, 1751, 8, 130, 1, 130, 1, 130, 1,
		131, 1, 131, 1, 131, 5, 131, 1758, 8, 131, 10, 131, 12, 131, 1761, 9, 131,
		1, 131, 1, 131, 1, 131, 3, 131, 1766, 8, 131, 1, 132, 1, 132, 1, 132, 3,
		132, 1771, 8, 132, 1, 133, 1, 133, 3, 133, 1775, 8, 133, 1, 133, 1, 133,
		1, 133, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 135, 1, 135, 1, 135,
		1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135,
		1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135,
		1, 135, 1, 135, 1, 135, 1, 135, 3, 135, 1810, 8, 135, 1, 136, 1, 136, 1,
		136, 1, 136, 1, 136, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1,
		137, 5, 137, 1824, 8, 137, 10, 137, 12, 137, 1827, 9, 137, 3, 137, 1829,
		8, 137, 1, 138, 1, 138, 3, 138, 1833, 8, 138, 1, 138, 1, 138, 1, 139, 3,
		139, 1838, 8, 139, 1, 139, 1, 139, 3, 139, 1842, 8, 139, 5, 139, 1844,
		8, 139, 10, 139, 12, 139, 1847, 9, 139, 1, 140, 1, 140, 1, 140, 1, 140,
		1, 140, 1, 140, 3, 140, 1855, 8, 140, 1, 141, 1, 141, 1, 141, 1, 141, 1,
		141, 1, 141, 1, 141, 3, 141, 1864, 8, 141, 1, 141, 3, 141, 1867, 8, 141,
		1, 142, 1, 142, 1, 142, 1, 142, 5, 142, 1873, 8, 142, 10, 142, 12, 142,
		1876, 9, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 5, 142, 1884,
		8, 142, 10, 142, 12, 142, 1887, 9, 142, 1, 142, 1, 142, 1, 142, 3, 142,
		1892, 8, 142, 1, 143, 1, 143, 1, 143, 1, 143, 1, 144, 1, 144, 3, 144, 1900,
		8, 144, 1, 144, 1, 144, 1, 144, 1, 144, 1, 144, 1, 144, 3, 144, 1908, 8,
		144, 1, 144, 1, 144, 3, 144, 1912, 8, 144, 1, 144, 3, 144, 1915, 8, 144,
		1, 145, 5, 145, 1918, 8, 145, 10, 145, 12, 145, 1921, 9, 145, 1, 145, 1,
		145, 3, 145, 1925, 8, 145, 1, 145, 3, 145, 1928, 8, 145, 1, 146, 1, 146,
		3, 146, 1932, 8, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 147, 1, 147, 1,
		147, 1, 148, 1, 148, 3, 148, 1943, 8, 148, 1, 148, 3, 148, 1946, 8, 148,
		1, 149, 1, 149, 3, 149, 1950, 8, 149, 1, 149, 1, 149, 3, 149, 1954, 8,
		149, 1, 150, 1, 150, 5, 150, 1958, 8, 150, 10, 150, 12, 150, 1961, 9, 150,
		1, 150, 1, 150, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151,
		1, 151, 1, 151, 1, 151, 1, 151, 3, 151, 1976, 8, 151, 1, 152, 1, 152, 1,
		152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 3, 152, 1986, 8, 152, 1, 152,
		1, 152, 1, 152, 3, 152, 1991, 8, 152, 1, 153, 1, 153, 1, 153, 1, 154, 1,
		154, 3, 154, 1998, 8, 154, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155,
		1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 3, 155, 2012, 8, 155, 1,
		156, 1, 156, 1, 156, 1, 156, 3, 156, 2018, 8, 156, 1, 157, 1, 157, 1, 157,
		1, 157, 3, 157, 2024, 8, 157, 1, 158, 1, 158, 1, 158, 1, 158, 1, 158, 1,
		158, 1, 158, 1, 158, 1, 158, 1, 158, 1, 158, 1, 158, 3, 158, 2038, 8, 158,
		1, 159, 1, 159, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 3, 160,
		2048, 8, 160, 1, 161, 1, 161, 3, 161, 2052, 8, 161, 1, 161, 3, 161, 2055,
		8, 161, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 5, 162,
		2064, 8, 162, 10, 162, 12, 162, 2067, 9, 162, 1, 162, 1, 162, 3, 162, 2071,
		8, 162, 1, 163, 1, 163, 1, 163, 1, 163, 3, 163, 2077, 8, 163, 1, 164, 1,
		164, 1, 164, 1, 164, 1, 165, 1, 165, 1, 165, 1, 165, 3, 165, 2087, 8, 165,
		1, 166, 1, 166, 1, 166, 3, 166, 2092, 8, 166, 1, 167, 1, 167, 1, 167, 5,
		167, 2097, 8, 167, 10, 167, 12, 167, 2100, 9, 167, 1, 168, 1, 168, 1, 168,
		5, 168, 2105, 8, 168, 10, 168, 12, 168, 2108, 9, 168, 1, 169, 1, 169, 3,
		169, 2112, 8, 169, 1, 170, 1, 170, 1, 171, 1, 171, 1, 172, 1, 172, 1, 172,
		3, 172, 2121, 8, 172, 1, 172, 1, 172, 1, 173, 1, 173, 1, 173, 5, 173, 2128,
		8, 173, 10, 173, 12, 173, 2131, 9, 173, 1, 174, 1, 174, 1, 174, 5, 174,
		2136, 8, 174, 10, 174, 12, 174, 2139, 9, 174, 1, 174, 1, 174, 1, 174, 0,
		0, 175, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32,
		34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68,
		70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104,
		106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134,
		136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164,
		166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194,
		196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224,
		226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254,
		256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284,
		286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314,
		316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344,
		346, 348, 0, 23, 2, 0, 19, 19, 103, 103, 2, 0, 115, 115, 123, 123, 3, 0,
		18, 18, 20, 20, 95, 95, 2, 0, 3, 3, 105, 105, 2, 0, 27, 27, 60, 60, 2,
		0, 23, 23, 70, 70, 2, 0, 13, 13, 90, 91, 3, 0, 20, 20, 25, 25, 86, 86,
		3, 0, 19, 19, 77, 77, 123, 123, 3, 0, 69, 69, 132, 133, 187, 187, 2, 0,
		139, 139, 157, 157, 1, 0, 155, 156, 8, 0, 5, 5, 8, 8, 28, 28, 66, 66, 76,
		76, 107, 108, 131, 131, 134, 137, 3, 0, 55, 55, 61, 61, 142, 147, 2, 0,
		15, 15, 22, 22, 1, 0, 35, 35, 6, 0, 17, 17, 39, 39, 82, 82, 97, 97, 104,
		104, 110, 110, 3, 0, 38, 38, 63, 63, 83, 83, 9, 0, 4, 4, 12, 12, 22, 23,
		56, 56, 65, 65, 67, 67, 84, 84, 94, 94, 113, 113, 9, 0, 21, 21, 44, 44,
		64, 64, 75, 75, 93, 93, 96, 97, 99, 99, 125, 125, 129, 129, 8, 0, 6, 6,
		15, 15, 37, 37, 39, 39, 54, 54, 72, 72, 77, 77, 111, 112, 2, 0, 183, 184,
		186, 186, 2, 0, 184, 184, 186, 186, 2361, 0, 354, 1, 0, 0, 0, 2, 357, 1,
		0, 0, 0, 4, 365, 1, 0, 0, 0, 6, 372, 1, 0, 0, 0, 8, 385, 1, 0, 0, 0, 10,
		392, 1, 0, 0, 0, 12, 402, 1, 0, 0, 0, 14, 410, 1, 0, 0, 0, 16, 414, 1,
		0, 0, 0, 18, 420, 1, 0, 0, 0, 20, 430, 1, 0, 0, 0, 22, 440, 1, 0, 0, 0,
		24, 455, 1, 0, 0, 0, 26, 457, 1, 0, 0, 0, 28, 462, 1, 0, 0, 0, 30, 465,
		1, 0, 0, 0, 32, 468, 1, 0, 0, 0, 34, 471, 1, 0, 0, 0, 36, 474, 1, 0, 0,
		0, 38, 477, 1, 0, 0, 0, 40, 487, 1, 0, 0, 0, 42, 492, 1, 0, 0, 0, 44, 505,
		1, 0, 0, 0, 46, 513, 1, 0, 0, 0, 48, 523, 1, 0, 0, 0, 50, 532, 1, 0, 0,
		0, 52, 534, 1, 0, 0, 0, 54, 545, 1, 0, 0, 0, 56, 552, 1, 0, 0, 0, 58, 555,
		1, 0, 0, 0, 60, 572, 1, 0, 0, 0, 62, 581, 1, 0, 0, 0, 64, 594, 1, 0, 0,
		0, 66, 602, 1, 0, 0, 0, 68, 605, 1, 0, 0, 0, 70, 627, 1, 0, 0, 0, 72, 629,
		1, 0, 0, 0, 74, 648, 1, 0, 0, 0, 76, 674, 1, 0, 0, 0, 78, 677, 1, 0, 0,
		0, 80, 685, 1, 0, 0, 0, 82, 687, 1, 0, 0, 0, 84, 712, 1, 0, 0, 0, 86, 716,
		1, 0, 0, 0, 88, 718, 1, 0, 0, 0, 90, 722, 1, 0, 0, 0, 92, 730, 1, 0, 0,
		0, 94, 746, 1, 0, 0, 0, 96, 748, 1, 0, 0, 0, 98, 755, 1, 0, 0, 0, 100,
		757, 1, 0, 0, 0, 102, 761, 1, 0, 0, 0, 104, 768, 1, 0, 0, 0, 106, 785,
		1, 0, 0, 0, 108, 787, 1, 0, 0, 0, 110, 792, 1, 0, 0, 0, 112, 794, 1, 0,
		0, 0, 114, 799, 1, 0, 0, 0, 116, 818, 1, 0, 0, 0, 118, 820, 1, 0, 0, 0,
		120, 826, 1, 0, 0, 0, 122, 828, 1, 0, 0, 0, 124, 839, 1, 0, 0, 0, 126,
		850, 1, 0, 0, 0, 128, 864, 1, 0, 0, 0, 130, 866, 1, 0, 0, 0, 132, 884,
		1, 0, 0, 0, 134, 886, 1, 0, 0, 0, 136, 908, 1, 0, 0, 0, 138, 910, 1, 0,
		0, 0, 140, 912, 1, 0, 0, 0, 142, 933, 1, 0, 0, 0, 144, 935, 1, 0, 0, 0,
		146, 957, 1, 0, 0, 0, 148, 978, 1, 0, 0, 0, 150, 980, 1, 0, 0, 0, 152,
		982, 1, 0, 0, 0, 154, 991, 1, 0, 0, 0, 156, 993, 1, 0, 0, 0, 158, 1008,
		1, 0, 0, 0, 160, 1012, 1, 0, 0, 0, 162, 1014, 1, 0, 0, 0, 164, 1029, 1,
		0, 0, 0, 166, 1049, 1, 0, 0, 0, 168, 1051, 1, 0, 0, 0, 170, 1063, 1, 0,
		0, 0, 172, 1075, 1, 0, 0, 0, 174, 1094, 1, 0, 0, 0, 176, 1112, 1, 0, 0,
		0, 178, 1127, 1, 0, 0, 0, 180, 1197, 1, 0, 0, 0, 182, 1200, 1, 0, 0, 0,
		184, 1213, 1, 0, 0, 0, 186, 1243, 1, 0, 0, 0, 188, 1247, 1, 0, 0, 0, 190,
		1261, 1, 0, 0, 0, 192, 1275, 1, 0, 0, 0, 194, 1293, 1, 0, 0, 0, 196, 1300,
		1, 0, 0, 0, 198, 1311, 1, 0, 0, 0, 200, 1342, 1, 0, 0, 0, 202, 1344, 1,
		0, 0, 0, 204, 1400, 1, 0, 0, 0, 206, 1402, 1, 0, 0, 0, 208, 1404, 1, 0,
		0, 0, 210, 1420, 1, 0, 0, 0, 212, 1450, 1, 0, 0, 0, 214, 1452, 1, 0, 0,
		0, 216, 1458, 1, 0, 0, 0, 218, 1467, 1, 0, 0, 0, 220, 1478, 1, 0, 0, 0,
		222, 1480, 1, 0, 0, 0, 224, 1510, 1, 0, 0, 0, 226, 1512, 1, 0, 0, 0, 228,
		1517, 1, 0, 0, 0, 230, 1520, 1, 0, 0, 0, 232, 1542, 1, 0, 0, 0, 234, 1557,
		1, 0, 0, 0, 236, 1559, 1, 0, 0, 0, 238, 1601, 1, 0, 0, 0, 240, 1625, 1,
		0, 0, 0, 242, 1627, 1, 0, 0, 0, 244, 1641, 1, 0, 0, 0, 246, 1691, 1, 0,
		0, 0, 248, 1693, 1, 0, 0, 0, 250, 1701, 1, 0, 0, 0, 252, 1707, 1, 0, 0,
		0, 254, 1709, 1, 0, 0, 0, 256, 1726, 1, 0, 0, 0, 258, 1728, 1, 0, 0, 0,
		260, 1736, 1, 0, 0, 0, 262, 1754, 1, 0, 0, 0, 264, 1767, 1, 0, 0, 0, 266,
		1772, 1, 0, 0, 0, 268, 1779, 1, 0, 0, 0, 270, 1809, 1, 0, 0, 0, 272, 1811,
		1, 0, 0, 0, 274, 1828, 1, 0, 0, 0, 276, 1830, 1, 0, 0, 0, 278, 1837, 1,
		0, 0, 0, 280, 1854, 1, 0, 0, 0, 282, 1866, 1, 0, 0, 0, 284, 1891, 1, 0,
		0, 0, 286, 1893, 1, 0, 0, 0, 288, 1914, 1, 0, 0, 0, 290, 1927, 1, 0, 0,
		0, 292, 1929, 1, 0, 0, 0, 294, 1937, 1, 0, 0, 0, 296, 1945, 1, 0, 0, 0,
		298, 1947, 1, 0, 0, 0, 300, 1955, 1, 0, 0, 0, 302, 1975, 1, 0, 0, 0, 304,
		1990, 1, 0, 0, 0, 306, 1992, 1, 0, 0, 0, 308, 1995, 1, 0, 0, 0, 310, 2011,
		1, 0, 0, 0, 312, 2017, 1, 0, 0, 0, 314, 2023, 1, 0, 0, 0, 316, 2037, 1,
		0, 0, 0, 318, 2039, 1, 0, 0, 0, 320, 2047, 1, 0, 0, 0, 322, 2054, 1, 0,
		0, 0, 324, 2070, 1, 0, 0, 0, 326, 2076, 1, 0, 0, 0, 328, 2078, 1, 0, 0,
		0, 330, 2086, 1, 0, 0, 0, 332, 2091, 1, 0, 0, 0, 334, 2093, 1, 0, 0, 0,
		336, 2101, 1, 0, 0, 0, 338, 2111, 1, 0, 0, 0, 340, 2113, 1, 0, 0, 0, 342,
		2115, 1, 0, 0, 0, 344, 2120, 1, 0, 0, 0, 346, 2124, 1, 0, 0, 0, 348, 2137,
		1, 0, 0, 0, 350, 355, 3, 2, 1, 0, 351, 355, 3, 8, 4, 0, 352, 355, 3, 16,
		8, 0, 353, 355, 3, 12, 6, 0, 354, 350, 1, 0, 0, 0, 354, 351, 1, 0, 0, 0,
		354, 352, 1, 0, 0, 0, 354, 353, 1, 0, 0, 0, 355, 1, 1, 0, 0, 0, 356, 358,
		3, 4, 2, 0, 357, 356, 1, 0, 0, 0, 357, 358, 1, 0, 0, 0, 358, 360, 1, 0,
		0, 0, 359, 361, 3, 36, 18, 0, 360, 359, 1, 0, 0, 0, 360, 361, 1, 0, 0,
		0, 361, 362, 1, 0, 0, 0, 362, 363, 3, 44, 22, 0, 363, 364, 5, 156, 0, 0,
		364, 3, 1, 0, 0, 0, 365, 366, 5, 87, 0, 0, 366, 368, 3, 346, 173, 0, 367,
		369, 3, 6, 3, 0, 368, 367, 1, 0, 0, 0, 368, 369, 1, 0, 0, 0, 369, 370,
		1, 0, 0, 0, 370, 371, 5, 140, 0, 0, 371, 5, 1, 0, 0, 0, 372, 381, 5, 148,
		0, 0, 373, 378, 3, 330, 165, 0, 374, 375, 5, 139, 0, 0, 375, 377, 3, 330,
		165, 0, 376, 374, 1, 0, 0, 0, 377, 380, 1, 0, 0, 0, 378, 376, 1, 0, 0,
		0, 378, 379, 1, 0, 0, 0, 379, 382, 1, 0, 0, 0, 380, 378, 1, 0, 0, 0, 381,
		373, 1, 0, 0, 0, 381, 382, 1, 0, 0, 0, 382, 383, 1, 0, 0, 0, 383, 384,
		5, 149, 0, 0, 384, 7, 1, 0, 0, 0, 385, 387, 3, 10, 5, 0, 386, 388, 3, 36,
		18, 0, 387, 386, 1, 0, 0, 0, 387, 388, 1, 0, 0, 0, 388, 389, 1, 0, 0, 0,
		389, 390, 3, 44, 22, 0, 390, 391, 5, 156, 0, 0, 391, 9, 1, 0, 0, 0, 392,
		393, 5, 63, 0, 0, 393, 397, 3, 346, 173, 0, 394, 396, 3, 322, 161, 0, 395,
		394, 1, 0, 0, 0, 396, 399, 1, 0, 0, 0, 397, 395, 1, 0, 0, 0, 397, 398,
		1, 0, 0, 0, 398, 400, 1, 0, 0, 0, 399, 397, 1, 0, 0, 0, 400, 401, 5, 140,
		0, 0, 401, 11, 1, 0, 0, 0, 402, 403, 3, 14, 7, 0, 403, 405, 3, 32, 16,
		0, 404, 406, 3, 30, 15, 0, 405, 404, 1, 0, 0, 0, 405, 406, 1, 0, 0, 0,
		406, 407, 1, 0, 0, 0, 407, 408, 5, 35, 0, 0, 408, 409, 5, 156, 0, 0, 409,
		13, 1, 0, 0, 0, 410, 411, 5, 80, 0, 0, 411, 412, 3, 346, 173, 0, 412, 413,
		5, 140, 0, 0, 413, 15, 1, 0, 0, 0, 414, 415, 3, 18, 9, 0, 415, 416, 3,
		20, 10, 0, 416, 417, 3, 22, 11, 0, 417, 418, 3, 24, 12, 0, 418, 419, 5,
		156, 0, 0, 419, 17, 1, 0, 0, 0, 420, 421, 5, 119, 0, 0, 421, 425, 3, 346,
		173, 0, 422, 424, 3, 322, 161, 0, 423, 422, 1, 0, 0, 0, 424, 427, 1, 0,
		0, 0, 425, 423, 1, 0, 0, 0, 425, 426, 1, 0, 0, 0, 426, 428, 1, 0, 0, 0,
		427, 425, 1, 0, 0, 0, 428, 429, 5, 140, 0, 0, 429, 19, 1, 0, 0, 0, 430,
		432, 5, 60, 0, 0, 431, 433, 3, 34, 17, 0, 432, 431, 1, 0, 0, 0, 432, 433,
		1, 0, 0, 0, 433, 437, 1, 0, 0, 0, 434, 436, 3, 50, 25, 0, 435, 434, 1,
		0, 0, 0, 436, 439, 1, 0, 0, 0, 437, 435, 1, 0, 0, 0, 437, 438, 1, 0, 0,
		0, 438, 21, 1, 0, 0, 0, 439, 437, 1, 0, 0, 0, 440, 442, 5, 53, 0, 0, 441,
		443, 3, 34, 17, 0, 442, 441, 1, 0, 0, 0, 442, 443, 1, 0, 0, 0, 443, 447,
		1, 0, 0, 0, 444, 446, 3, 48, 24, 0, 445, 444, 1, 0, 0, 0, 446, 449, 1,
		0, 0, 0, 447, 445, 1, 0, 0, 0, 447, 448, 1, 0, 0, 0, 448, 23, 1, 0, 0,
		0, 449, 447, 1, 0, 0, 0, 450, 451, 3, 26, 13, 0, 451, 452, 5, 35, 0, 0,
		452, 456, 1, 0, 0, 0, 453, 456, 3, 276, 138, 0, 454, 456, 5, 35, 0, 0,
		455, 450, 1, 0, 0, 0, 455, 453, 1, 0, 0, 0, 455, 454, 1, 0, 0, 0, 456,
		25, 1, 0, 0, 0, 457, 458, 5, 58, 0, 0, 458, 460, 3, 278, 139, 0, 459, 461,
		3, 28, 14, 0, 460, 459, 1, 0, 0, 0, 460, 461, 1, 0, 0, 0, 461, 27, 1, 0,
		0, 0, 462, 463, 5, 45, 0, 0, 463, 464, 3, 278, 139, 0, 464, 29, 1, 0, 0,
		0, 465, 466, 5, 21, 0, 0, 466, 467, 3, 38, 19, 0, 467, 31, 1, 0, 0, 0,
		468, 469, 5, 101, 0, 0, 469, 470, 3, 42, 21, 0, 470, 33, 1, 0, 0, 0, 471,
		472, 5, 122, 0, 0, 472, 473, 3, 42, 21, 0, 473, 35, 1, 0, 0, 0, 474, 475,
		5, 122, 0, 0, 475, 476, 3, 38, 19, 0, 476, 37, 1, 0, 0, 0, 477, 482, 3,
		40, 20, 0, 478, 479, 5, 139, 0, 0, 479, 481, 3, 40, 20, 0, 480, 478, 1,
		0, 0, 0, 481, 484, 1, 0, 0, 0, 482, 480, 1, 0, 0, 0, 482, 483, 1, 0, 0,
		0, 483, 485, 1, 0, 0, 0, 484, 482, 1, 0, 0, 0, 485, 486, 5, 140, 0, 0,
		486, 39, 1, 0, 0, 0, 487, 490, 3, 346, 173, 0, 488, 489, 5, 55, 0, 0, 489,
		491, 5, 189, 0, 0, 490, 488, 1, 0, 0, 0, 490, 491, 1, 0, 0, 0, 491, 41,
		1, 0, 0, 0, 492, 497, 3, 346, 173, 0, 493, 494, 5, 139, 0, 0, 494, 496,
		3, 346, 173, 0, 495, 493, 1, 0, 0, 0, 496, 499, 1, 0, 0, 0, 497, 495, 1,
		0, 0, 0, 497, 498, 1, 0, 0, 0, 498, 500, 1, 0, 0, 0, 499, 497, 1, 0, 0,
		0, 500, 501, 5, 140, 0, 0, 501, 43, 1, 0, 0, 0, 502, 504, 3, 48, 24, 0,
		503, 502, 1, 0, 0, 0, 504, 507, 1, 0, 0, 0, 505, 503, 1, 0, 0, 0, 505,
		506, 1, 0, 0, 0, 506, 509, 1, 0, 0, 0, 507, 505, 1, 0, 0, 0, 508, 510,
		3, 46, 23, 0, 509, 508, 1, 0, 0, 0, 509, 510, 1, 0, 0, 0, 510, 45, 1, 0,
		0, 0, 511, 514, 3, 276, 138, 0, 512, 514, 3, 300, 150, 0, 513, 511, 1,
		0, 0, 0, 513, 512, 1, 0, 0, 0, 514, 47, 1, 0, 0, 0, 515, 524, 3, 52, 26,
		0, 516, 524, 3, 54, 27, 0, 517, 524, 3, 60, 30, 0, 518, 524, 3, 64, 32,
		0, 519, 524, 3, 200, 100, 0, 520, 524, 3, 202, 101, 0, 521, 524, 3, 210,
		105, 0, 522, 524, 3, 72, 36, 0, 523, 515, 1, 0, 0, 0, 523, 516, 1, 0, 0,
		0, 523, 517, 1, 0, 0, 0, 523, 518, 1, 0, 0, 0, 523, 519, 1, 0, 0, 0, 523,
		520, 1, 0, 0, 0, 523, 521, 1, 0, 0, 0, 523, 522, 1, 0, 0, 0, 524, 49, 1,
		0, 0, 0, 525, 533, 3, 210, 105, 0, 526, 533, 3, 202, 101, 0, 527, 533,
		3, 60, 30, 0, 528, 533, 3, 64, 32, 0, 529, 533, 3, 200, 100, 0, 530, 533,
		3, 72, 36, 0, 531, 533, 3, 54, 27, 0, 532, 525, 1, 0, 0, 0, 532, 526, 1,
		0, 0, 0, 532, 527, 1, 0, 0, 0, 532, 528, 1, 0, 0, 0, 532, 529, 1, 0, 0,
		0, 532, 530, 1, 0, 0, 0, 532, 531, 1, 0, 0, 0, 533, 51, 1, 0, 0, 0, 534,
		535, 5, 62, 0, 0, 535, 540, 3, 338, 169, 0, 536, 537, 5, 139, 0, 0, 537,
		539, 3, 338, 169, 0, 538, 536, 1, 0, 0, 0, 539, 542, 1, 0, 0, 0, 540, 538,
		1, 0, 0, 0, 540, 541, 1, 0, 0, 0, 541, 543, 1, 0, 0, 0, 542, 540, 1, 0,
		0, 0, 543, 544, 5, 140, 0, 0, 544, 53, 1, 0, 0, 0, 545, 549, 3, 56, 28,
		0, 546, 548, 3, 58, 29, 0, 547, 546, 1, 0, 0, 0, 548, 551, 1, 0, 0, 0,
		549, 547, 1, 0, 0, 0, 549, 550, 1, 0, 0, 0, 550, 55, 1, 0, 0, 0, 551, 549,
		1, 0, 0, 0, 552, 553, 7, 0, 0, 0, 553, 57, 1, 0, 0, 0, 554, 556, 3, 226,
		113, 0, 555, 554, 1, 0, 0, 0, 555, 556, 1, 0, 0, 0, 556, 557, 1, 0, 0,
		0, 557, 560, 3, 330, 165, 0, 558, 559, 5, 141, 0, 0, 559, 561, 3, 76, 38,
		0, 560, 558, 1, 0, 0, 0, 560, 561, 1, 0, 0, 0, 561, 562, 1, 0, 0, 0, 562,
		563, 5, 142, 0, 0, 563, 567, 3, 284, 142, 0, 564, 566, 3, 322, 161, 0,
		565, 564, 1, 0, 0, 0, 566, 569, 1, 0, 0, 0, 567, 565, 1, 0, 0, 0, 567,
		568, 1, 0, 0, 0, 568, 570, 1, 0, 0, 0, 569, 567, 1, 0, 0, 0, 570, 571,
		5, 140, 0, 0, 571, 59, 1, 0, 0, 0, 572, 573, 5, 118, 0, 0, 573, 577, 3,
		62, 31, 0, 574, 576, 3, 62, 31, 0, 575, 574, 1, 0, 0, 0, 576, 579, 1, 0,
		0, 0, 577, 575, 1, 0, 0, 0, 577, 578, 1, 0, 0, 0, 578, 61, 1, 0, 0, 0,
		579, 577, 1, 0, 0, 0, 580, 582, 3, 226, 113, 0, 581, 580, 1, 0, 0, 0, 581,
		582, 1, 0, 0, 0, 582, 583, 1, 0, 0, 0, 583, 584, 3, 118, 59, 0, 584, 585,
		5, 142, 0, 0, 585, 589, 3, 76, 38, 0, 586, 588, 3, 322, 161, 0, 587, 586,
		1, 0, 0, 0, 588, 591, 1, 0, 0, 0, 589, 587, 1, 0, 0, 0, 589, 590, 1, 0,
		0, 0, 590, 592, 1, 0, 0, 0, 591, 589, 1, 0, 0, 0, 592, 593, 5, 140, 0,
		0, 593, 63, 1, 0, 0, 0, 594, 595, 3, 66, 33, 0, 595, 599, 3, 68, 34, 0,
		596, 598, 3, 68, 34, 0, 597, 596, 1, 0, 0, 0, 598, 601, 1, 0, 0, 0, 599,
		597, 1, 0, 0, 0, 599, 600, 1, 0, 0, 0, 600, 65, 1, 0, 0, 0, 601, 599, 1,
		0, 0, 0, 602, 603, 7, 1, 0, 0, 603, 67, 1, 0, 0, 0, 604, 606, 3, 226, 113,
		0, 605, 604, 1, 0, 0, 0, 605, 606, 1, 0, 0, 0, 606, 607, 1, 0, 0, 0, 607,
		608, 3, 336, 168, 0, 608, 609, 5, 141, 0, 0, 609, 611, 3, 76, 38, 0, 610,
		612, 3, 70, 35, 0, 611, 610, 1, 0, 0, 0, 611, 612, 1, 0, 0, 0, 612, 616,
		1, 0, 0, 0, 613, 615, 3, 322, 161, 0, 614, 613, 1, 0, 0, 0, 615, 618, 1,
		0, 0, 0, 616, 614, 1, 0, 0, 0, 616, 617, 1, 0, 0, 0, 617, 619, 1, 0, 0,
		0, 618, 616, 1, 0, 0, 0, 619, 620, 5, 140, 0, 0, 620, 69, 1, 0, 0, 0, 621,
		622, 5, 2, 0, 0, 622, 628, 3, 330, 165, 0, 623, 624, 5, 2, 0, 0, 624, 628,
		3, 284, 142, 0, 625, 626, 5, 142, 0, 0, 626, 628, 3, 284, 142, 0, 627,
		621, 1, 0, 0, 0, 627, 623, 1, 0, 0, 0, 627, 625, 1, 0, 0, 0, 628, 71, 1,
		0, 0, 0, 629, 630, 5, 40, 0, 0, 630, 631, 3, 330, 165, 0, 631, 638, 3,
		74, 37, 0, 632, 633, 5, 139, 0, 0, 633, 634, 3, 330, 165, 0, 634, 635,
		3, 74, 37, 0, 635, 637, 1, 0, 0, 0, 636, 632, 1, 0, 0, 0, 637, 640, 1,
		0, 0, 0, 638, 636, 1, 0, 0, 0, 638, 639, 1, 0, 0, 0, 639, 641, 1, 0, 0,
		0, 640, 638, 1, 0, 0, 0, 641, 642, 5, 140, 0, 0, 642, 73, 1, 0, 0, 0, 643,
		645, 5, 148, 0, 0, 644, 646, 3, 216, 108, 0, 645, 644, 1, 0, 0, 0, 645,
		646, 1, 0, 0, 0, 646, 647, 1, 0, 0, 0, 647, 649, 5, 149, 0, 0, 648, 643,
		1, 0, 0, 0, 648, 649, 1, 0, 0, 0, 649, 652, 1, 0, 0, 0, 650, 651, 5, 56,
		0, 0, 651, 653, 3, 232, 116, 0, 652, 650, 1, 0, 0, 0, 652, 653, 1, 0, 0,
		0, 653, 656, 1, 0, 0, 0, 654, 655, 5, 67, 0, 0, 655, 657, 3, 232, 116,
		0, 656, 654, 1, 0, 0, 0, 656, 657, 1, 0, 0, 0, 657, 659, 1, 0, 0, 0, 658,
		660, 5, 102, 0, 0, 659, 658, 1, 0, 0, 0, 659, 660, 1, 0, 0, 0, 660, 75,
		1, 0, 0, 0, 661, 675, 3, 78, 39, 0, 662, 675, 3, 92, 46, 0, 663, 675, 3,
		94, 47, 0, 664, 675, 3, 98, 49, 0, 665, 675, 3, 108, 54, 0, 666, 668, 5,
		118, 0, 0, 667, 666, 1, 0, 0, 0, 667, 668, 1, 0, 0, 0, 668, 669, 1, 0,
		0, 0, 669, 671, 3, 116, 58, 0, 670, 672, 3, 130, 65, 0, 671, 670, 1, 0,
		0, 0, 671, 672, 1, 0, 0, 0, 672, 675, 1, 0, 0, 0, 673, 675, 3, 110, 55,
		0, 674, 661, 1, 0, 0, 0, 674, 662, 1, 0, 0, 0, 674, 663, 1, 0, 0, 0, 674,
		664, 1, 0, 0, 0, 674, 665, 1, 0, 0, 0, 674, 667, 1, 0, 0, 0, 674, 673,
		1, 0, 0, 0, 675, 77, 1, 0, 0, 0, 676, 678, 5, 81, 0, 0, 677, 676, 1, 0,
		0, 0, 677, 678, 1, 0, 0, 0, 678, 679, 1, 0, 0, 0, 679, 680, 3, 80, 40,
		0, 680, 79, 1, 0, 0, 0, 681, 686, 3, 82, 41, 0, 682, 686, 3, 88, 44, 0,
		683, 686, 3, 90, 45, 0, 684, 686, 3, 132, 66, 0, 685, 681, 1, 0, 0, 0,
		685, 682, 1, 0, 0, 0, 685, 683, 1, 0, 0, 0, 685, 684, 1, 0, 0, 0, 686,
		81, 1, 0, 0, 0, 687, 702, 5, 7, 0, 0, 688, 690, 5, 150, 0, 0, 689, 691,
		3, 84, 42, 0, 690, 689, 1, 0, 0, 0, 690, 691, 1, 0, 0, 0, 691, 698, 1,
		0, 0, 0, 692, 694, 5, 139, 0, 0, 693, 695, 3, 84, 42, 0, 694, 693, 1, 0,
		0, 0, 694, 695, 1, 0, 0, 0, 695, 697, 1, 0, 0, 0, 696, 692, 1, 0, 0, 0,
		697, 700, 1, 0, 0, 0, 698, 696, 1, 0, 0, 0, 698, 699, 1, 0, 0, 0, 699,
		701, 1, 0, 0, 0, 700, 698, 1, 0, 0, 0, 701, 703, 5, 152, 0, 0, 702, 688,
		1, 0, 0, 0, 702, 703, 1, 0, 0, 0, 703, 704, 1, 0, 0, 0, 704, 705, 5, 73,
		0, 0, 705, 706, 3, 86, 43, 0, 706, 83, 1, 0, 0, 0, 707, 713, 3, 116, 58,
		0, 708, 709, 3, 232, 116, 0, 709, 710, 5, 157, 0, 0, 710, 711, 3, 232,
		116, 0, 711, 713, 1, 0, 0, 0, 712, 707, 1, 0, 0, 0, 712, 708, 1, 0, 0,
		0, 713, 85, 1, 0, 0, 0, 714, 717, 5, 19, 0, 0, 715, 717, 3, 76, 38, 0,
		716, 714, 1, 0, 0, 0, 716, 715, 1, 0, 0, 0, 717, 87, 1, 0, 0, 0, 718, 719,
		5, 106, 0, 0, 719, 720, 5, 73, 0, 0, 720, 721, 3, 76, 38, 0, 721, 89, 1,
		0, 0, 0, 722, 725, 5, 43, 0, 0, 723, 724, 5, 73, 0, 0, 724, 726, 3, 76,
		38, 0, 725, 723, 1, 0, 0, 0, 725, 726, 1, 0, 0, 0, 726, 91, 1, 0, 0, 0,
		727, 728, 5, 154, 0, 0, 728, 731, 3, 76, 38, 0, 729, 731, 5, 84, 0, 0,
		730, 727, 1, 0, 0, 0, 730, 729, 1, 0, 0, 0, 731, 93, 1, 0, 0, 0, 732, 737,
		5, 113, 0, 0, 733, 734, 5, 150, 0, 0, 734, 735, 3, 232, 116, 0, 735, 736,
		5, 152, 0, 0, 736, 738, 1, 0, 0, 0, 737, 733, 1, 0, 0, 0, 737, 738, 1,
		0, 0, 0, 738, 747, 1, 0, 0, 0, 739, 741, 5, 118, 0, 0, 740, 739, 1, 0,
		0, 0, 740, 741, 1, 0, 0, 0, 741, 742, 1, 0, 0, 0, 742, 744, 5, 6, 0, 0,
		743, 745, 3, 96, 48, 0, 744, 743, 1, 0, 0, 0, 744, 745, 1, 0, 0, 0, 745,
		747, 1, 0, 0, 0, 746, 732, 1, 0, 0, 0, 746, 740, 1, 0, 0, 0, 747, 95, 1,
		0, 0, 0, 748, 749, 5, 148, 0, 0, 749, 750, 3, 340, 170, 0, 750, 751, 5,
		149, 0, 0, 751, 97, 1, 0, 0, 0, 752, 756, 3, 100, 50, 0, 753, 756, 3, 102,
		51, 0, 754, 756, 3, 104, 52, 0, 755, 752, 1, 0, 0, 0, 755, 753, 1, 0, 0,
		0, 755, 754, 1, 0, 0, 0, 756, 99, 1, 0, 0, 0, 757, 758, 3, 106, 53, 0,
		758, 759, 5, 73, 0, 0, 759, 760, 5, 72, 0, 0, 760, 101, 1, 0, 0, 0, 761,
		766, 3, 106, 53, 0, 762, 764, 5, 140, 0, 0, 763, 762, 1, 0, 0, 0, 763,
		764, 1, 0, 0, 0, 764, 765, 1, 0, 0, 0, 765, 767, 3, 318, 159, 0, 766, 763,
		1, 0, 0, 0, 766, 767, 1, 0, 0, 0, 767, 103, 1, 0, 0, 0, 768, 769, 5, 96,
		0, 0, 769, 770, 5, 116, 0, 0, 770, 771, 3, 106, 53, 0, 771, 105, 1, 0,
		0, 0, 772, 774, 5, 49, 0, 0, 773, 775, 3, 214, 107, 0, 774, 773, 1, 0,
		0, 0, 774, 775, 1, 0, 0, 0, 775, 776, 1, 0, 0, 0, 776, 778, 5, 141, 0,
		0, 777, 779, 3, 226, 113, 0, 778, 777, 1, 0, 0, 0, 778, 779, 1, 0, 0, 0,
		779, 780, 1, 0, 0, 0, 780, 786, 3, 76, 38, 0, 781, 783, 5, 86, 0, 0, 782,
		784, 3, 214, 107, 0, 783, 782, 1, 0, 0, 0, 783, 784, 1, 0, 0, 0, 784, 786,
		1, 0, 0, 0, 785, 772, 1, 0, 0, 0, 785, 781, 1, 0, 0, 0, 786, 107, 1, 0,
		0, 0, 787, 788, 5, 125, 0, 0, 788, 109, 1, 0, 0, 0, 789, 793, 3, 330, 165,
		0, 790, 793, 3, 112, 56, 0, 791, 793, 3, 114, 57, 0, 792, 789, 1, 0, 0,
		0, 792, 790, 1, 0, 0, 0, 792, 791, 1, 0, 0, 0, 793, 111, 1, 0, 0, 0, 794,
		797, 3, 284, 142, 0, 795, 796, 5, 157, 0, 0, 796, 798, 3, 284, 142, 0,
		797, 795, 1, 0, 0, 0, 797, 798, 1, 0, 0, 0, 798, 113, 1, 0, 0, 0, 799,
		800, 5, 148, 0, 0, 800, 803, 3, 330, 165, 0, 801, 802, 5, 142, 0, 0, 802,
		804, 3, 232, 116, 0, 803, 801, 1, 0, 0, 0, 803, 804, 1, 0, 0, 0, 804, 813,
		1, 0, 0, 0, 805, 806, 5, 139, 0, 0, 806, 809, 3, 330, 165, 0, 807, 808,
		5, 142, 0, 0, 808, 810, 3, 232, 116, 0, 809, 807, 1, 0, 0, 0, 809, 810,
		1, 0, 0, 0, 810, 812, 1, 0, 0, 0, 811, 805, 1, 0, 0, 0, 812, 815, 1, 0,
		0, 0, 813, 811, 1, 0, 0, 0, 813, 814, 1, 0, 0, 0, 814, 816, 1, 0, 0, 0,
		815, 813, 1, 0, 0, 0, 816, 817, 5, 149, 0, 0, 817, 115, 1, 0, 0, 0, 818,
		819, 3, 344, 172, 0, 819, 117, 1, 0, 0, 0, 820, 822, 3, 348, 174, 0, 821,
		823, 3, 120, 60, 0, 822, 821, 1, 0, 0, 0, 822, 823, 1, 0, 0, 0, 823, 119,
		1, 0, 0, 0, 824, 827, 3, 122, 61, 0, 825, 827, 3, 124, 62, 0, 826, 824,
		1, 0, 0, 0, 826, 825, 1, 0, 0, 0, 827, 121, 1, 0, 0, 0, 828, 829, 5, 144,
		0, 0, 829, 834, 3, 330, 165, 0, 830, 831, 5, 139, 0, 0, 831, 833, 3, 330,
		165, 0, 832, 830, 1, 0, 0, 0, 833, 836, 1, 0, 0, 0, 834, 832, 1, 0, 0,
		0, 834, 835, 1, 0, 0, 0, 835, 837, 1, 0, 0, 0, 836, 834, 1, 0, 0, 0, 837,
		838, 5, 147, 0, 0, 838, 123, 1, 0, 0, 0, 839, 840, 5, 144, 0, 0, 840, 845,
		3, 126, 63, 0, 841, 842, 5, 140, 0, 0, 842, 844, 3, 126, 63, 0, 843, 841,
		1, 0, 0, 0, 844, 847, 1, 0, 0, 0, 845, 843, 1, 0, 0, 0, 845, 846, 1, 0,
		0, 0, 846, 848, 1, 0, 0, 0, 847, 845, 1, 0, 0, 0, 848, 849, 5, 147, 0,
		0, 849, 125, 1, 0, 0, 0, 850, 860, 3, 330, 165, 0, 851, 852, 5, 141, 0,
		0, 852, 857, 3, 128, 64, 0, 853, 854, 5, 139, 0, 0, 854, 856, 3, 128, 64,
		0, 855, 853, 1, 0, 0, 0, 856, 859, 1, 0, 0, 0, 857, 855, 1, 0, 0, 0, 857,
		858, 1, 0, 0, 0, 858, 861, 1, 0, 0, 0, 859, 857, 1, 0, 0, 0, 860, 851,
		1, 0, 0, 0, 860, 861, 1, 0, 0, 0, 861, 127, 1, 0, 0, 0, 862, 865, 3, 330,
		165, 0, 863, 865, 7, 2, 0, 0, 864, 862, 1, 0, 0, 0, 864, 863, 1, 0, 0,
		0, 865, 129, 1, 0, 0, 0, 866, 867, 5, 144, 0, 0, 867, 872, 3, 76, 38, 0,
		868, 869, 5, 139, 0, 0, 869, 871, 3, 76, 38, 0, 870, 868, 1, 0, 0, 0, 871,
		874, 1, 0, 0, 0, 872, 870, 1, 0, 0, 0, 872, 873, 1, 0, 0, 0, 873, 875,
		1, 0, 0, 0, 874, 872, 1, 0, 0, 0, 875, 876, 5, 147, 0, 0, 876, 131, 1,
		0, 0, 0, 877, 885, 3, 134, 67, 0, 878, 885, 3, 136, 68, 0, 879, 885, 3,
		144, 72, 0, 880, 885, 3, 148, 74, 0, 881, 885, 3, 156, 78, 0, 882, 885,
		3, 160, 80, 0, 883, 885, 3, 176, 88, 0, 884, 877, 1, 0, 0, 0, 884, 878,
		1, 0, 0, 0, 884, 879, 1, 0, 0, 0, 884, 880, 1, 0, 0, 0, 884, 881, 1, 0,
		0, 0, 884, 882, 1, 0, 0, 0, 884, 883, 1, 0, 0, 0, 885, 133, 1, 0, 0, 0,
		886, 887, 5, 18, 0, 0, 887, 888, 5, 73, 0, 0, 888, 889, 3, 116, 58, 0,
		889, 135, 1, 0, 0, 0, 890, 892, 5, 18, 0, 0, 891, 893, 3, 138, 69, 0, 892,
		891, 1, 0, 0, 0, 892, 893, 1, 0, 0, 0, 893, 895, 1, 0, 0, 0, 894, 896,
		3, 140, 70, 0, 895, 894, 1, 0, 0, 0, 895, 896, 1, 0, 0, 0, 896, 900, 1,
		0, 0, 0, 897, 899, 3, 142, 71, 0, 898, 897, 1, 0, 0, 0, 899, 902, 1, 0,
		0, 0, 900, 898, 1, 0, 0, 0, 900, 901, 1, 0, 0, 0, 901, 903, 1, 0, 0, 0,
		902, 900, 1, 0, 0, 0, 903, 909, 5, 35, 0, 0, 904, 906, 5, 18, 0, 0, 905,
		907, 3, 140, 70, 0, 906, 905, 1, 0, 0, 0, 906, 907, 1, 0, 0, 0, 907, 909,
		1, 0, 0, 0, 908, 890, 1, 0, 0, 0, 908, 904, 1, 0, 0, 0, 909, 137, 1, 0,
		0, 0, 910, 911, 7, 3, 0, 0, 911, 139, 1, 0, 0, 0, 912, 913, 5, 148, 0,
		0, 913, 918, 3, 118, 59, 0, 914, 915, 5, 139, 0, 0, 915, 917, 3, 118, 59,
		0, 916, 914, 1, 0, 0, 0, 917, 920, 1, 0, 0, 0, 918, 916, 1, 0, 0, 0, 918,
		919, 1, 0, 0, 0, 919, 921, 1, 0, 0, 0, 920, 918, 1, 0, 0, 0, 921, 922,
		5, 149, 0, 0, 922, 141, 1, 0, 0, 0, 923, 934, 3, 198, 99, 0, 924, 934,
		3, 180, 90, 0, 925, 934, 3, 182, 91, 0, 926, 934, 3, 184, 92, 0, 927, 934,
		3, 54, 27, 0, 928, 934, 3, 60, 30, 0, 929, 931, 5, 18, 0, 0, 930, 929,
		1, 0, 0, 0, 930, 931, 1, 0, 0, 0, 931, 932, 1, 0, 0, 0, 932, 934, 3, 64,
		32, 0, 933, 923, 1, 0, 0, 0, 933, 924, 1, 0, 0, 0, 933, 925, 1, 0, 0, 0,
		933, 926, 1, 0, 0, 0, 933, 927, 1, 0, 0, 0, 933, 928, 1, 0, 0, 0, 933,
		930, 1, 0, 0, 0, 934, 143, 1, 0, 0, 0, 935, 936, 5, 18, 0, 0, 936, 938,
		5, 51, 0, 0, 937, 939, 3, 140, 70, 0, 938, 937, 1, 0, 0, 0, 938, 939, 1,
		0, 0, 0, 939, 940, 1, 0, 0, 0, 940, 941, 5, 47, 0, 0, 941, 945, 3, 116,
		58, 0, 942, 944, 3, 146, 73, 0, 943, 942, 1, 0, 0, 0, 944, 947, 1, 0, 0,
		0, 945, 943, 1, 0, 0, 0, 945, 946, 1, 0, 0, 0, 946, 948, 1, 0, 0, 0, 947,
		945, 1, 0, 0, 0, 948, 949, 5, 35, 0, 0, 949, 145, 1, 0, 0, 0, 950, 958,
		3, 198, 99, 0, 951, 958, 3, 180, 90, 0, 952, 958, 3, 184, 92, 0, 953, 955,
		5, 18, 0, 0, 954, 953, 1, 0, 0, 0, 954, 955, 1, 0, 0, 0, 955, 956, 1, 0,
		0, 0, 956, 958, 3, 64, 32, 0, 957, 950, 1, 0, 0, 0, 957, 951, 1, 0, 0,
		0, 957, 952, 1, 0, 0, 0, 957, 954, 1, 0, 0, 0, 958, 147, 1, 0, 0, 0, 959,
		961, 3, 150, 75, 0, 960, 962, 3, 140, 70, 0, 961, 960, 1, 0, 0, 0, 961,
		962, 1, 0, 0, 0, 962, 964, 1, 0, 0, 0, 963, 965, 3, 152, 76, 0, 964, 963,
		1, 0, 0, 0, 964, 965, 1, 0, 0, 0, 965, 969, 1, 0, 0, 0, 966, 968, 3, 154,
		77, 0, 967, 966, 1, 0, 0, 0, 968, 971, 1, 0, 0, 0, 969, 967, 1, 0, 0, 0,
		969, 970, 1, 0, 0, 0, 970, 972, 1, 0, 0, 0, 971, 969, 1, 0, 0, 0, 972,
		973, 5, 35, 0, 0, 973, 979, 1, 0, 0, 0, 974, 976, 3, 150, 75, 0, 975, 977,
		3, 140, 70, 0, 976, 975, 1, 0, 0, 0, 976, 977, 1, 0, 0, 0, 977, 979, 1,
		0, 0, 0, 978, 959, 1, 0, 0, 0, 978, 974, 1, 0, 0, 0, 979, 149, 1, 0, 0,
		0, 980, 981, 7, 4, 0, 0, 981, 151, 1, 0, 0, 0, 982, 983, 5, 150, 0, 0,
		983, 984, 5, 189, 0, 0, 984, 985, 5, 152, 0, 0, 985, 153, 1, 0, 0, 0, 986,
		992, 3, 180, 90, 0, 987, 989, 5, 18, 0, 0, 988, 987, 1, 0, 0, 0, 988, 989,
		1, 0, 0, 0, 989, 990, 1, 0, 0, 0, 990, 992, 3, 184, 92, 0, 991, 986, 1,
		0, 0, 0, 991, 988, 1, 0, 0, 0, 992, 155, 1, 0, 0, 0, 993, 995, 5, 72, 0,
		0, 994, 996, 3, 140, 70, 0, 995, 994, 1, 0, 0, 0, 995, 996, 1, 0, 0, 0,
		996, 1000, 1, 0, 0, 0, 997, 999, 3, 158, 79, 0, 998, 997, 1, 0, 0, 0, 999,
		1002, 1, 0, 0, 0, 1000, 998, 1, 0, 0, 0, 1000, 1001, 1, 0, 0, 0, 1001,
		1003, 1, 0, 0, 0, 1002, 1000, 1, 0, 0, 0, 1003, 1004, 5, 35, 0, 0, 1004,
		157, 1, 0, 0, 0, 1005, 1009, 3, 198, 99, 0, 1006, 1009, 3, 180, 90, 0,
		1007, 1009, 3, 182, 91, 0, 1008, 1005, 1, 0, 0, 0, 1008, 1006, 1, 0, 0,
		0, 1008, 1007, 1, 0, 0, 0, 1009, 159, 1, 0, 0, 0, 1010, 1013, 3, 162, 81,
		0, 1011, 1013, 3, 164, 82, 0, 1012, 1010, 1, 0, 0, 0, 1012, 1011, 1, 0,
		0, 0, 1013, 161, 1, 0, 0, 0, 1014, 1018, 5, 95, 0, 0, 1015, 1017, 3, 168,
		84, 0, 1016, 1015, 1, 0, 0, 0, 1017, 1020, 1, 0, 0, 0, 1018, 1016, 1, 0,
		0, 0, 1018, 1019, 1, 0, 0, 0, 1019, 1024, 1, 0, 0, 0, 1020, 1018, 1, 0,
		0, 0, 1021, 1023, 3, 166, 83, 0, 1022, 1021, 1, 0, 0, 0, 1023, 1026, 1,
		0, 0, 0, 1024, 1022, 1, 0, 0, 0, 1024, 1025, 1, 0, 0, 0, 1025, 1027, 1,
		0, 0, 0, 1026, 1024, 1, 0, 0, 0, 1027, 1028, 5, 35, 0, 0, 1028, 163, 1,
		0, 0, 0, 1029, 1033, 5, 95, 0, 0, 1030, 1032, 3, 168, 84, 0, 1031, 1030,
		1, 0, 0, 0, 1032, 1035, 1, 0, 0, 0, 1033, 1031, 1, 0, 0, 0, 1033, 1034,
		1, 0, 0, 0, 1034, 1036, 1, 0, 0, 0, 1035, 1033, 1, 0, 0, 0, 1036, 1037,
		3, 172, 86, 0, 1037, 1038, 5, 35, 0, 0, 1038, 165, 1, 0, 0, 0, 1039, 1050,
		3, 198, 99, 0, 1040, 1050, 3, 180, 90, 0, 1041, 1050, 3, 184, 92, 0, 1042,
		1050, 3, 54, 27, 0, 1043, 1050, 3, 60, 30, 0, 1044, 1050, 3, 168, 84, 0,
		1045, 1047, 5, 18, 0, 0, 1046, 1045, 1, 0, 0, 0, 1046, 1047, 1, 0, 0, 0,
		1047, 1048, 1, 0, 0, 0, 1048, 1050, 3, 64, 32, 0, 1049, 1039, 1, 0, 0,
		0, 1049, 1040, 1, 0, 0, 0, 1049, 1041, 1, 0, 0, 0, 1049, 1042, 1, 0, 0,
		0, 1049, 1043, 1, 0, 0, 0, 1049, 1044, 1, 0, 0, 0, 1049, 1046, 1, 0, 0,
		0, 1050, 167, 1, 0, 0, 0, 1051, 1052, 3, 334, 167, 0, 1052, 1053, 5, 141,
		0, 0, 1053, 1057, 3, 76, 38, 0, 1054, 1056, 3, 322, 161, 0, 1055, 1054,
		1, 0, 0, 0, 1056, 1059, 1, 0, 0, 0, 1057, 1055, 1, 0, 0, 0, 1057, 1058,
		1, 0, 0, 0, 1058, 1061, 1, 0, 0, 0, 1059, 1057, 1, 0, 0, 0, 1060, 1062,
		5, 140, 0, 0, 1061, 1060, 1, 0, 0, 0, 1061, 1062, 1, 0, 0, 0, 1062, 169,
		1, 0, 0, 0, 1063, 1064, 3, 334, 167, 0, 1064, 1065, 5, 141, 0, 0, 1065,
		1069, 3, 76, 38, 0, 1066, 1068, 3, 322, 161, 0, 1067, 1066, 1, 0, 0, 0,
		1068, 1071, 1, 0, 0, 0, 1069, 1067, 1, 0, 0, 0, 1069, 1070, 1, 0, 0, 0,
		1070, 1073, 1, 0, 0, 0, 1071, 1069, 1, 0, 0, 0, 1072, 1074, 5, 140, 0,
		0, 1073, 1072, 1, 0, 0, 0, 1073, 1074, 1, 0, 0, 0, 1074, 171, 1, 0, 0,
		0, 1075, 1079, 5, 16, 0, 0, 1076, 1077, 3, 330, 165, 0, 1077, 1078, 5,
		141, 0, 0, 1078, 1080, 1, 0, 0, 0, 1079, 1076, 1, 0, 0, 0, 1079, 1080,
		1, 0, 0, 0, 1080, 1081, 1, 0, 0, 0, 1081, 1082, 3, 76, 38, 0, 1082, 1085,
		5, 73, 0, 0, 1083, 1086, 3, 174, 87, 0, 1084, 1086, 5, 140, 0, 0, 1085,
		1083, 1, 0, 0, 0, 1085, 1084, 1, 0, 0, 0, 1086, 1091, 1, 0, 0, 0, 1087,
		1090, 3, 174, 87, 0, 1088, 1090, 5, 140, 0, 0, 1089, 1087, 1, 0, 0, 0,
		1089, 1088, 1, 0, 0, 0, 1090, 1093, 1, 0, 0, 0, 1091, 1089, 1, 0, 0, 0,
		1091, 1092, 1, 0, 0, 0, 1092, 173, 1, 0, 0, 0, 1093, 1091, 1, 0, 0, 0,
		1094, 1099, 3, 284, 142, 0, 1095, 1096, 5, 139, 0, 0, 1096, 1098, 3, 284,
		142, 0, 1097, 1095, 1, 0, 0, 0, 1098, 1101, 1, 0, 0, 0, 1099, 1097, 1,
		0, 0, 0, 1099, 1100, 1, 0, 0, 0, 1100, 1102, 1, 0, 0, 0, 1101, 1099, 1,
		0, 0, 0, 1102, 1103, 5, 141, 0, 0, 1103, 1107, 5, 148, 0, 0, 1104, 1106,
		3, 170, 85, 0, 1105, 1104, 1, 0, 0, 0, 1106, 1109, 1, 0, 0, 0, 1107, 1105,
		1, 0, 0, 0, 1107, 1108, 1, 0, 0, 0, 1108, 1110, 1, 0, 0, 0, 1109, 1107,
		1, 0, 0, 0, 1110, 1111, 5, 149, 0, 0, 1111, 175, 1, 0, 0, 0, 1112, 1113,
		5, 95, 0, 0, 1113, 1114, 5, 51, 0, 0, 1114, 1115, 5, 47, 0, 0, 1115, 1119,
		3, 116, 58, 0, 1116, 1118, 3, 178, 89, 0, 1117, 1116, 1, 0, 0, 0, 1118,
		1121, 1, 0, 0, 0, 1119, 1117, 1, 0, 0, 0, 1119, 1120, 1, 0, 0, 0, 1120,
		1122, 1, 0, 0, 0, 1121, 1119, 1, 0, 0, 0, 1122, 1123, 5, 35, 0, 0, 1123,
		177, 1, 0, 0, 0, 1124, 1128, 3, 198, 99, 0, 1125, 1128, 3, 180, 90, 0,
		1126, 1128, 3, 184, 92, 0, 1127, 1124, 1, 0, 0, 0, 1127, 1125, 1, 0, 0,
		0, 1127, 1126, 1, 0, 0, 0, 1128, 179, 1, 0, 0, 0, 1129, 1131, 3, 226, 113,
		0, 1130, 1129, 1, 0, 0, 0, 1130, 1131, 1, 0, 0, 0, 1131, 1133, 1, 0, 0,
		0, 1132, 1134, 5, 18, 0, 0, 1133, 1132, 1, 0, 0, 0, 1133, 1134, 1, 0, 0,
		0, 1134, 1135, 1, 0, 0, 0, 1135, 1136, 3, 206, 103, 0, 1136, 1138, 3, 330,
		165, 0, 1137, 1139, 3, 120, 60, 0, 1138, 1137, 1, 0, 0, 0, 1138, 1139,
		1, 0, 0, 0, 1139, 1141, 1, 0, 0, 0, 1140, 1142, 3, 214, 107, 0, 1141, 1140,
		1, 0, 0, 0, 1141, 1142, 1, 0, 0, 0, 1142, 1143, 1, 0, 0, 0, 1143, 1147,
		5, 140, 0, 0, 1144, 1146, 3, 302, 151, 0, 1145, 1144, 1, 0, 0, 0, 1146,
		1149, 1, 0, 0, 0, 1147, 1145, 1, 0, 0, 0, 1147, 1148, 1, 0, 0, 0, 1148,
		1198, 1, 0, 0, 0, 1149, 1147, 1, 0, 0, 0, 1150, 1152, 3, 226, 113, 0, 1151,
		1150, 1, 0, 0, 0, 1151, 1152, 1, 0, 0, 0, 1152, 1154, 1, 0, 0, 0, 1153,
		1155, 5, 18, 0, 0, 1154, 1153, 1, 0, 0, 0, 1154, 1155, 1, 0, 0, 0, 1155,
		1156, 1, 0, 0, 0, 1156, 1157, 5, 49, 0, 0, 1157, 1159, 3, 330, 165, 0,
		1158, 1160, 3, 120, 60, 0, 1159, 1158, 1, 0, 0, 0, 1159, 1160, 1, 0, 0,
		0, 1160, 1162, 1, 0, 0, 0, 1161, 1163, 3, 214, 107, 0, 1162, 1161, 1, 0,
		0, 0, 1162, 1163, 1, 0, 0, 0, 1163, 1164, 1, 0, 0, 0, 1164, 1166, 5, 141,
		0, 0, 1165, 1167, 3, 226, 113, 0, 1166, 1165, 1, 0, 0, 0, 1166, 1167, 1,
		0, 0, 0, 1167, 1168, 1, 0, 0, 0, 1168, 1169, 3, 76, 38, 0, 1169, 1173,
		5, 140, 0, 0, 1170, 1172, 3, 302, 151, 0, 1171, 1170, 1, 0, 0, 0, 1172,
		1175, 1, 0, 0, 0, 1173, 1171, 1, 0, 0, 0, 1173, 1174, 1, 0, 0, 0, 1174,
		1198, 1, 0, 0, 0, 1175, 1173, 1, 0, 0, 0, 1176, 1178, 3, 226, 113, 0, 1177,
		1176, 1, 0, 0, 0, 1177, 1178, 1, 0, 0, 0, 1178, 1180, 1, 0, 0, 0, 1179,
		1181, 5, 18, 0, 0, 1180, 1179, 1, 0, 0, 0, 1180, 1181, 1, 0, 0, 0, 1181,
		1182, 1, 0, 0, 0, 1182, 1183, 5, 75, 0, 0, 1183, 1185, 3, 330, 165, 0,
		1184, 1186, 3, 120, 60, 0, 1185, 1184, 1, 0, 0, 0, 1185, 1186, 1, 0, 0,
		0, 1186, 1188, 1, 0, 0, 0, 1187, 1189, 3, 214, 107, 0, 1188, 1187, 1, 0,
		0, 0, 1188, 1189, 1, 0, 0, 0, 1189, 1190, 1, 0, 0, 0, 1190, 1192, 5, 141,
		0, 0, 1191, 1193, 3, 226, 113, 0, 1192, 1191, 1, 0, 0, 0, 1192, 1193, 1,
		0, 0, 0, 1193, 1194, 1, 0, 0, 0, 1194, 1195, 3, 76, 38, 0, 1195, 1196,
		5, 140, 0, 0, 1196, 1198, 1, 0, 0, 0, 1197, 1130, 1, 0, 0, 0, 1197, 1151,
		1, 0, 0, 0, 1197, 1177, 1, 0, 0, 0, 1198, 181, 1, 0, 0, 0, 1199, 1201,
		3, 226, 113, 0, 1200, 1199, 1, 0, 0, 0, 1200, 1201, 1, 0, 0, 0, 1201, 1202,
		1, 0, 0, 0, 1202, 1203, 3, 334, 167, 0, 1203, 1204, 5, 141, 0, 0, 1204,
		1205, 3, 76, 38, 0, 1205, 1209, 5, 140, 0, 0, 1206, 1208, 3, 322, 161,
		0, 1207, 1206, 1, 0, 0, 0, 1208, 1211, 1, 0, 0, 0, 1209, 1207, 1, 0, 0,
		0, 1209, 1210, 1, 0, 0, 0, 1210, 183, 1, 0, 0, 0, 1211, 1209, 1, 0, 0,
		0, 1212, 1214, 3, 226, 113, 0, 1213, 1212, 1, 0, 0, 0, 1213, 1214, 1, 0,
		0, 0, 1214, 1216, 1, 0, 0, 0, 1215, 1217, 5, 18, 0, 0, 1216, 1215, 1, 0,
		0, 0, 1216, 1217, 1, 0, 0, 0, 1217, 1218, 1, 0, 0, 0, 1218, 1219, 5, 88,
		0, 0, 1219, 1221, 3, 330, 165, 0, 1220, 1222, 3, 186, 93, 0, 1221, 1220,
		1, 0, 0, 0, 1221, 1222, 1, 0, 0, 0, 1222, 1225, 1, 0, 0, 0, 1223, 1224,
		5, 141, 0, 0, 1224, 1226, 3, 118, 59, 0, 1225, 1223, 1, 0, 0, 0, 1225,
		1226, 1, 0, 0, 0, 1226, 1228, 1, 0, 0, 0, 1227, 1229, 3, 188, 94, 0, 1228,
		1227, 1, 0, 0, 0, 1228, 1229, 1, 0, 0, 0, 1229, 1233, 1, 0, 0, 0, 1230,
		1232, 3, 190, 95, 0, 1231, 1230, 1, 0, 0, 0, 1232, 1235, 1, 0, 0, 0, 1233,
		1231, 1, 0, 0, 0, 1233, 1234, 1, 0, 0, 0, 1234, 1236, 1, 0, 0, 0, 1235,
		1233, 1, 0, 0, 0, 1236, 1240, 5, 140, 0, 0, 1237, 1239, 3, 192, 96, 0,
		1238, 1237, 1, 0, 0, 0, 1239, 1242, 1, 0, 0, 0, 1240, 1238, 1, 0, 0, 0,
		1240, 1241, 1, 0, 0, 0, 1241, 185, 1, 0, 0, 0, 1242, 1240, 1, 0, 0, 0,
		1243, 1244, 5, 150, 0, 0, 1244, 1245, 3, 216, 108, 0, 1245, 1246, 5, 152,
		0, 0, 1246, 187, 1, 0, 0, 0, 1247, 1248, 5, 56, 0, 0, 1248, 1250, 3, 232,
		116, 0, 1249, 1251, 5, 140, 0, 0, 1250, 1249, 1, 0, 0, 0, 1250, 1251, 1,
		0, 0, 0, 1251, 189, 1, 0, 0, 0, 1252, 1262, 3, 194, 97, 0, 1253, 1262,
		3, 196, 98, 0, 1254, 1255, 5, 111, 0, 0, 1255, 1262, 3, 232, 116, 0, 1256,
		1257, 5, 23, 0, 0, 1257, 1262, 3, 232, 116, 0, 1258, 1262, 7, 5, 0, 0,
		1259, 1260, 5, 54, 0, 0, 1260, 1262, 3, 116, 58, 0, 1261, 1252, 1, 0, 0,
		0, 1261, 1253, 1, 0, 0, 0, 1261, 1254, 1, 0, 0, 0, 1261, 1256, 1, 0, 0,
		0, 1261, 1258, 1, 0, 0, 0, 1261, 1259, 1, 0, 0, 0, 1262, 191, 1, 0, 0,
		0, 1263, 1264, 5, 111, 0, 0, 1264, 1265, 3, 232, 116, 0, 1265, 1266, 5,
		140, 0, 0, 1266, 1276, 1, 0, 0, 0, 1267, 1268, 5, 23, 0, 0, 1268, 1269,
		3, 232, 116, 0, 1269, 1270, 5, 140, 0, 0, 1270, 1276, 1, 0, 0, 0, 1271,
		1272, 5, 23, 0, 0, 1272, 1276, 5, 140, 0, 0, 1273, 1274, 5, 70, 0, 0, 1274,
		1276, 5, 140, 0, 0, 1275, 1263, 1, 0, 0, 0, 1275, 1267, 1, 0, 0, 0, 1275,
		1271, 1, 0, 0, 0, 1275, 1273, 1, 0, 0, 0, 1276, 193, 1, 0, 0, 0, 1277,
		1278, 5, 93, 0, 0, 1278, 1283, 3, 348, 174, 0, 1279, 1280, 5, 150, 0, 0,
		1280, 1281, 3, 232, 116, 0, 1281, 1282, 5, 152, 0, 0, 1282, 1284, 1, 0,
		0, 0, 1283, 1279, 1, 0, 0, 0, 1283, 1284, 1, 0, 0, 0, 1284, 1294, 1, 0,
		0, 0, 1285, 1286, 5, 129, 0, 0, 1286, 1291, 3, 348, 174, 0, 1287, 1288,
		5, 150, 0, 0, 1288, 1289, 3, 232, 116, 0, 1289, 1290, 5, 152, 0, 0, 1290,
		1292, 1, 0, 0, 0, 1291, 1287, 1, 0, 0, 0, 1291, 1292, 1, 0, 0, 0, 1292,
		1294, 1, 0, 0, 0, 1293, 1277, 1, 0, 0, 0, 1293, 1285, 1, 0, 0, 0, 1294,
		195, 1, 0, 0, 0, 1295, 1296, 5, 94, 0, 0, 1296, 1301, 5, 140, 0, 0, 1297,
		1298, 5, 130, 0, 0, 1298, 1301, 5, 140, 0, 0, 1299, 1301, 3, 328, 164,
		0, 1300, 1295, 1, 0, 0, 0, 1300, 1297, 1, 0, 0, 0, 1300, 1299, 1, 0, 0,
		0, 1301, 197, 1, 0, 0, 0, 1302, 1304, 5, 112, 0, 0, 1303, 1302, 1, 0, 0,
		0, 1303, 1304, 1, 0, 0, 0, 1304, 1305, 1, 0, 0, 0, 1305, 1312, 5, 89, 0,
		0, 1306, 1308, 5, 112, 0, 0, 1307, 1306, 1, 0, 0, 0, 1307, 1308, 1, 0,
		0, 0, 1308, 1309, 1, 0, 0, 0, 1309, 1312, 5, 85, 0, 0, 1310, 1312, 7, 6,
		0, 0, 1311, 1303, 1, 0, 0, 0, 1311, 1307, 1, 0, 0, 0, 1311, 1310, 1, 0,
		0, 0, 1312, 199, 1, 0, 0, 0, 1313, 1314, 5, 86, 0, 0, 1314, 1316, 3, 330,
		165, 0, 1315, 1317, 3, 214, 107, 0, 1316, 1315, 1, 0, 0, 0, 1316, 1317,
		1, 0, 0, 0, 1317, 1318, 1, 0, 0, 0, 1318, 1320, 5, 141, 0, 0, 1319, 1321,
		3, 226, 113, 0, 1320, 1319, 1, 0, 0, 0, 1320, 1321, 1, 0, 0, 0, 1321, 1322,
		1, 0, 0, 0, 1322, 1323, 3, 76, 38, 0, 1323, 1327, 5, 140, 0, 0, 1324, 1326,
		3, 304, 152, 0, 1325, 1324, 1, 0, 0, 0, 1326, 1329, 1, 0, 0, 0, 1327, 1325,
		1, 0, 0, 0, 1327, 1328, 1, 0, 0, 0, 1328, 1343, 1, 0, 0, 0, 1329, 1327,
		1, 0, 0, 0, 1330, 1331, 5, 49, 0, 0, 1331, 1333, 3, 330, 165, 0, 1332,
		1334, 3, 214, 107, 0, 1333, 1332, 1, 0, 0, 0, 1333, 1334, 1, 0, 0, 0, 1334,
		1335, 1, 0, 0, 0, 1335, 1339, 5, 140, 0, 0, 1336, 1338, 3, 304, 152, 0,
		1337, 1336, 1, 0, 0, 0, 1338, 1341, 1, 0, 0, 0, 1339, 1337, 1, 0, 0, 0,
		1339, 1340, 1, 0, 0, 0, 1340, 1343, 1, 0, 0, 0, 1341, 1339, 1, 0, 0, 0,
		1342, 1313, 1, 0, 0, 0, 1342, 1330, 1, 0, 0, 0, 1343, 201, 1, 0, 0, 0,
		1344, 1345, 3, 204, 102, 0, 1345, 1349, 5, 140, 0, 0, 1346, 1348, 3, 302,
		151, 0, 1347, 1346, 1, 0, 0, 0, 1348, 1351, 1, 0, 0, 0, 1349, 1347, 1,
		0, 0, 0, 1349, 1350, 1, 0, 0, 0, 1350, 1353, 1, 0, 0, 0, 1351, 1349, 1,
		0, 0, 0, 1352, 1354, 3, 222, 111, 0, 1353, 1352, 1, 0, 0, 0, 1353, 1354,
		1, 0, 0, 0, 1354, 203, 1, 0, 0, 0, 1355, 1357, 3, 226, 113, 0, 1356, 1355,
		1, 0, 0, 0, 1356, 1357, 1, 0, 0, 0, 1357, 1359, 1, 0, 0, 0, 1358, 1360,
		5, 18, 0, 0, 1359, 1358, 1, 0, 0, 0, 1359, 1360, 1, 0, 0, 0, 1360, 1361,
		1, 0, 0, 0, 1361, 1362, 3, 206, 103, 0, 1362, 1364, 3, 208, 104, 0, 1363,
		1365, 3, 214, 107, 0, 1364, 1363, 1, 0, 0, 0, 1364, 1365, 1, 0, 0, 0, 1365,
		1401, 1, 0, 0, 0, 1366, 1368, 3, 226, 113, 0, 1367, 1366, 1, 0, 0, 0, 1367,
		1368, 1, 0, 0, 0, 1368, 1370, 1, 0, 0, 0, 1369, 1371, 5, 18, 0, 0, 1370,
		1369, 1, 0, 0, 0, 1370, 1371, 1, 0, 0, 0, 1371, 1372, 1, 0, 0, 0, 1372,
		1373, 5, 49, 0, 0, 1373, 1375, 3, 208, 104, 0, 1374, 1376, 3, 214, 107,
		0, 1375, 1374, 1, 0, 0, 0, 1375, 1376, 1, 0, 0, 0, 1376, 1382, 1, 0, 0,
		0, 1377, 1379, 5, 141, 0, 0, 1378, 1380, 3, 226, 113, 0, 1379, 1378, 1,
		0, 0, 0, 1379, 1380, 1, 0, 0, 0, 1380, 1381, 1, 0, 0, 0, 1381, 1383, 3,
		76, 38, 0, 1382, 1377, 1, 0, 0, 0, 1382, 1383, 1, 0, 0, 0, 1383, 1401,
		1, 0, 0, 0, 1384, 1386, 3, 226, 113, 0, 1385, 1384, 1, 0, 0, 0, 1385, 1386,
		1, 0, 0, 0, 1386, 1387, 1, 0, 0, 0, 1387, 1388, 5, 18, 0, 0, 1388, 1389,
		5, 75, 0, 0, 1389, 1391, 3, 208, 104, 0, 1390, 1392, 3, 214, 107, 0, 1391,
		1390, 1, 0, 0, 0, 1391, 1392, 1, 0, 0, 0, 1392, 1398, 1, 0, 0, 0, 1393,
		1395, 5, 141, 0, 0, 1394, 1396, 3, 226, 113, 0, 1395, 1394, 1, 0, 0, 0,
		1395, 1396, 1, 0, 0, 0, 1396, 1397, 1, 0, 0, 0, 1397, 1399, 3, 76, 38,
		0, 1398, 1393, 1, 0, 0, 0, 1398, 1399, 1, 0, 0, 0, 1399, 1401, 1, 0, 0,
		0, 1400, 1356, 1, 0, 0, 0, 1400, 1367, 1, 0, 0, 0, 1400, 1385, 1, 0, 0,
		0, 1401, 205, 1, 0, 0, 0, 1402, 1403, 7, 7, 0, 0, 1403, 207, 1, 0, 0, 0,
		1404, 1406, 3, 330, 165, 0, 1405, 1407, 3, 120, 60, 0, 1406, 1405, 1, 0,
		0, 0, 1406, 1407, 1, 0, 0, 0, 1407, 1413, 1, 0, 0, 0, 1408, 1409, 5, 156,
		0, 0, 1409, 1411, 3, 330, 165, 0, 1410, 1412, 3, 120, 60, 0, 1411, 1410,
		1, 0, 0, 0, 1411, 1412, 1, 0, 0, 0, 1412, 1414, 1, 0, 0, 0, 1413, 1408,
		1, 0, 0, 0, 1413, 1414, 1, 0, 0, 0, 1414, 1415, 1, 0, 0, 0, 1415, 1416,
		5, 156, 0, 0, 1416, 1418, 3, 330, 165, 0, 1417, 1419, 3, 120, 60, 0, 1418,
		1417, 1, 0, 0, 0, 1418, 1419, 1, 0, 0, 0, 1419, 209, 1, 0, 0, 0, 1420,
		1421, 3, 212, 106, 0, 1421, 1425, 5, 140, 0, 0, 1422, 1424, 3, 304, 152,
		0, 1423, 1422, 1, 0, 0, 0, 1424, 1427, 1, 0, 0, 0, 1425, 1423, 1, 0, 0,
		0, 1425, 1426, 1, 0, 0, 0, 1426, 1429, 1, 0, 0, 0, 1427, 1425, 1, 0, 0,
		0, 1428, 1430, 3, 224, 112, 0, 1429, 1428, 1, 0, 0, 0, 1429, 1430, 1, 0,
		0, 0, 1430, 211, 1, 0, 0, 0, 1431, 1433, 3, 226, 113, 0, 1432, 1431, 1,
		0, 0, 0, 1432, 1433, 1, 0, 0, 0, 1433, 1434, 1, 0, 0, 0, 1434, 1435, 5,
		86, 0, 0, 1435, 1437, 3, 330, 165, 0, 1436, 1438, 3, 214, 107, 0, 1437,
		1436, 1, 0, 0, 0, 1437, 1438, 1, 0, 0, 0, 1438, 1451, 1, 0, 0, 0, 1439,
		1441, 3, 226, 113, 0, 1440, 1439, 1, 0, 0, 0, 1440, 1441, 1, 0, 0, 0, 1441,
		1442, 1, 0, 0, 0, 1442, 1443, 5, 49, 0, 0, 1443, 1445, 3, 330, 165, 0,
		1444, 1446, 3, 214, 107, 0, 1445, 1444, 1, 0, 0, 0, 1445, 1446, 1, 0, 0,
		0, 1446, 1447, 1, 0, 0, 0, 1447, 1448, 5, 141, 0, 0, 1448, 1449, 3, 76,
		38, 0, 1449, 1451, 1, 0, 0, 0, 1450, 1432, 1, 0, 0, 0, 1450, 1440, 1, 0,
		0, 0, 1451, 213, 1, 0, 0, 0, 1452, 1454, 5, 148, 0, 0, 1453, 1455, 3, 216,
		108, 0, 1454, 1453, 1, 0, 0, 0, 1454, 1455, 1, 0, 0, 0, 1455, 1456, 1,
		0, 0, 0, 1456, 1457, 5, 149, 0, 0, 1457, 215, 1, 0, 0, 0, 1458, 1463, 3,
		218, 109, 0, 1459, 1460, 5, 140, 0, 0, 1460, 1462, 3, 218, 109, 0, 1461,
		1459, 1, 0, 0, 0, 1462, 1465, 1, 0, 0, 0, 1463, 1461, 1, 0, 0, 0, 1463,
		1464, 1, 0, 0, 0, 1464, 217, 1, 0, 0, 0, 1465, 1463, 1, 0, 0, 0, 1466,
		1468, 3, 220, 110, 0, 1467, 1466, 1, 0, 0, 0, 1467, 1468, 1, 0, 0, 0, 1468,
		1469, 1, 0, 0, 0, 1469, 1472, 3, 336, 168, 0, 1470, 1471, 5, 141, 0, 0,
		1471, 1473, 3, 76, 38, 0, 1472, 1470, 1, 0, 0, 0, 1472, 1473, 1, 0, 0,
		0, 1473, 1476, 1, 0, 0, 0, 1474, 1475, 5, 142, 0, 0, 1475, 1477, 3, 232,
		116, 0, 1476, 1474, 1, 0, 0, 0, 1476, 1477, 1, 0, 0, 0, 1477, 219, 1, 0,
		0, 0, 1478, 1479, 7, 8, 0, 0, 1479, 221, 1, 0, 0, 0, 1480, 1481, 3, 44,
		22, 0, 1481, 1482, 5, 140, 0, 0, 1482, 223, 1, 0, 0, 0, 1483, 1484, 5,
		48, 0, 0, 1484, 1488, 5, 140, 0, 0, 1485, 1487, 3, 304, 152, 0, 1486, 1485,
		1, 0, 0, 0, 1487, 1490, 1, 0, 0, 0, 1488, 1486, 1, 0, 0, 0, 1488, 1489,
		1, 0, 0, 0, 1489, 1511, 1, 0, 0, 0, 1490, 1488, 1, 0, 0, 0, 1491, 1498,
		5, 41, 0, 0, 1492, 1493, 5, 67, 0, 0, 1493, 1497, 3, 232, 116, 0, 1494,
		1495, 5, 56, 0, 0, 1495, 1497, 3, 232, 116, 0, 1496, 1492, 1, 0, 0, 0,
		1496, 1494, 1, 0, 0, 0, 1497, 1500, 1, 0, 0, 0, 1498, 1496, 1, 0, 0, 0,
		1498, 1499, 1, 0, 0, 0, 1499, 1504, 1, 0, 0, 0, 1500, 1498, 1, 0, 0, 0,
		1501, 1503, 3, 304, 152, 0, 1502, 1501, 1, 0, 0, 0, 1503, 1506, 1, 0, 0,
		0, 1504, 1502, 1, 0, 0, 0, 1504, 1505, 1, 0, 0, 0, 1505, 1511, 1, 0, 0,
		0, 1506, 1504, 1, 0, 0, 0, 1507, 1508, 3, 44, 22, 0, 1508, 1509, 5, 140,
		0, 0, 1509, 1511, 1, 0, 0, 0, 1510, 1483, 1, 0, 0, 0, 1510, 1491, 1, 0,
		0, 0, 1510, 1507, 1, 0, 0, 0, 1511, 225, 1, 0, 0, 0, 1512, 1513, 5, 1,
		0, 0, 1513, 227, 1, 0, 0, 0, 1514, 1516, 3, 230, 115, 0, 1515, 1514, 1,
		0, 0, 0, 1516, 1519, 1, 0, 0, 0, 1517, 1515, 1, 0, 0, 0, 1517, 1518, 1,
		0, 0, 0, 1518, 229, 1, 0, 0, 0, 1519, 1517, 1, 0, 0, 0, 1520, 1521, 5,
		150, 0, 0, 1521, 1527, 3, 344, 172, 0, 1522, 1524, 5, 148, 0, 0, 1523,
		1525, 3, 248, 124, 0, 1524, 1523, 1, 0, 0, 0, 1524, 1525, 1, 0, 0, 0, 1525,
		1526, 1, 0, 0, 0, 1526, 1528, 5, 149, 0, 0, 1527, 1522, 1, 0, 0, 0, 1527,
		1528, 1, 0, 0, 0, 1528, 1529, 1, 0, 0, 0, 1529, 1530, 5, 152, 0, 0, 1530,
		231, 1, 0, 0, 0, 1531, 1543, 3, 234, 117, 0, 1532, 1536, 3, 236, 118, 0,
		1533, 1534, 3, 254, 127, 0, 1534, 1535, 3, 236, 118, 0, 1535, 1537, 1,
		0, 0, 0, 1536, 1533, 1, 0, 0, 0, 1536, 1537, 1, 0, 0, 0, 1537, 1540, 1,
		0, 0, 0, 1538, 1539, 5, 142, 0, 0, 1539, 1541, 3, 232, 116, 0, 1540, 1538,
		1, 0, 0, 0, 1540, 1541, 1, 0, 0, 0, 1541, 1543, 1, 0, 0, 0, 1542, 1531,
		1, 0, 0, 0, 1542, 1532, 1, 0, 0, 0, 1543, 233, 1, 0, 0, 0, 1544, 1546,
		5, 86, 0, 0, 1545, 1547, 3, 214, 107, 0, 1546, 1545, 1, 0, 0, 0, 1546,
		1547, 1, 0, 0, 0, 1547, 1548, 1, 0, 0, 0, 1548, 1558, 3, 44, 22, 0, 1549,
		1551, 5, 49, 0, 0, 1550, 1552, 3, 214, 107, 0, 1551, 1550, 1, 0, 0, 0,
		1551, 1552, 1, 0, 0, 0, 1552, 1553, 1, 0, 0, 0, 1553, 1554, 5, 141, 0,
		0, 1554, 1555, 3, 76, 38, 0, 1555, 1556, 3, 44, 22, 0, 1556, 1558, 1, 0,
		0, 0, 1557, 1544, 1, 0, 0, 0, 1557, 1549, 1, 0, 0, 0, 1558, 235, 1, 0,
		0, 0, 1559, 1565, 3, 238, 119, 0, 1560, 1561, 3, 252, 126, 0, 1561, 1562,
		3, 238, 119, 0, 1562, 1564, 1, 0, 0, 0, 1563, 1560, 1, 0, 0, 0, 1564, 1567,
		1, 0, 0, 0, 1565, 1563, 1, 0, 0, 0, 1565, 1566, 1, 0, 0, 0, 1566, 237,
		1, 0, 0, 0, 1567, 1565, 1, 0, 0, 0, 1568, 1569, 5, 155, 0, 0, 1569, 1602,
		3, 238, 119, 0, 1570, 1571, 5, 161, 0, 0, 1571, 1602, 3, 238, 119, 0, 1572,
		1573, 5, 71, 0, 0, 1573, 1602, 3, 238, 119, 0, 1574, 1575, 5, 134, 0, 0,
		1575, 1602, 3, 238, 119, 0, 1576, 1577, 5, 135, 0, 0, 1577, 1602, 3, 238,
		119, 0, 1578, 1579, 5, 154, 0, 0, 1579, 1602, 3, 330, 165, 0, 1580, 1602,
		3, 340, 170, 0, 1581, 1602, 3, 342, 171, 0, 1582, 1602, 7, 9, 0, 0, 1583,
		1584, 5, 148, 0, 0, 1584, 1585, 3, 232, 116, 0, 1585, 1587, 5, 149, 0,
		0, 1586, 1588, 5, 154, 0, 0, 1587, 1586, 1, 0, 0, 0, 1587, 1588, 1, 0,
		0, 0, 1588, 1591, 1, 0, 0, 0, 1589, 1590, 5, 156, 0, 0, 1590, 1592, 3,
		232, 116, 0, 1591, 1589, 1, 0, 0, 0, 1591, 1592, 1, 0, 0, 0, 1592, 1602,
		1, 0, 0, 0, 1593, 1602, 3, 240, 120, 0, 1594, 1602, 3, 242, 121, 0, 1595,
		1602, 3, 244, 122, 0, 1596, 1597, 3, 116, 58, 0, 1597, 1598, 5, 148, 0,
		0, 1598, 1599, 3, 232, 116, 0, 1599, 1600, 5, 149, 0, 0, 1600, 1602, 1,
		0, 0, 0, 1601, 1568, 1, 0, 0, 0, 1601, 1570, 1, 0, 0, 0, 1601, 1572, 1,
		0, 0, 0, 1601, 1574, 1, 0, 0, 0, 1601, 1576, 1, 0, 0, 0, 1601, 1578, 1,
		0, 0, 0, 1601, 1580, 1, 0, 0, 0, 1601, 1581, 1, 0, 0, 0, 1601, 1582, 1,
		0, 0, 0, 1601, 1583, 1, 0, 0, 0, 1601, 1593, 1, 0, 0, 0, 1601, 1594, 1,
		0, 0, 0, 1601, 1595, 1, 0, 0, 0, 1601, 1596, 1, 0, 0, 0, 1602, 239, 1,
		0, 0, 0, 1603, 1608, 5, 190, 0, 0, 1604, 1605, 5, 189, 0, 0, 1605, 1607,
		5, 190, 0, 0, 1606, 1604, 1, 0, 0, 0, 1607, 1610, 1, 0, 0, 0, 1608, 1606,
		1, 0, 0, 0, 1608, 1609, 1, 0, 0, 0, 1609, 1612, 1, 0, 0, 0, 1610, 1608,
		1, 0, 0, 0, 1611, 1613, 5, 189, 0, 0, 1612, 1611, 1, 0, 0, 0, 1612, 1613,
		1, 0, 0, 0, 1613, 1626, 1, 0, 0, 0, 1614, 1619, 5, 189, 0, 0, 1615, 1616,
		5, 190, 0, 0, 1616, 1618, 5, 189, 0, 0, 1617, 1615, 1, 0, 0, 0, 1618, 1621,
		1, 0, 0, 0, 1619, 1617, 1, 0, 0, 0, 1619, 1620, 1, 0, 0, 0, 1620, 1623,
		1, 0, 0, 0, 1621, 1619, 1, 0, 0, 0, 1622, 1624, 5, 190, 0, 0, 1623, 1622,
		1, 0, 0, 0, 1623, 1624, 1, 0, 0, 0, 1624, 1626, 1, 0, 0, 0, 1625, 1603,
		1, 0, 0, 0, 1625, 1614, 1, 0, 0, 0, 1626, 241, 1, 0, 0, 0, 1627, 1636,
		5, 150, 0, 0, 1628, 1633, 3, 232, 116, 0, 1629, 1630, 7, 10, 0, 0, 1630,
		1632, 3, 232, 116, 0, 1631, 1629, 1, 0, 0, 0, 1632, 1635, 1, 0, 0, 0, 1633,
		1631, 1, 0, 0, 0, 1633, 1634, 1, 0, 0, 0, 1634, 1637, 1, 0, 0, 0, 1635,
		1633, 1, 0, 0, 0, 1636, 1628, 1, 0, 0, 0, 1636, 1637, 1, 0, 0, 0, 1637,
		1638, 1, 0, 0, 0, 1638, 1639, 5, 152, 0, 0, 1639, 243, 1, 0, 0, 0, 1640,
		1642, 5, 57, 0, 0, 1641, 1640, 1, 0, 0, 0, 1641, 1642, 1, 0, 0, 0, 1642,
		1647, 1, 0, 0, 0, 1643, 1646, 3, 344, 172, 0, 1644, 1646, 3, 116, 58, 0,
		1645, 1643, 1, 0, 0, 0, 1645, 1644, 1, 0, 0, 0, 1646, 1648, 1, 0, 0, 0,
		1647, 1645, 1, 0, 0, 0, 1647, 1648, 1, 0, 0, 0, 1648, 1652, 1, 0, 0, 0,
		1649, 1651, 3, 246, 123, 0, 1650, 1649, 1, 0, 0, 0, 1651, 1654, 1, 0, 0,
		0, 1652, 1650, 1, 0, 0, 0, 1652, 1653, 1, 0, 0, 0, 1653, 245, 1, 0, 0,
		0, 1654, 1652, 1, 0, 0, 0, 1655, 1692, 5, 154, 0, 0, 1656, 1657, 7, 11,
		0, 0, 1657, 1692, 3, 330, 165, 0, 1658, 1659, 5, 144, 0, 0, 1659, 1664,
		3, 118, 59, 0, 1660, 1661, 5, 139, 0, 0, 1661, 1663, 3, 118, 59, 0, 1662,
		1660, 1, 0, 0, 0, 1663, 1666, 1, 0, 0, 0, 1664, 1662, 1, 0, 0, 0, 1664,
		1665, 1, 0, 0, 0, 1665, 1667, 1, 0, 0, 0, 1666, 1664, 1, 0, 0, 0, 1667,
		1668, 5, 147, 0, 0, 1668, 1692, 1, 0, 0, 0, 1669, 1670, 5, 150, 0, 0, 1670,
		1671, 3, 248, 124, 0, 1671, 1672, 5, 152, 0, 0, 1672, 1692, 1, 0, 0, 0,
		1673, 1688, 5, 148, 0, 0, 1674, 1676, 3, 232, 116, 0, 1675, 1677, 3, 250,
		125, 0, 1676, 1675, 1, 0, 0, 0, 1676, 1677, 1, 0, 0, 0, 1677, 1685, 1,
		0, 0, 0, 1678, 1679, 5, 139, 0, 0, 1679, 1681, 3, 232, 116, 0, 1680, 1682,
		3, 250, 125, 0, 1681, 1680, 1, 0, 0, 0, 1681, 1682, 1, 0, 0, 0, 1682, 1684,
		1, 0, 0, 0, 1683, 1678, 1, 0, 0, 0, 1684, 1687, 1, 0, 0, 0, 1685, 1683,
		1, 0, 0, 0, 1685, 1686, 1, 0, 0, 0, 1686, 1689, 1, 0, 0, 0, 1687, 1685,
		1, 0, 0, 0, 1688, 1674, 1, 0, 0, 0, 1688, 1689, 1, 0, 0, 0, 1689, 1690,
		1, 0, 0, 0, 1690, 1692, 5, 149, 0, 0, 1691, 1655, 1, 0, 0, 0, 1691, 1656,
		1, 0, 0, 0, 1691, 1658, 1, 0, 0, 0, 1691, 1669, 1, 0, 0, 0, 1691, 1673,
		1, 0, 0, 0, 1692, 247, 1, 0, 0, 0, 1693, 1698, 3, 232, 116, 0, 1694, 1695,
		5, 139, 0, 0, 1695, 1697, 3, 232, 116, 0, 1696, 1694, 1, 0, 0, 0, 1697,
		1700, 1, 0, 0, 0, 1698, 1696, 1, 0, 0, 0, 1698, 1699, 1, 0, 0, 0, 1699,
		249, 1, 0, 0, 0, 1700, 1698, 1, 0, 0, 0, 1701, 1702, 5, 141, 0, 0, 1702,
		1705, 3, 232, 116, 0, 1703, 1704, 5, 141, 0, 0, 1704, 1706, 3, 232, 116,
		0, 1705, 1703, 1, 0, 0, 0, 1705, 1706, 1, 0, 0, 0, 1706, 251, 1, 0, 0,
		0, 1707, 1708, 7, 12, 0, 0, 1708, 253, 1, 0, 0, 0, 1709, 1710, 7, 13, 0,
		0, 1710, 255, 1, 0, 0, 0, 1711, 1727, 3, 258, 129, 0, 1712, 1727, 3, 260,
		130, 0, 1713, 1727, 3, 266, 133, 0, 1714, 1727, 3, 268, 134, 0, 1715, 1727,
		3, 270, 135, 0, 1716, 1727, 3, 272, 136, 0, 1717, 1727, 3, 288, 144, 0,
		1718, 1727, 3, 298, 149, 0, 1719, 1727, 3, 300, 150, 0, 1720, 1727, 3,
		276, 138, 0, 1721, 1722, 3, 338, 169, 0, 1722, 1723, 5, 141, 0, 0, 1723,
		1724, 3, 256, 128, 0, 1724, 1727, 1, 0, 0, 0, 1725, 1727, 3, 280, 140,
		0, 1726, 1711, 1, 0, 0, 0, 1726, 1712, 1, 0, 0, 0, 1726, 1713, 1, 0, 0,
		0, 1726, 1714, 1, 0, 0, 0, 1726, 1715, 1, 0, 0, 0, 1726, 1716, 1, 0, 0,
		0, 1726, 1717, 1, 0, 0, 0, 1726, 1718, 1, 0, 0, 0, 1726, 1719, 1, 0, 0,
		0, 1726, 1720, 1, 0, 0, 0, 1726, 1721, 1, 0, 0, 0, 1726, 1725, 1, 0, 0,
		0, 1727, 257, 1, 0, 0, 0, 1728, 1729, 5, 52, 0, 0, 1729, 1730, 3, 232,
		116, 0, 1730, 1731, 5, 114, 0, 0, 1731, 1734, 3, 256, 128, 0, 1732, 1733,
		5, 34, 0, 0, 1733, 1735, 3, 256, 128, 0, 1734, 1732, 1, 0, 0, 0, 1734,
		1735, 1, 0, 0, 0, 1735, 259, 1, 0, 0, 0, 1736, 1737, 5, 16, 0, 0, 1737,
		1738, 3, 232, 116, 0, 1738, 1742, 5, 73, 0, 0, 1739, 1741, 3, 262, 131,
		0, 1740, 1739, 1, 0, 0, 0, 1741, 1744, 1, 0, 0, 0, 1742, 1740, 1, 0, 0,
		0, 1742, 1743, 1, 0, 0, 0, 1743, 1750, 1, 0, 0, 0, 1744, 1742, 1, 0, 0,
		0, 1745, 1746, 5, 34, 0, 0, 1746, 1748, 3, 278, 139, 0, 1747, 1749, 5,
		140, 0, 0, 1748, 1747, 1, 0, 0, 0, 1748, 1749, 1, 0, 0, 0, 1749, 1751,
		1, 0, 0, 0, 1750, 1745, 1, 0, 0, 0, 1750, 1751, 1, 0, 0, 0, 1751, 1752,
		1, 0, 0, 0, 1752, 1753, 5, 35, 0, 0, 1753, 261, 1, 0, 0, 0, 1754, 1759,
		3, 264, 132, 0, 1755, 1756, 5, 139, 0, 0, 1756, 1758, 3, 264, 132, 0, 1757,
		1755, 1, 0, 0, 0, 1758, 1761, 1, 0, 0, 0, 1759, 1757, 1, 0, 0, 0, 1759,
		1760, 1, 0, 0, 0, 1760, 1762, 1, 0, 0, 0, 1761, 1759, 1, 0, 0, 0, 1762,
		1763, 5, 141, 0, 0, 1763, 1765, 3, 256, 128, 0, 1764, 1766, 5, 140, 0,
		0, 1765, 1764, 1, 0, 0, 0, 1765, 1766, 1, 0, 0, 0, 1766, 263, 1, 0, 0,
		0, 1767, 1770, 3, 232, 116, 0, 1768, 1769, 5, 157, 0, 0, 1769, 1771, 3,
		232, 116, 0, 1770, 1768, 1, 0, 0, 0, 1770, 1771, 1, 0, 0, 0, 1771, 265,
		1, 0, 0, 0, 1772, 1774, 5, 100, 0, 0, 1773, 1775, 3, 278, 139, 0, 1774,
		1773, 1, 0, 0, 0, 1774, 1775, 1, 0, 0, 0, 1775, 1776, 1, 0, 0, 0, 1776,
		1777, 5, 121, 0, 0, 1777, 1778, 3, 232, 116, 0, 1778, 267, 1, 0, 0, 0,
		1779, 1780, 5, 127, 0, 0, 1780, 1781, 3, 232, 116, 0, 1781, 1782, 5, 29,
		0, 0, 1782, 1783, 3, 256, 128, 0, 1783, 269, 1, 0, 0, 0, 1784, 1785, 5,
		47, 0, 0, 1785, 1786, 3, 244, 122, 0, 1786, 1787, 5, 138, 0, 0, 1787, 1788,
		3, 232, 116, 0, 1788, 1789, 5, 116, 0, 0, 1789, 1790, 3, 232, 116, 0, 1790,
		1791, 5, 29, 0, 0, 1791, 1792, 3, 256, 128, 0, 1792, 1810, 1, 0, 0, 0,
		1793, 1794, 5, 47, 0, 0, 1794, 1795, 3, 244, 122, 0, 1795, 1796, 5, 138,
		0, 0, 1796, 1797, 3, 232, 116, 0, 1797, 1798, 5, 30, 0, 0, 1798, 1799,
		3, 232, 116, 0, 1799, 1800, 5, 29, 0, 0, 1800, 1801, 3, 256, 128, 0, 1801,
		1810, 1, 0, 0, 0, 1802, 1803, 5, 47, 0, 0, 1803, 1804, 3, 244, 122, 0,
		1804, 1805, 5, 55, 0, 0, 1805, 1806, 3, 232, 116, 0, 1806, 1807, 5, 29,
		0, 0, 1807, 1808, 3, 256, 128, 0, 1808, 1810, 1, 0, 0, 0, 1809, 1784, 1,
		0, 0, 0, 1809, 1793, 1, 0, 0, 0, 1809, 1802, 1, 0, 0, 0, 1810, 271, 1,
		0, 0, 0, 1811, 1812, 5, 128, 0, 0, 1812, 1813, 3, 274, 137, 0, 1813, 1814,
		5, 29, 0, 0, 1814, 1815, 3, 256, 128, 0, 1815, 273, 1, 0, 0, 0, 1816, 1817,
		3, 244, 122, 0, 1817, 1818, 5, 8, 0, 0, 1818, 1819, 3, 244, 122, 0, 1819,
		1829, 1, 0, 0, 0, 1820, 1825, 3, 244, 122, 0, 1821, 1822, 5, 139, 0, 0,
		1822, 1824, 3, 244, 122, 0, 1823, 1821, 1, 0, 0, 0, 1824, 1827, 1, 0, 0,
		0, 1825, 1823, 1, 0, 0, 0, 1825, 1826, 1, 0, 0, 0, 1826, 1829, 1, 0, 0,
		0, 1827, 1825, 1, 0, 0, 0, 1828, 1816, 1, 0, 0, 0, 1828, 1820, 1, 0, 0,
		0, 1829, 275, 1, 0, 0, 0, 1830, 1832, 5, 14, 0, 0, 1831, 1833, 3, 278,
		139, 0, 1832, 1831, 1, 0, 0, 0, 1832, 1833, 1, 0, 0, 0, 1833, 1834, 1,
		0, 0, 0, 1834, 1835, 5, 35, 0, 0, 1835, 277, 1, 0, 0, 0, 1836, 1838, 3,
		256, 128, 0, 1837, 1836, 1, 0, 0, 0, 1837, 1838, 1, 0, 0, 0, 1838, 1845,
		1, 0, 0, 0, 1839, 1841, 5, 140, 0, 0, 1840, 1842, 3, 256, 128, 0, 1841,
		1840, 1, 0, 0, 0, 1841, 1842, 1, 0, 0, 0, 1842, 1844, 1, 0, 0, 0, 1843,
		1839, 1, 0, 0, 0, 1844, 1847, 1, 0, 0, 0, 1845, 1843, 1, 0, 0, 0, 1845,
		1846, 1, 0, 0, 0, 1846, 279, 1, 0, 0, 0, 1847, 1845, 1, 0, 0, 0, 1848,
		1849, 3, 244, 122, 0, 1849, 1850, 5, 138, 0, 0, 1850, 1851, 3, 232, 116,
		0, 1851, 1855, 1, 0, 0, 0, 1852, 1855, 3, 244, 122, 0, 1853, 1855, 3, 282,
		141, 0, 1854, 1848, 1, 0, 0, 0, 1854, 1852, 1, 0, 0, 0, 1854, 1853, 1,
		0, 0, 0, 1855, 281, 1, 0, 0, 0, 1856, 1857, 5, 50, 0, 0, 1857, 1867, 3,
		338, 169, 0, 1858, 1863, 5, 37, 0, 0, 1859, 1860, 5, 148, 0, 0, 1860, 1861,
		3, 232, 116, 0, 1861, 1862, 5, 149, 0, 0, 1862, 1864, 1, 0, 0, 0, 1863,
		1859, 1, 0, 0, 0, 1863, 1864, 1, 0, 0, 0, 1864, 1867, 1, 0, 0, 0, 1865,
		1867, 7, 14, 0, 0, 1866, 1856, 1, 0, 0, 0, 1866, 1858, 1, 0, 0, 0, 1866,
		1865, 1, 0, 0, 0, 1867, 283, 1, 0, 0, 0, 1868, 1869, 5, 148, 0, 0, 1869,
		1874, 3, 286, 143, 0, 1870, 1871, 5, 140, 0, 0, 1871, 1873, 3, 286, 143,
		0, 1872, 1870, 1, 0, 0, 0, 1873, 1876, 1, 0, 0, 0, 1874, 1872, 1, 0, 0,
		0, 1874, 1875, 1, 0, 0, 0, 1875, 1877, 1, 0, 0, 0, 1876, 1874, 1, 0, 0,
		0, 1877, 1878, 5, 149, 0, 0, 1878, 1892, 1, 0, 0, 0, 1879, 1880, 5, 148,
		0, 0, 1880, 1885, 3, 284, 142, 0, 1881, 1882, 5, 139, 0, 0, 1882, 1884,
		3, 284, 142, 0, 1883, 1881, 1, 0, 0, 0, 1884, 1887, 1, 0, 0, 0, 1885, 1883,
		1, 0, 0, 0, 1885, 1886, 1, 0, 0, 0, 1886, 1888, 1, 0, 0, 0, 1887, 1885,
		1, 0, 0, 0, 1888, 1889, 5, 149, 0, 0, 1889, 1892, 1, 0, 0, 0, 1890, 1892,
		3, 232, 116, 0, 1891, 1868, 1, 0, 0, 0, 1891, 1879, 1, 0, 0, 0, 1891, 1890,
		1, 0, 0, 0, 1892, 285, 1, 0, 0, 0, 1893, 1894, 3, 330, 165, 0, 1894, 1895,
		5, 141, 0, 0, 1895, 1896, 3, 284, 142, 0, 1896, 287, 1, 0, 0, 0, 1897,
		1899, 5, 117, 0, 0, 1898, 1900, 3, 278, 139, 0, 1899, 1898, 1, 0, 0, 0,
		1899, 1900, 1, 0, 0, 0, 1900, 1901, 1, 0, 0, 0, 1901, 1902, 5, 36, 0, 0,
		1902, 1903, 3, 290, 145, 0, 1903, 1904, 5, 35, 0, 0, 1904, 1915, 1, 0,
		0, 0, 1905, 1907, 5, 117, 0, 0, 1906, 1908, 3, 278, 139, 0, 1907, 1906,
		1, 0, 0, 0, 1907, 1908, 1, 0, 0, 0, 1908, 1909, 1, 0, 0, 0, 1909, 1911,
		5, 46, 0, 0, 1910, 1912, 3, 278, 139, 0, 1911, 1910, 1, 0, 0, 0, 1911,
		1912, 1, 0, 0, 0, 1912, 1913, 1, 0, 0, 0, 1913, 1915, 5, 35, 0, 0, 1914,
		1897, 1, 0, 0, 0, 1914, 1905, 1, 0, 0, 0, 1915, 289, 1, 0, 0, 0, 1916,
		1918, 3, 292, 146, 0, 1917, 1916, 1, 0, 0, 0, 1918, 1921, 1, 0, 0, 0, 1919,
		1917, 1, 0, 0, 0, 1919, 1920, 1, 0, 0, 0, 1920, 1924, 1, 0, 0, 0, 1921,
		1919, 1, 0, 0, 0, 1922, 1923, 5, 34, 0, 0, 1923, 1925, 3, 278, 139, 0,
		1924, 1922, 1, 0, 0, 0, 1924, 1925, 1, 0, 0, 0, 1925, 1928, 1, 0, 0, 0,
		1926, 1928, 3, 278, 139, 0, 1927, 1919, 1, 0, 0, 0, 1927, 1926, 1, 0, 0,
		0, 1928, 291, 1, 0, 0, 0, 1929, 1931, 5, 74, 0, 0, 1930, 1932, 3, 294,
		147, 0, 1931, 1930, 1, 0, 0, 0, 1931, 1932, 1, 0, 0, 0, 1932, 1933, 1,
		0, 0, 0, 1933, 1934, 3, 116, 58, 0, 1934, 1935, 5, 29, 0, 0, 1935, 1936,
		3, 296, 148, 0, 1936, 293, 1, 0, 0, 0, 1937, 1938, 3, 330, 165, 0, 1938,
		1939, 5, 141, 0, 0, 1939, 295, 1, 0, 0, 0, 1940, 1942, 3, 256, 128, 0,
		1941, 1943, 5, 140, 0, 0, 1942, 1941, 1, 0, 0, 0, 1942, 1943, 1, 0, 0,
		0, 1943, 1946, 1, 0, 0, 0, 1944, 1946, 5, 140, 0, 0, 1945, 1940, 1, 0,
		0, 0, 1945, 1944, 1, 0, 0, 0, 1946, 297, 1, 0, 0, 0, 1947, 1949, 5, 92,
		0, 0, 1948, 1950, 3, 244, 122, 0, 1949, 1948, 1, 0, 0, 0, 1949, 1950, 1,
		0, 0, 0, 1950, 1953, 1, 0, 0, 0, 1951, 1952, 5, 12, 0, 0, 1952, 1954, 3,
		244, 122, 0, 1953, 1951, 1, 0, 0, 0, 1953, 1954, 1, 0, 0, 0, 1954, 299,
		1, 0, 0, 0, 1955, 1959, 5, 9, 0, 0, 1956, 1958, 8, 15, 0, 0, 1957, 1956,
		1, 0, 0, 0, 1958, 1961, 1, 0, 0, 0, 1959, 1957, 1, 0, 0, 0, 1959, 1960,
		1, 0, 0, 0, 1960, 1962, 1, 0, 0, 0, 1961, 1959, 1, 0, 0, 0, 1962, 1963,
		5, 35, 0, 0, 1963, 301, 1, 0, 0, 0, 1964, 1976, 3, 306, 153, 0, 1965, 1976,
		3, 308, 154, 0, 1966, 1976, 3, 310, 155, 0, 1967, 1976, 3, 312, 156, 0,
		1968, 1976, 3, 314, 157, 0, 1969, 1976, 3, 316, 158, 0, 1970, 1971, 3,
		322, 161, 0, 1971, 1972, 5, 140, 0, 0, 1972, 1976, 1, 0, 0, 0, 1973, 1976,
		3, 320, 160, 0, 1974, 1976, 3, 328, 164, 0, 1975, 1964, 1, 0, 0, 0, 1975,
		1965, 1, 0, 0, 0, 1975, 1966, 1, 0, 0, 0, 1975, 1967, 1, 0, 0, 0, 1975,
		1968, 1, 0, 0, 0, 1975, 1969, 1, 0, 0, 0, 1975, 1970, 1, 0, 0, 0, 1975,
		1973, 1, 0, 0, 0, 1975, 1974, 1, 0, 0, 0, 1976, 303, 1, 0, 0, 0, 1977,
		1991, 3, 308, 154, 0, 1978, 1991, 3, 314, 157, 0, 1979, 1991, 3, 316, 158,
		0, 1980, 1991, 3, 320, 160, 0, 1981, 1982, 3, 322, 161, 0, 1982, 1983,
		5, 140, 0, 0, 1983, 1991, 1, 0, 0, 0, 1984, 1986, 3, 318, 159, 0, 1985,
		1984, 1, 0, 0, 0, 1985, 1986, 1, 0, 0, 0, 1986, 1987, 1, 0, 0, 0, 1987,
		1991, 3, 324, 162, 0, 1988, 1989, 5, 120, 0, 0, 1989, 1991, 5, 140, 0,
		0, 1990, 1977, 1, 0, 0, 0, 1990, 1978, 1, 0, 0, 0, 1990, 1979, 1, 0, 0,
		0, 1990, 1980, 1, 0, 0, 0, 1990, 1981, 1, 0, 0, 0, 1990, 1985, 1, 0, 0,
		0, 1990, 1988, 1, 0, 0, 0, 1991, 305, 1, 0, 0, 0, 1992, 1993, 5, 98, 0,
		0, 1993, 1994, 5, 140, 0, 0, 1994, 307, 1, 0, 0, 0, 1995, 1997, 5, 78,
		0, 0, 1996, 1998, 5, 140, 0, 0, 1997, 1996, 1, 0, 0, 0, 1997, 1998, 1,
		0, 0, 0, 1998, 309, 1, 0, 0, 0, 1999, 2000, 5, 65, 0, 0, 2000, 2001, 3,
		232, 116, 0, 2001, 2002, 5, 140, 0, 0, 2002, 2012, 1, 0, 0, 0, 2003, 2004,
		5, 109, 0, 0, 2004, 2012, 5, 140, 0, 0, 2005, 2006, 5, 33, 0, 0, 2006,
		2012, 5, 140, 0, 0, 2007, 2008, 5, 79, 0, 0, 2008, 2012, 5, 140, 0, 0,
		2009, 2010, 5, 126, 0, 0, 2010, 2012, 5, 140, 0, 0, 2011, 1999, 1, 0, 0,
		0, 2011, 2003, 1, 0, 0, 0, 2011, 2005, 1, 0, 0, 0, 2011, 2007, 1, 0, 0,
		0, 2011, 2009, 1, 0, 0, 0, 2012, 311, 1, 0, 0, 0, 2013, 2014, 5, 3, 0,
		0, 2014, 2018, 5, 140, 0, 0, 2015, 2016, 5, 44, 0, 0, 2016, 2018, 5, 140,
		0, 0, 2017, 2013, 1, 0, 0, 0, 2017, 2015, 1, 0, 0, 0, 2018, 313, 1, 0,
		0, 0, 2019, 2020, 5, 59, 0, 0, 2020, 2024, 5, 140, 0, 0, 2021, 2022, 5,
		10, 0, 0, 2022, 2024, 5, 140, 0, 0, 2023, 2019, 1, 0, 0, 0, 2023, 2021,
		1, 0, 0, 0, 2024, 315, 1, 0, 0, 0, 2025, 2026, 5, 17, 0, 0, 2026, 2038,
		5, 140, 0, 0, 2027, 2028, 5, 82, 0, 0, 2028, 2038, 5, 140, 0, 0, 2029,
		2030, 5, 97, 0, 0, 2030, 2038, 5, 140, 0, 0, 2031, 2032, 5, 104, 0, 0,
		2032, 2038, 5, 140, 0, 0, 2033, 2034, 5, 110, 0, 0, 2034, 2038, 5, 140,
		0, 0, 2035, 2036, 5, 39, 0, 0, 2036, 2038, 5, 140, 0, 0, 2037, 2025, 1,
		0, 0, 0, 2037, 2027, 1, 0, 0, 0, 2037, 2029, 1, 0, 0, 0, 2037, 2031, 1,
		0, 0, 0, 2037, 2033, 1, 0, 0, 0, 2037, 2035, 1, 0, 0, 0, 2038, 317, 1,
		0, 0, 0, 2039, 2040, 7, 16, 0, 0, 2040, 319, 1, 0, 0, 0, 2041, 2042, 5,
		42, 0, 0, 2042, 2048, 5, 140, 0, 0, 2043, 2044, 5, 64, 0, 0, 2044, 2048,
		5, 140, 0, 0, 2045, 2046, 5, 68, 0, 0, 2046, 2048, 5, 140, 0, 0, 2047,
		2041, 1, 0, 0, 0, 2047, 2043, 1, 0, 0, 0, 2047, 2045, 1, 0, 0, 0, 2048,
		321, 1, 0, 0, 0, 2049, 2051, 5, 24, 0, 0, 2050, 2052, 3, 240, 120, 0, 2051,
		2050, 1, 0, 0, 0, 2051, 2052, 1, 0, 0, 0, 2052, 2055, 1, 0, 0, 0, 2053,
		2055, 7, 17, 0, 0, 2054, 2049, 1, 0, 0, 0, 2054, 2053, 1, 0, 0, 0, 2055,
		323, 1, 0, 0, 0, 2056, 2057, 5, 124, 0, 0, 2057, 2071, 5, 140, 0, 0, 2058,
		2059, 5, 41, 0, 0, 2059, 2071, 5, 140, 0, 0, 2060, 2061, 5, 41, 0, 0, 2061,
		2065, 3, 284, 142, 0, 2062, 2064, 3, 326, 163, 0, 2063, 2062, 1, 0, 0,
		0, 2064, 2067, 1, 0, 0, 0, 2065, 2063, 1, 0, 0, 0, 2065, 2066, 1, 0, 0,
		0, 2066, 2068, 1, 0, 0, 0, 2067, 2065, 1, 0, 0, 0, 2068, 2069, 5, 140,
		0, 0, 2069, 2071, 1, 0, 0, 0, 2070, 2056, 1, 0, 0, 0, 2070, 2058, 1, 0,
		0, 0, 2070, 2060, 1, 0, 0, 0, 2071, 325, 1, 0, 0, 0, 2072, 2073, 5, 67,
		0, 0, 2073, 2077, 3, 284, 142, 0, 2074, 2075, 5, 56, 0, 0, 2075, 2077,
		3, 284, 142, 0, 2076, 2072, 1, 0, 0, 0, 2076, 2074, 1, 0, 0, 0, 2077, 327,
		1, 0, 0, 0, 2078, 2079, 5, 26, 0, 0, 2079, 2080, 3, 232, 116, 0, 2080,
		2081, 5, 140, 0, 0, 2081, 329, 1, 0, 0, 0, 2082, 2087, 5, 183, 0, 0, 2083,
		2084, 5, 160, 0, 0, 2084, 2087, 5, 183, 0, 0, 2085, 2087, 3, 332, 166,
		0, 2086, 2082, 1, 0, 0, 0, 2086, 2083, 1, 0, 0, 0, 2086, 2085, 1, 0, 0,
		0, 2087, 331, 1, 0, 0, 0, 2088, 2092, 7, 18, 0, 0, 2089, 2092, 7, 19, 0,
		0, 2090, 2092, 7, 20, 0, 0, 2091, 2088, 1, 0, 0, 0, 2091, 2089, 1, 0, 0,
		0, 2091, 2090, 1, 0, 0, 0, 2092, 333, 1, 0, 0, 0, 2093, 2098, 3, 330, 165,
		0, 2094, 2095, 5, 139, 0, 0, 2095, 2097, 3, 330, 165, 0, 2096, 2094, 1,
		0, 0, 0, 2097, 2100, 1, 0, 0, 0, 2098, 2096, 1, 0, 0, 0, 2098, 2099, 1,
		0, 0, 0, 2099, 335, 1, 0, 0, 0, 2100, 2098, 1, 0, 0, 0, 2101, 2106, 3,
		330, 165, 0, 2102, 2103, 5, 139, 0, 0, 2103, 2105, 3, 330, 165, 0, 2104,
		2102, 1, 0, 0, 0, 2105, 2108, 1, 0, 0, 0, 2106, 2104, 1, 0, 0, 0, 2106,
		2107, 1, 0, 0, 0, 2107, 337, 1, 0, 0, 0, 2108, 2106, 1, 0, 0, 0, 2109,
		2112, 7, 21, 0, 0, 2110, 2112, 3, 332, 166, 0, 2111, 2109, 1, 0, 0, 0,
		2111, 2110, 1, 0, 0, 0, 2112, 339, 1, 0, 0, 0, 2113, 2114, 7, 22, 0, 0,
		2114, 341, 1, 0, 0, 0, 2115, 2116, 5, 185, 0, 0, 2116, 343, 1, 0, 0, 0,
		2117, 2118, 3, 346, 173, 0, 2118, 2119, 5, 156, 0, 0, 2119, 2121, 1, 0,
		0, 0, 2120, 2117, 1, 0, 0, 0, 2120, 2121, 1, 0, 0, 0, 2121, 2122, 1, 0,
		0, 0, 2122, 2123, 3, 348, 174, 0, 2123, 345, 1, 0, 0, 0, 2124, 2129, 3,
		330, 165, 0, 2125, 2126, 5, 156, 0, 0, 2126, 2128, 3, 330, 165, 0, 2127,
		2125, 1, 0, 0, 0, 2128, 2131, 1, 0, 0, 0, 2129, 2127, 1, 0, 0, 0, 2129,
		2130, 1, 0, 0, 0, 2130, 347, 1, 0, 0, 0, 2131, 2129, 1, 0, 0, 0, 2132,
		2133, 3, 330, 165, 0, 2133, 2134, 5, 156, 0, 0, 2134, 2136, 1, 0, 0, 0,
		2135, 2132, 1, 0, 0, 0, 2136, 2139, 1, 0, 0, 0, 2137, 2135, 1, 0, 0, 0,
		2137, 2138, 1, 0, 0, 0, 2138, 2140, 1, 0, 0, 0, 2139, 2137, 1, 0, 0, 0,
		2140, 2141, 3, 330, 165, 0, 2141, 349, 1, 0, 0, 0, 288, 354, 357, 360,
		368, 378, 381, 387, 397, 405, 425, 432, 437, 442, 447, 455, 460, 482, 490,
		497, 505, 509, 513, 523, 532, 540, 549, 555, 560, 567, 577, 581, 589, 599,
		605, 611, 616, 627, 638, 645, 648, 652, 656, 659, 667, 671, 674, 677, 685,
		690, 694, 698, 702, 712, 716, 725, 730, 737, 740, 744, 746, 755, 763, 766,
		774, 778, 783, 785, 792, 797, 803, 809, 813, 822, 826, 834, 845, 857, 860,
		864, 872, 884, 892, 895, 900, 906, 908, 918, 930, 933, 938, 945, 954, 957,
		961, 964, 969, 976, 978, 988, 991, 995, 1000, 1008, 1012, 1018, 1024, 1033,
		1046, 1049, 1057, 1061, 1069, 1073, 1079, 1085, 1089, 1091, 1099, 1107,
		1119, 1127, 1130, 1133, 1138, 1141, 1147, 1151, 1154, 1159, 1162, 1166,
		1173, 1177, 1180, 1185, 1188, 1192, 1197, 1200, 1209, 1213, 1216, 1221,
		1225, 1228, 1233, 1240, 1250, 1261, 1275, 1283, 1291, 1293, 1300, 1303,
		1307, 1311, 1316, 1320, 1327, 1333, 1339, 1342, 1349, 1353, 1356, 1359,
		1364, 1367, 1370, 1375, 1379, 1382, 1385, 1391, 1395, 1398, 1400, 1406,
		1411, 1413, 1418, 1425, 1429, 1432, 1437, 1440, 1445, 1450, 1454, 1463,
		1467, 1472, 1476, 1488, 1496, 1498, 1504, 1510, 1517, 1524, 1527, 1536,
		1540, 1542, 1546, 1551, 1557, 1565, 1587, 1591, 1601, 1608, 1612, 1619,
		1623, 1625, 1633, 1636, 1641, 1645, 1647, 1652, 1664, 1676, 1681, 1685,
		1688, 1691, 1698, 1705, 1726, 1734, 1742, 1748, 1750, 1759, 1765, 1770,
		1774, 1809, 1825, 1828, 1832, 1837, 1841, 1845, 1854, 1863, 1866, 1874,
		1885, 1891, 1899, 1907, 1911, 1914, 1919, 1924, 1927, 1931, 1942, 1945,
		1949, 1953, 1959, 1975, 1985, 1990, 1997, 2011, 2017, 2023, 2037, 2047,
		2051, 2054, 2065, 2070, 2076, 2086, 2091, 2098, 2106, 2111, 2120, 2129,
		2137,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// DelphiParserInit initializes any static state used to implement DelphiParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewDelphiParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func DelphiParserInit() {
	staticData := &DelphiParserStaticData
	staticData.once.Do(delphiParserInit)
}

// NewDelphiParser produces a new parser instance for the optional input antlr.TokenStream.
func NewDelphiParser(input antlr.TokenStream) *DelphiParser {
	DelphiParserInit()
	this := new(DelphiParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &DelphiParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Delphi.g4"

	return this
}

// DelphiParser tokens.
const (
	DelphiParserEOF                   = antlr.TokenEOF
	DelphiParserT__0                  = 1
	DelphiParserABSOLUTE              = 2
	DelphiParserABSTRACT              = 3
	DelphiParserADD                   = 4
	DelphiParserAND                   = 5
	DelphiParserANSISTRING            = 6
	DelphiParserARRAY                 = 7
	DelphiParserAS                    = 8
	DelphiParserASM                   = 9
	DelphiParserASSEMBLER             = 10
	DelphiParserASSEMBLY              = 11
	DelphiParserAT                    = 12
	DelphiParserAUTOMATED             = 13
	DelphiParserBEGIN                 = 14
	DelphiParserBREAK                 = 15
	DelphiParserCASE                  = 16
	DelphiParserCDECL                 = 17
	DelphiParserCLASS                 = 18
	DelphiParserCONST                 = 19
	DelphiParserCONSTRUCTOR           = 20
	DelphiParserCONTAINS              = 21
	DelphiParserCONTINUE              = 22
	DelphiParserDEFAULT               = 23
	DelphiParserDEPRECATED            = 24
	DelphiParserDESTRUCTOR            = 25
	DelphiParserDISPID                = 26
	DelphiParserDISPINTERFACE         = 27
	DelphiParserDIV                   = 28
	DelphiParserDO                    = 29
	DelphiParserDOWNTO                = 30
	DelphiParserDQ                    = 31
	DelphiParserDW                    = 32
	DelphiParserDYNAMIC               = 33
	DelphiParserELSE                  = 34
	DelphiParserEND                   = 35
	DelphiParserEXCEPT                = 36
	DelphiParserEXIT                  = 37
	DelphiParserEXPERIMENTAL          = 38
	DelphiParserEXPORT                = 39
	DelphiParserEXPORTS               = 40
	DelphiParserEXTERNAL              = 41
	DelphiParserFAR                   = 42
	DelphiParserFILE                  = 43
	DelphiParserFINAL                 = 44
	DelphiParserFINALIZATION          = 45
	DelphiParserFINALLY               = 46
	DelphiParserFOR                   = 47
	DelphiParserFORWARD               = 48
	DelphiParserFUNCTION              = 49
	DelphiParserGOTO                  = 50
	DelphiParserHELPER                = 51
	DelphiParserIF                    = 52
	DelphiParserIMPLEMENTATION        = 53
	DelphiParserIMPLEMENTS            = 54
	DelphiParserIN                    = 55
	DelphiParserINDEX                 = 56
	DelphiParserINHERITED             = 57
	DelphiParserINITIALIZATION        = 58
	DelphiParserINLINE                = 59
	DelphiParserINTERFACE             = 60
	DelphiParserIS                    = 61
	DelphiParserLABEL                 = 62
	DelphiParserLIBRARY               = 63
	DelphiParserLOCAL                 = 64
	DelphiParserMESSAGE               = 65
	DelphiParserMOD                   = 66
	DelphiParserNAME                  = 67
	DelphiParserNEAR                  = 68
	DelphiParserNIL                   = 69
	DelphiParserNODEFAULT             = 70
	DelphiParserNOT                   = 71
	DelphiParserOBJECT                = 72
	DelphiParserOF                    = 73
	DelphiParserON                    = 74
	DelphiParserOPERATOR              = 75
	DelphiParserOR                    = 76
	DelphiParserOUT                   = 77
	DelphiParserOVERLOAD              = 78
	DelphiParserOVERRIDE              = 79
	DelphiParserPACKAGE               = 80
	DelphiParserPACKED                = 81
	DelphiParserPASCAL                = 82
	DelphiParserPLATFORM              = 83
	DelphiParserPOINTER               = 84
	DelphiParserPRIVATE               = 85
	DelphiParserPROCEDURE             = 86
	DelphiParserPROGRAM               = 87
	DelphiParserPROPERTY              = 88
	DelphiParserPROTECTED             = 89
	DelphiParserPUBLIC                = 90
	DelphiParserPUBLISHED             = 91
	DelphiParserRAISE                 = 92
	DelphiParserREAD                  = 93
	DelphiParserREADONLY              = 94
	DelphiParserRECORD                = 95
	DelphiParserREFERENCE             = 96
	DelphiParserREGISTER              = 97
	DelphiParserREINTRODUCE           = 98
	DelphiParserREMOVE                = 99
	DelphiParserREPEAT                = 100
	DelphiParserREQUIRES              = 101
	DelphiParserRESIDENT              = 102
	DelphiParserRESOURCESTRING        = 103
	DelphiParserSAFECALL              = 104
	DelphiParserSEALED                = 105
	DelphiParserSET                   = 106
	DelphiParserSHL                   = 107
	DelphiParserSHR                   = 108
	DelphiParserSTATIC                = 109
	DelphiParserSTDCALL               = 110
	DelphiParserSTORED                = 111
	DelphiParserSTRICT                = 112
	DelphiParserSTRING                = 113
	DelphiParserTHEN                  = 114
	DelphiParserTHREADVAR             = 115
	DelphiParserTO                    = 116
	DelphiParserTRY                   = 117
	DelphiParserTYPE                  = 118
	DelphiParserUNIT                  = 119
	DelphiParserUNSAFE                = 120
	DelphiParserUNTIL                 = 121
	DelphiParserUSES                  = 122
	DelphiParserVAR                   = 123
	DelphiParserVARARGS               = 124
	DelphiParserVARIANT               = 125
	DelphiParserVIRTUAL               = 126
	DelphiParserWHILE                 = 127
	DelphiParserWITH                  = 128
	DelphiParserWRITE                 = 129
	DelphiParserWRITEONLY             = 130
	DelphiParserXOR                   = 131
	DelphiParserFALSE                 = 132
	DelphiParserTRUE                  = 133
	DelphiParserPLUS                  = 134
	DelphiParserMINUS                 = 135
	DelphiParserSTAR                  = 136
	DelphiParserSLASH                 = 137
	DelphiParserASSIGN                = 138
	DelphiParserCOMMA                 = 139
	DelphiParserSEMI                  = 140
	DelphiParserCOLON                 = 141
	DelphiParserEQUAL                 = 142
	DelphiParserNOT_EQUAL             = 143
	DelphiParserLT                    = 144
	DelphiParserLE                    = 145
	DelphiParserGE                    = 146
	DelphiParserGT                    = 147
	DelphiParserLPAREN                = 148
	DelphiParserRPAREN                = 149
	DelphiParserLBRACK                = 150
	DelphiParserLBRACK2               = 151
	DelphiParserRBRACK                = 152
	DelphiParserRBRACK2               = 153
	DelphiParserPOINTER2              = 154
	DelphiParserAT2                   = 155
	DelphiParserDOT                   = 156
	DelphiParserDOTDOT                = 157
	DelphiParserLCURLY                = 158
	DelphiParserRCURLY                = 159
	DelphiParserAMBER                 = 160
	DelphiParserDOUBLEAT              = 161
	DelphiParserTkGlobalFunction      = 162
	DelphiParserTkFunctionName        = 163
	DelphiParserTkFunctionArgs        = 164
	DelphiParserTkFunctionBody        = 165
	DelphiParserTkFunctionReturn      = 166
	DelphiParserTkCustomAttribute     = 167
	DelphiParserTkCustomAttributeArgs = 168
	DelphiParserTkNewType             = 169
	DelphiParserTkClass               = 170
	DelphiParserTkRecord              = 171
	DelphiParserTkRecordHelper        = 172
	DelphiParserTkInterface           = 173
	DelphiParserTkObject              = 174
	DelphiParserTkClassOfType         = 175
	DelphiParserTkVariableType        = 176
	DelphiParserTkVariableIdents      = 177
	DelphiParserTkVariableParam       = 178
	DelphiParserTkGuid                = 179
	DelphiParserTkClassParents        = 180
	DelphiParserTkClassField          = 181
	DelphiParserTkAnonymousExpression = 182
	DelphiParserTkIdentifier          = 183
	DelphiParserTkIntNum              = 184
	DelphiParserTkRealNum             = 185
	DelphiParserTkHexNum              = 186
	DelphiParserTkAsmHexNum           = 187
	DelphiParserTkAsmHexLabel         = 188
	DelphiParserQuotedString          = 189
	DelphiParserControlString         = 190
	DelphiParserHexdigitseq           = 191
	DelphiParserCOMMENT               = 192
	DelphiParserWS                    = 193
	DelphiParserUnicodeBOM            = 194
)

// DelphiParser rules.
const (
	DelphiParserRULE_file                         = 0
	DelphiParserRULE_program                      = 1
	DelphiParserRULE_programHead                  = 2
	DelphiParserRULE_programParmSeq               = 3
	DelphiParserRULE_library                      = 4
	DelphiParserRULE_libraryHead                  = 5
	DelphiParserRULE_packageE                     = 6
	DelphiParserRULE_packageHead                  = 7
	DelphiParserRULE_unit                         = 8
	DelphiParserRULE_unitHead                     = 9
	DelphiParserRULE_unitInterface                = 10
	DelphiParserRULE_unitImplementation           = 11
	DelphiParserRULE_unitBlock                    = 12
	DelphiParserRULE_unitInitialization           = 13
	DelphiParserRULE_unitFinalization             = 14
	DelphiParserRULE_containsClause               = 15
	DelphiParserRULE_requiresClause               = 16
	DelphiParserRULE_usesClause                   = 17
	DelphiParserRULE_usesFileClause               = 18
	DelphiParserRULE_namespaceFileNameList        = 19
	DelphiParserRULE_namespaceFileName            = 20
	DelphiParserRULE_namespaceNameList            = 21
	DelphiParserRULE_block                        = 22
	DelphiParserRULE_blockBody                    = 23
	DelphiParserRULE_declSection                  = 24
	DelphiParserRULE_interfaceDecl                = 25
	DelphiParserRULE_labelDeclSection             = 26
	DelphiParserRULE_constSection                 = 27
	DelphiParserRULE_constKey                     = 28
	DelphiParserRULE_constDeclaration             = 29
	DelphiParserRULE_typeSection                  = 30
	DelphiParserRULE_typeDeclaration              = 31
	DelphiParserRULE_varSection                   = 32
	DelphiParserRULE_varKey                       = 33
	DelphiParserRULE_varDeclaration               = 34
	DelphiParserRULE_varValueSpec                 = 35
	DelphiParserRULE_exportsSection               = 36
	DelphiParserRULE_exportItem                   = 37
	DelphiParserRULE_typeDecl                     = 38
	DelphiParserRULE_strucType                    = 39
	DelphiParserRULE_strucTypePart                = 40
	DelphiParserRULE_arrayType                    = 41
	DelphiParserRULE_arrayIndex                   = 42
	DelphiParserRULE_arraySubType                 = 43
	DelphiParserRULE_setType                      = 44
	DelphiParserRULE_fileType                     = 45
	DelphiParserRULE_pointerType                  = 46
	DelphiParserRULE_stringType                   = 47
	DelphiParserRULE_codePageNumber               = 48
	DelphiParserRULE_procedureType                = 49
	DelphiParserRULE_methodType                   = 50
	DelphiParserRULE_simpleProcedureType          = 51
	DelphiParserRULE_procedureReference           = 52
	DelphiParserRULE_procedureTypeHeading         = 53
	DelphiParserRULE_variantType                  = 54
	DelphiParserRULE_simpleType                   = 55
	DelphiParserRULE_subRangeType                 = 56
	DelphiParserRULE_enumType                     = 57
	DelphiParserRULE_typeId                       = 58
	DelphiParserRULE_genericTypeIdent             = 59
	DelphiParserRULE_genericDefinition            = 60
	DelphiParserRULE_simpleGenericDefinition      = 61
	DelphiParserRULE_constrainedGenericDefinition = 62
	DelphiParserRULE_constrainedGeneric           = 63
	DelphiParserRULE_genericConstraint            = 64
	DelphiParserRULE_genericPostfix               = 65
	DelphiParserRULE_classDecl                    = 66
	DelphiParserRULE_classTypeTypeDecl            = 67
	DelphiParserRULE_classTypeDecl                = 68
	DelphiParserRULE_classState                   = 69
	DelphiParserRULE_classParent                  = 70
	DelphiParserRULE_classItem                    = 71
	DelphiParserRULE_classHelperDecl              = 72
	DelphiParserRULE_classHelperItem              = 73
	DelphiParserRULE_interfaceTypeDecl            = 74
	DelphiParserRULE_interfaceKey                 = 75
	DelphiParserRULE_interfaceGuid                = 76
	DelphiParserRULE_interfaceItem                = 77
	DelphiParserRULE_objectDecl                   = 78
	DelphiParserRULE_objectItem                   = 79
	DelphiParserRULE_recordDecl                   = 80
	DelphiParserRULE_simpleRecord                 = 81
	DelphiParserRULE_variantRecord                = 82
	DelphiParserRULE_recordItem                   = 83
	DelphiParserRULE_recordField                  = 84
	DelphiParserRULE_recordVariantField           = 85
	DelphiParserRULE_recordVariantSection         = 86
	DelphiParserRULE_recordVariant                = 87
	DelphiParserRULE_recordHelperDecl             = 88
	DelphiParserRULE_recordHelperItem             = 89
	DelphiParserRULE_classMethod                  = 90
	DelphiParserRULE_classField                   = 91
	DelphiParserRULE_classProperty                = 92
	DelphiParserRULE_classPropertyArray           = 93
	DelphiParserRULE_classPropertyIndex           = 94
	DelphiParserRULE_classPropertySpecifier       = 95
	DelphiParserRULE_classPropertyEndSpecifier    = 96
	DelphiParserRULE_classPropertyReadWrite       = 97
	DelphiParserRULE_classPropertyDispInterface   = 98
	DelphiParserRULE_visibility                   = 99
	DelphiParserRULE_exportedProcHeading          = 100
	DelphiParserRULE_methodDecl                   = 101
	DelphiParserRULE_methodDeclHeading            = 102
	DelphiParserRULE_methodKey                    = 103
	DelphiParserRULE_methodName                   = 104
	DelphiParserRULE_procDecl                     = 105
	DelphiParserRULE_procDeclHeading              = 106
	DelphiParserRULE_formalParameterSection       = 107
	DelphiParserRULE_formalParameterList          = 108
	DelphiParserRULE_formalParameter              = 109
	DelphiParserRULE_parmType                     = 110
	DelphiParserRULE_methodBody                   = 111
	DelphiParserRULE_procBody                     = 112
	DelphiParserRULE_customAttribute              = 113
	DelphiParserRULE_customAttributeList          = 114
	DelphiParserRULE_customAttributeDecl          = 115
	DelphiParserRULE_expression                   = 116
	DelphiParserRULE_anonymousExpression          = 117
	DelphiParserRULE_simpleExpression             = 118
	DelphiParserRULE_factor                       = 119
	DelphiParserRULE_stringFactor                 = 120
	DelphiParserRULE_setSection                   = 121
	DelphiParserRULE_designator                   = 122
	DelphiParserRULE_designatorItem               = 123
	DelphiParserRULE_expressionList               = 124
	DelphiParserRULE_colonConstruct               = 125
	DelphiParserRULE_operator                     = 126
	DelphiParserRULE_relOp                        = 127
	DelphiParserRULE_statement                    = 128
	DelphiParserRULE_ifStatement                  = 129
	DelphiParserRULE_caseStatement                = 130
	DelphiParserRULE_caseItem                     = 131
	DelphiParserRULE_caseLabel                    = 132
	DelphiParserRULE_repeatStatement              = 133
	DelphiParserRULE_whileStatement               = 134
	DelphiParserRULE_forStatement                 = 135
	DelphiParserRULE_withStatement                = 136
	DelphiParserRULE_withItem                     = 137
	DelphiParserRULE_compoundStatement            = 138
	DelphiParserRULE_statementList                = 139
	DelphiParserRULE_simpleStatement              = 140
	DelphiParserRULE_gotoStatement                = 141
	DelphiParserRULE_constExpression              = 142
	DelphiParserRULE_recordConstExpression        = 143
	DelphiParserRULE_tryStatement                 = 144
	DelphiParserRULE_handlerList                  = 145
	DelphiParserRULE_handler                      = 146
	DelphiParserRULE_handlerIdent                 = 147
	DelphiParserRULE_handlerStatement             = 148
	DelphiParserRULE_raiseStatement               = 149
	DelphiParserRULE_assemblerStatement           = 150
	DelphiParserRULE_methodDirective              = 151
	DelphiParserRULE_functionDirective            = 152
	DelphiParserRULE_reintroduceDirective         = 153
	DelphiParserRULE_overloadDirective            = 154
	DelphiParserRULE_bindingDirective             = 155
	DelphiParserRULE_abstractDirective            = 156
	DelphiParserRULE_inlineDirective              = 157
	DelphiParserRULE_callConvention               = 158
	DelphiParserRULE_callConventionNoSemi         = 159
	DelphiParserRULE_oldCallConventionDirective   = 160
	DelphiParserRULE_hintingDirective             = 161
	DelphiParserRULE_externalDirective            = 162
	DelphiParserRULE_externalSpecifier            = 163
	DelphiParserRULE_dispIDDirective              = 164
	DelphiParserRULE_ident                        = 165
	DelphiParserRULE_usedKeywordsAsNames          = 166
	DelphiParserRULE_identList                    = 167
	DelphiParserRULE_identListFlat                = 168
	DelphiParserRULE_label                        = 169
	DelphiParserRULE_intNum                       = 170
	DelphiParserRULE_realNum                      = 171
	DelphiParserRULE_namespacedQualifiedIdent     = 172
	DelphiParserRULE_namespaceName                = 173
	DelphiParserRULE_qualifiedIdent               = 174
)

// IFileContext is an interface to support dynamic dispatch.
type IFileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Program() IProgramContext
	Library() ILibraryContext
	Unit() IUnitContext
	PackageE() IPackageEContext

	// IsFileContext differentiates from other interfaces.
	IsFileContext()
}

type FileContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileContext() *FileContext {
	var p = new(FileContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_file
	return p
}

func InitEmptyFileContext(p *FileContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_file
}

func (*FileContext) IsFileContext() {}

func NewFileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileContext {
	var p = new(FileContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_file

	return p
}

func (s *FileContext) GetParser() antlr.Parser { return s.parser }

func (s *FileContext) Program() IProgramContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgramContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgramContext)
}

func (s *FileContext) Library() ILibraryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryContext)
}

func (s *FileContext) Unit() IUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitContext)
}

func (s *FileContext) PackageE() IPackageEContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageEContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageEContext)
}

func (s *FileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterFile(s)
	}
}

func (s *FileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitFile(s)
	}
}

func (p *DelphiParser) File() (localctx IFileContext) {
	localctx = NewFileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, DelphiParserRULE_file)
	p.SetState(354)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserT__0, DelphiParserASM, DelphiParserBEGIN, DelphiParserCLASS, DelphiParserCONST, DelphiParserCONSTRUCTOR, DelphiParserDESTRUCTOR, DelphiParserEXPORTS, DelphiParserFUNCTION, DelphiParserLABEL, DelphiParserPROCEDURE, DelphiParserPROGRAM, DelphiParserRESOURCESTRING, DelphiParserTHREADVAR, DelphiParserTYPE, DelphiParserUSES, DelphiParserVAR, DelphiParserDOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(350)
			p.Program()
		}

	case DelphiParserLIBRARY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(351)
			p.Library()
		}

	case DelphiParserUNIT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(352)
			p.Unit()
		}

	case DelphiParserPACKAGE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(353)
			p.PackageE()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	DOT() antlr.TerminalNode
	ProgramHead() IProgramHeadContext
	UsesFileClause() IUsesFileClauseContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ProgramContext) DOT() antlr.TerminalNode {
	return s.GetToken(DelphiParserDOT, 0)
}

func (s *ProgramContext) ProgramHead() IProgramHeadContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgramHeadContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgramHeadContext)
}

func (s *ProgramContext) UsesFileClause() IUsesFileClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsesFileClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsesFileClauseContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (p *DelphiParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, DelphiParserRULE_program)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(357)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserPROGRAM {
		{
			p.SetState(356)
			p.ProgramHead()
		}

	}
	p.SetState(360)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserUSES {
		{
			p.SetState(359)
			p.UsesFileClause()
		}

	}
	{
		p.SetState(362)
		p.Block()
	}
	{
		p.SetState(363)
		p.Match(DelphiParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProgramHeadContext is an interface to support dynamic dispatch.
type IProgramHeadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROGRAM() antlr.TerminalNode
	NamespaceName() INamespaceNameContext
	SEMI() antlr.TerminalNode
	ProgramParmSeq() IProgramParmSeqContext

	// IsProgramHeadContext differentiates from other interfaces.
	IsProgramHeadContext()
}

type ProgramHeadContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramHeadContext() *ProgramHeadContext {
	var p = new(ProgramHeadContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_programHead
	return p
}

func InitEmptyProgramHeadContext(p *ProgramHeadContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_programHead
}

func (*ProgramHeadContext) IsProgramHeadContext() {}

func NewProgramHeadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramHeadContext {
	var p = new(ProgramHeadContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_programHead

	return p
}

func (s *ProgramHeadContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramHeadContext) PROGRAM() antlr.TerminalNode {
	return s.GetToken(DelphiParserPROGRAM, 0)
}

func (s *ProgramHeadContext) NamespaceName() INamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameContext)
}

func (s *ProgramHeadContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *ProgramHeadContext) ProgramParmSeq() IProgramParmSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgramParmSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgramParmSeqContext)
}

func (s *ProgramHeadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramHeadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramHeadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterProgramHead(s)
	}
}

func (s *ProgramHeadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitProgramHead(s)
	}
}

func (p *DelphiParser) ProgramHead() (localctx IProgramHeadContext) {
	localctx = NewProgramHeadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, DelphiParserRULE_programHead)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(365)
		p.Match(DelphiParserPROGRAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(366)
		p.NamespaceName()
	}
	p.SetState(368)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserLPAREN {
		{
			p.SetState(367)
			p.ProgramParmSeq()
		}

	}
	{
		p.SetState(370)
		p.Match(DelphiParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProgramParmSeqContext is an interface to support dynamic dispatch.
type IProgramParmSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsProgramParmSeqContext differentiates from other interfaces.
	IsProgramParmSeqContext()
}

type ProgramParmSeqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramParmSeqContext() *ProgramParmSeqContext {
	var p = new(ProgramParmSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_programParmSeq
	return p
}

func InitEmptyProgramParmSeqContext(p *ProgramParmSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_programParmSeq
}

func (*ProgramParmSeqContext) IsProgramParmSeqContext() {}

func NewProgramParmSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramParmSeqContext {
	var p = new(ProgramParmSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_programParmSeq

	return p
}

func (s *ProgramParmSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramParmSeqContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserLPAREN, 0)
}

func (s *ProgramParmSeqContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserRPAREN, 0)
}

func (s *ProgramParmSeqContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *ProgramParmSeqContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *ProgramParmSeqContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserCOMMA)
}

func (s *ProgramParmSeqContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserCOMMA, i)
}

func (s *ProgramParmSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramParmSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramParmSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterProgramParmSeq(s)
	}
}

func (s *ProgramParmSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitProgramParmSeq(s)
	}
}

func (p *DelphiParser) ProgramParmSeq() (localctx IProgramParmSeqContext) {
	localctx = NewProgramParmSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, DelphiParserRULE_programParmSeq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(372)
		p.Match(DelphiParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(381)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&90090271942938704) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2306828220488493323) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&18014400656965633) != 0) {
		{
			p.SetState(373)
			p.Ident()
		}
		p.SetState(378)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DelphiParserCOMMA {
			{
				p.SetState(374)
				p.Match(DelphiParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(375)
				p.Ident()
			}

			p.SetState(380)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(383)
		p.Match(DelphiParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILibraryContext is an interface to support dynamic dispatch.
type ILibraryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LibraryHead() ILibraryHeadContext
	Block() IBlockContext
	DOT() antlr.TerminalNode
	UsesFileClause() IUsesFileClauseContext

	// IsLibraryContext differentiates from other interfaces.
	IsLibraryContext()
}

type LibraryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryContext() *LibraryContext {
	var p = new(LibraryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_library
	return p
}

func InitEmptyLibraryContext(p *LibraryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_library
}

func (*LibraryContext) IsLibraryContext() {}

func NewLibraryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryContext {
	var p = new(LibraryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_library

	return p
}

func (s *LibraryContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryContext) LibraryHead() ILibraryHeadContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryHeadContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryHeadContext)
}

func (s *LibraryContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *LibraryContext) DOT() antlr.TerminalNode {
	return s.GetToken(DelphiParserDOT, 0)
}

func (s *LibraryContext) UsesFileClause() IUsesFileClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsesFileClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsesFileClauseContext)
}

func (s *LibraryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterLibrary(s)
	}
}

func (s *LibraryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitLibrary(s)
	}
}

func (p *DelphiParser) Library() (localctx ILibraryContext) {
	localctx = NewLibraryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, DelphiParserRULE_library)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(385)
		p.LibraryHead()
	}
	p.SetState(387)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserUSES {
		{
			p.SetState(386)
			p.UsesFileClause()
		}

	}
	{
		p.SetState(389)
		p.Block()
	}
	{
		p.SetState(390)
		p.Match(DelphiParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILibraryHeadContext is an interface to support dynamic dispatch.
type ILibraryHeadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIBRARY() antlr.TerminalNode
	NamespaceName() INamespaceNameContext
	SEMI() antlr.TerminalNode
	AllHintingDirective() []IHintingDirectiveContext
	HintingDirective(i int) IHintingDirectiveContext

	// IsLibraryHeadContext differentiates from other interfaces.
	IsLibraryHeadContext()
}

type LibraryHeadContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryHeadContext() *LibraryHeadContext {
	var p = new(LibraryHeadContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_libraryHead
	return p
}

func InitEmptyLibraryHeadContext(p *LibraryHeadContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_libraryHead
}

func (*LibraryHeadContext) IsLibraryHeadContext() {}

func NewLibraryHeadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryHeadContext {
	var p = new(LibraryHeadContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_libraryHead

	return p
}

func (s *LibraryHeadContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryHeadContext) LIBRARY() antlr.TerminalNode {
	return s.GetToken(DelphiParserLIBRARY, 0)
}

func (s *LibraryHeadContext) NamespaceName() INamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameContext)
}

func (s *LibraryHeadContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *LibraryHeadContext) AllHintingDirective() []IHintingDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintingDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IHintingDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintingDirectiveContext); ok {
			tst[i] = t.(IHintingDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *LibraryHeadContext) HintingDirective(i int) IHintingDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintingDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintingDirectiveContext)
}

func (s *LibraryHeadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryHeadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryHeadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterLibraryHead(s)
	}
}

func (s *LibraryHeadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitLibraryHead(s)
	}
}

func (p *DelphiParser) LibraryHead() (localctx ILibraryHeadContext) {
	localctx = NewLibraryHeadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, DelphiParserRULE_libraryHead)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(392)
		p.Match(DelphiParserLIBRARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(393)
		p.NamespaceName()
	}
	p.SetState(397)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&576461302059253761) != 0 {
		{
			p.SetState(394)
			p.HintingDirective()
		}

		p.SetState(399)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(400)
		p.Match(DelphiParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackageEContext is an interface to support dynamic dispatch.
type IPackageEContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PackageHead() IPackageHeadContext
	RequiresClause() IRequiresClauseContext
	END() antlr.TerminalNode
	DOT() antlr.TerminalNode
	ContainsClause() IContainsClauseContext

	// IsPackageEContext differentiates from other interfaces.
	IsPackageEContext()
}

type PackageEContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageEContext() *PackageEContext {
	var p = new(PackageEContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_packageE
	return p
}

func InitEmptyPackageEContext(p *PackageEContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_packageE
}

func (*PackageEContext) IsPackageEContext() {}

func NewPackageEContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageEContext {
	var p = new(PackageEContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_packageE

	return p
}

func (s *PackageEContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageEContext) PackageHead() IPackageHeadContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageHeadContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageHeadContext)
}

func (s *PackageEContext) RequiresClause() IRequiresClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRequiresClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRequiresClauseContext)
}

func (s *PackageEContext) END() antlr.TerminalNode {
	return s.GetToken(DelphiParserEND, 0)
}

func (s *PackageEContext) DOT() antlr.TerminalNode {
	return s.GetToken(DelphiParserDOT, 0)
}

func (s *PackageEContext) ContainsClause() IContainsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContainsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContainsClauseContext)
}

func (s *PackageEContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageEContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageEContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterPackageE(s)
	}
}

func (s *PackageEContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitPackageE(s)
	}
}

func (p *DelphiParser) PackageE() (localctx IPackageEContext) {
	localctx = NewPackageEContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, DelphiParserRULE_packageE)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(402)
		p.PackageHead()
	}
	{
		p.SetState(403)
		p.RequiresClause()
	}
	p.SetState(405)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserCONTAINS {
		{
			p.SetState(404)
			p.ContainsClause()
		}

	}
	{
		p.SetState(407)
		p.Match(DelphiParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(408)
		p.Match(DelphiParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackageHeadContext is an interface to support dynamic dispatch.
type IPackageHeadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PACKAGE() antlr.TerminalNode
	NamespaceName() INamespaceNameContext
	SEMI() antlr.TerminalNode

	// IsPackageHeadContext differentiates from other interfaces.
	IsPackageHeadContext()
}

type PackageHeadContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageHeadContext() *PackageHeadContext {
	var p = new(PackageHeadContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_packageHead
	return p
}

func InitEmptyPackageHeadContext(p *PackageHeadContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_packageHead
}

func (*PackageHeadContext) IsPackageHeadContext() {}

func NewPackageHeadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageHeadContext {
	var p = new(PackageHeadContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_packageHead

	return p
}

func (s *PackageHeadContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageHeadContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(DelphiParserPACKAGE, 0)
}

func (s *PackageHeadContext) NamespaceName() INamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameContext)
}

func (s *PackageHeadContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *PackageHeadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageHeadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageHeadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterPackageHead(s)
	}
}

func (s *PackageHeadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitPackageHead(s)
	}
}

func (p *DelphiParser) PackageHead() (localctx IPackageHeadContext) {
	localctx = NewPackageHeadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, DelphiParserRULE_packageHead)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(410)
		p.Match(DelphiParserPACKAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(411)
		p.NamespaceName()
	}
	{
		p.SetState(412)
		p.Match(DelphiParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitContext is an interface to support dynamic dispatch.
type IUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnitHead() IUnitHeadContext
	UnitInterface() IUnitInterfaceContext
	UnitImplementation() IUnitImplementationContext
	UnitBlock() IUnitBlockContext
	DOT() antlr.TerminalNode

	// IsUnitContext differentiates from other interfaces.
	IsUnitContext()
}

type UnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitContext() *UnitContext {
	var p = new(UnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_unit
	return p
}

func InitEmptyUnitContext(p *UnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_unit
}

func (*UnitContext) IsUnitContext() {}

func NewUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitContext {
	var p = new(UnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_unit

	return p
}

func (s *UnitContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitContext) UnitHead() IUnitHeadContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitHeadContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitHeadContext)
}

func (s *UnitContext) UnitInterface() IUnitInterfaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitInterfaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitInterfaceContext)
}

func (s *UnitContext) UnitImplementation() IUnitImplementationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitImplementationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitImplementationContext)
}

func (s *UnitContext) UnitBlock() IUnitBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitBlockContext)
}

func (s *UnitContext) DOT() antlr.TerminalNode {
	return s.GetToken(DelphiParserDOT, 0)
}

func (s *UnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterUnit(s)
	}
}

func (s *UnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitUnit(s)
	}
}

func (p *DelphiParser) Unit() (localctx IUnitContext) {
	localctx = NewUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, DelphiParserRULE_unit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(414)
		p.UnitHead()
	}
	{
		p.SetState(415)
		p.UnitInterface()
	}
	{
		p.SetState(416)
		p.UnitImplementation()
	}
	{
		p.SetState(417)
		p.UnitBlock()
	}
	{
		p.SetState(418)
		p.Match(DelphiParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitHeadContext is an interface to support dynamic dispatch.
type IUnitHeadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNIT() antlr.TerminalNode
	NamespaceName() INamespaceNameContext
	SEMI() antlr.TerminalNode
	AllHintingDirective() []IHintingDirectiveContext
	HintingDirective(i int) IHintingDirectiveContext

	// IsUnitHeadContext differentiates from other interfaces.
	IsUnitHeadContext()
}

type UnitHeadContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitHeadContext() *UnitHeadContext {
	var p = new(UnitHeadContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_unitHead
	return p
}

func InitEmptyUnitHeadContext(p *UnitHeadContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_unitHead
}

func (*UnitHeadContext) IsUnitHeadContext() {}

func NewUnitHeadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitHeadContext {
	var p = new(UnitHeadContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_unitHead

	return p
}

func (s *UnitHeadContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitHeadContext) UNIT() antlr.TerminalNode {
	return s.GetToken(DelphiParserUNIT, 0)
}

func (s *UnitHeadContext) NamespaceName() INamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameContext)
}

func (s *UnitHeadContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *UnitHeadContext) AllHintingDirective() []IHintingDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintingDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IHintingDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintingDirectiveContext); ok {
			tst[i] = t.(IHintingDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *UnitHeadContext) HintingDirective(i int) IHintingDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintingDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintingDirectiveContext)
}

func (s *UnitHeadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitHeadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitHeadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterUnitHead(s)
	}
}

func (s *UnitHeadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitUnitHead(s)
	}
}

func (p *DelphiParser) UnitHead() (localctx IUnitHeadContext) {
	localctx = NewUnitHeadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, DelphiParserRULE_unitHead)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(420)
		p.Match(DelphiParserUNIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(421)
		p.NamespaceName()
	}
	p.SetState(425)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&576461302059253761) != 0 {
		{
			p.SetState(422)
			p.HintingDirective()
		}

		p.SetState(427)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(428)
		p.Match(DelphiParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitInterfaceContext is an interface to support dynamic dispatch.
type IUnitInterfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	UsesClause() IUsesClauseContext
	AllInterfaceDecl() []IInterfaceDeclContext
	InterfaceDecl(i int) IInterfaceDeclContext

	// IsUnitInterfaceContext differentiates from other interfaces.
	IsUnitInterfaceContext()
}

type UnitInterfaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitInterfaceContext() *UnitInterfaceContext {
	var p = new(UnitInterfaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_unitInterface
	return p
}

func InitEmptyUnitInterfaceContext(p *UnitInterfaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_unitInterface
}

func (*UnitInterfaceContext) IsUnitInterfaceContext() {}

func NewUnitInterfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitInterfaceContext {
	var p = new(UnitInterfaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_unitInterface

	return p
}

func (s *UnitInterfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitInterfaceContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(DelphiParserINTERFACE, 0)
}

func (s *UnitInterfaceContext) UsesClause() IUsesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsesClauseContext)
}

func (s *UnitInterfaceContext) AllInterfaceDecl() []IInterfaceDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceDeclContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceDeclContext); ok {
			tst[i] = t.(IInterfaceDeclContext)
			i++
		}
	}

	return tst
}

func (s *UnitInterfaceContext) InterfaceDecl(i int) IInterfaceDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclContext)
}

func (s *UnitInterfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitInterfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitInterfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterUnitInterface(s)
	}
}

func (s *UnitInterfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitUnitInterface(s)
	}
}

func (p *DelphiParser) UnitInterface() (localctx IUnitInterfaceContext) {
	localctx = NewUnitInterfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, DelphiParserRULE_unitInterface)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(430)
		p.Match(DelphiParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(432)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserUSES {
		{
			p.SetState(431)
			p.UsesClause()
		}

	}
	p.SetState(437)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&564049500438530) != 0) || ((int64((_la-86)) & ^0x3f) == 0 && ((int64(1)<<(_la-86))&142270922753) != 0) {
		{
			p.SetState(434)
			p.InterfaceDecl()
		}

		p.SetState(439)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitImplementationContext is an interface to support dynamic dispatch.
type IUnitImplementationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPLEMENTATION() antlr.TerminalNode
	UsesClause() IUsesClauseContext
	AllDeclSection() []IDeclSectionContext
	DeclSection(i int) IDeclSectionContext

	// IsUnitImplementationContext differentiates from other interfaces.
	IsUnitImplementationContext()
}

type UnitImplementationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitImplementationContext() *UnitImplementationContext {
	var p = new(UnitImplementationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_unitImplementation
	return p
}

func InitEmptyUnitImplementationContext(p *UnitImplementationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_unitImplementation
}

func (*UnitImplementationContext) IsUnitImplementationContext() {}

func NewUnitImplementationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitImplementationContext {
	var p = new(UnitImplementationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_unitImplementation

	return p
}

func (s *UnitImplementationContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitImplementationContext) IMPLEMENTATION() antlr.TerminalNode {
	return s.GetToken(DelphiParserIMPLEMENTATION, 0)
}

func (s *UnitImplementationContext) UsesClause() IUsesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsesClauseContext)
}

func (s *UnitImplementationContext) AllDeclSection() []IDeclSectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclSectionContext); ok {
			len++
		}
	}

	tst := make([]IDeclSectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclSectionContext); ok {
			tst[i] = t.(IDeclSectionContext)
			i++
		}
	}

	return tst
}

func (s *UnitImplementationContext) DeclSection(i int) IDeclSectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclSectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclSectionContext)
}

func (s *UnitImplementationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitImplementationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitImplementationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterUnitImplementation(s)
	}
}

func (s *UnitImplementationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitUnitImplementation(s)
	}
}

func (p *DelphiParser) UnitImplementation() (localctx IUnitImplementationContext) {
	localctx = NewUnitImplementationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, DelphiParserRULE_unitImplementation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(440)
		p.Match(DelphiParserIMPLEMENTATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(442)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserUSES {
		{
			p.SetState(441)
			p.UsesClause()
		}

	}
	p.SetState(447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4612250067927826434) != 0) || ((int64((_la-86)) & ^0x3f) == 0 && ((int64(1)<<(_la-86))&142270922753) != 0) {
		{
			p.SetState(444)
			p.DeclSection()
		}

		p.SetState(449)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitBlockContext is an interface to support dynamic dispatch.
type IUnitBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnitInitialization() IUnitInitializationContext
	END() antlr.TerminalNode
	CompoundStatement() ICompoundStatementContext

	// IsUnitBlockContext differentiates from other interfaces.
	IsUnitBlockContext()
}

type UnitBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitBlockContext() *UnitBlockContext {
	var p = new(UnitBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_unitBlock
	return p
}

func InitEmptyUnitBlockContext(p *UnitBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_unitBlock
}

func (*UnitBlockContext) IsUnitBlockContext() {}

func NewUnitBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitBlockContext {
	var p = new(UnitBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_unitBlock

	return p
}

func (s *UnitBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitBlockContext) UnitInitialization() IUnitInitializationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitInitializationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitInitializationContext)
}

func (s *UnitBlockContext) END() antlr.TerminalNode {
	return s.GetToken(DelphiParserEND, 0)
}

func (s *UnitBlockContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *UnitBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterUnitBlock(s)
	}
}

func (s *UnitBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitUnitBlock(s)
	}
}

func (p *DelphiParser) UnitBlock() (localctx IUnitBlockContext) {
	localctx = NewUnitBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, DelphiParserRULE_unitBlock)
	p.SetState(455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserINITIALIZATION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(450)
			p.UnitInitialization()
		}
		{
			p.SetState(451)
			p.Match(DelphiParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserBEGIN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(453)
			p.CompoundStatement()
		}

	case DelphiParserEND:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(454)
			p.Match(DelphiParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitInitializationContext is an interface to support dynamic dispatch.
type IUnitInitializationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INITIALIZATION() antlr.TerminalNode
	StatementList() IStatementListContext
	UnitFinalization() IUnitFinalizationContext

	// IsUnitInitializationContext differentiates from other interfaces.
	IsUnitInitializationContext()
}

type UnitInitializationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitInitializationContext() *UnitInitializationContext {
	var p = new(UnitInitializationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_unitInitialization
	return p
}

func InitEmptyUnitInitializationContext(p *UnitInitializationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_unitInitialization
}

func (*UnitInitializationContext) IsUnitInitializationContext() {}

func NewUnitInitializationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitInitializationContext {
	var p = new(UnitInitializationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_unitInitialization

	return p
}

func (s *UnitInitializationContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitInitializationContext) INITIALIZATION() antlr.TerminalNode {
	return s.GetToken(DelphiParserINITIALIZATION, 0)
}

func (s *UnitInitializationContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *UnitInitializationContext) UnitFinalization() IUnitFinalizationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitFinalizationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitFinalizationContext)
}

func (s *UnitInitializationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitInitializationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitInitializationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterUnitInitialization(s)
	}
}

func (s *UnitInitializationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitUnitInitialization(s)
	}
}

func (p *DelphiParser) UnitInitialization() (localctx IUnitInitializationContext) {
	localctx = NewUnitInitializationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, DelphiParserRULE_unitInitialization)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(457)
		p.Match(DelphiParserINITIALIZATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(458)
		p.StatementList()
	}
	p.SetState(460)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserFINALIZATION {
		{
			p.SetState(459)
			p.UnitFinalization()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitFinalizationContext is an interface to support dynamic dispatch.
type IUnitFinalizationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FINALIZATION() antlr.TerminalNode
	StatementList() IStatementListContext

	// IsUnitFinalizationContext differentiates from other interfaces.
	IsUnitFinalizationContext()
}

type UnitFinalizationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitFinalizationContext() *UnitFinalizationContext {
	var p = new(UnitFinalizationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_unitFinalization
	return p
}

func InitEmptyUnitFinalizationContext(p *UnitFinalizationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_unitFinalization
}

func (*UnitFinalizationContext) IsUnitFinalizationContext() {}

func NewUnitFinalizationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitFinalizationContext {
	var p = new(UnitFinalizationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_unitFinalization

	return p
}

func (s *UnitFinalizationContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitFinalizationContext) FINALIZATION() antlr.TerminalNode {
	return s.GetToken(DelphiParserFINALIZATION, 0)
}

func (s *UnitFinalizationContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *UnitFinalizationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitFinalizationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitFinalizationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterUnitFinalization(s)
	}
}

func (s *UnitFinalizationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitUnitFinalization(s)
	}
}

func (p *DelphiParser) UnitFinalization() (localctx IUnitFinalizationContext) {
	localctx = NewUnitFinalizationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, DelphiParserRULE_unitFinalization)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(462)
		p.Match(DelphiParserFINALIZATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(463)
		p.StatementList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContainsClauseContext is an interface to support dynamic dispatch.
type IContainsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONTAINS() antlr.TerminalNode
	NamespaceFileNameList() INamespaceFileNameListContext

	// IsContainsClauseContext differentiates from other interfaces.
	IsContainsClauseContext()
}

type ContainsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContainsClauseContext() *ContainsClauseContext {
	var p = new(ContainsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_containsClause
	return p
}

func InitEmptyContainsClauseContext(p *ContainsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_containsClause
}

func (*ContainsClauseContext) IsContainsClauseContext() {}

func NewContainsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContainsClauseContext {
	var p = new(ContainsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_containsClause

	return p
}

func (s *ContainsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ContainsClauseContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(DelphiParserCONTAINS, 0)
}

func (s *ContainsClauseContext) NamespaceFileNameList() INamespaceFileNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceFileNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceFileNameListContext)
}

func (s *ContainsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContainsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContainsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterContainsClause(s)
	}
}

func (s *ContainsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitContainsClause(s)
	}
}

func (p *DelphiParser) ContainsClause() (localctx IContainsClauseContext) {
	localctx = NewContainsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, DelphiParserRULE_containsClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(465)
		p.Match(DelphiParserCONTAINS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(466)
		p.NamespaceFileNameList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRequiresClauseContext is an interface to support dynamic dispatch.
type IRequiresClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REQUIRES() antlr.TerminalNode
	NamespaceNameList() INamespaceNameListContext

	// IsRequiresClauseContext differentiates from other interfaces.
	IsRequiresClauseContext()
}

type RequiresClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRequiresClauseContext() *RequiresClauseContext {
	var p = new(RequiresClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_requiresClause
	return p
}

func InitEmptyRequiresClauseContext(p *RequiresClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_requiresClause
}

func (*RequiresClauseContext) IsRequiresClauseContext() {}

func NewRequiresClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RequiresClauseContext {
	var p = new(RequiresClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_requiresClause

	return p
}

func (s *RequiresClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RequiresClauseContext) REQUIRES() antlr.TerminalNode {
	return s.GetToken(DelphiParserREQUIRES, 0)
}

func (s *RequiresClauseContext) NamespaceNameList() INamespaceNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameListContext)
}

func (s *RequiresClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RequiresClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RequiresClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterRequiresClause(s)
	}
}

func (s *RequiresClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitRequiresClause(s)
	}
}

func (p *DelphiParser) RequiresClause() (localctx IRequiresClauseContext) {
	localctx = NewRequiresClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, DelphiParserRULE_requiresClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(468)
		p.Match(DelphiParserREQUIRES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(469)
		p.NamespaceNameList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsesClauseContext is an interface to support dynamic dispatch.
type IUsesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USES() antlr.TerminalNode
	NamespaceNameList() INamespaceNameListContext

	// IsUsesClauseContext differentiates from other interfaces.
	IsUsesClauseContext()
}

type UsesClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsesClauseContext() *UsesClauseContext {
	var p = new(UsesClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_usesClause
	return p
}

func InitEmptyUsesClauseContext(p *UsesClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_usesClause
}

func (*UsesClauseContext) IsUsesClauseContext() {}

func NewUsesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsesClauseContext {
	var p = new(UsesClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_usesClause

	return p
}

func (s *UsesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UsesClauseContext) USES() antlr.TerminalNode {
	return s.GetToken(DelphiParserUSES, 0)
}

func (s *UsesClauseContext) NamespaceNameList() INamespaceNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameListContext)
}

func (s *UsesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterUsesClause(s)
	}
}

func (s *UsesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitUsesClause(s)
	}
}

func (p *DelphiParser) UsesClause() (localctx IUsesClauseContext) {
	localctx = NewUsesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, DelphiParserRULE_usesClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(471)
		p.Match(DelphiParserUSES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(472)
		p.NamespaceNameList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsesFileClauseContext is an interface to support dynamic dispatch.
type IUsesFileClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USES() antlr.TerminalNode
	NamespaceFileNameList() INamespaceFileNameListContext

	// IsUsesFileClauseContext differentiates from other interfaces.
	IsUsesFileClauseContext()
}

type UsesFileClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsesFileClauseContext() *UsesFileClauseContext {
	var p = new(UsesFileClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_usesFileClause
	return p
}

func InitEmptyUsesFileClauseContext(p *UsesFileClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_usesFileClause
}

func (*UsesFileClauseContext) IsUsesFileClauseContext() {}

func NewUsesFileClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsesFileClauseContext {
	var p = new(UsesFileClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_usesFileClause

	return p
}

func (s *UsesFileClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UsesFileClauseContext) USES() antlr.TerminalNode {
	return s.GetToken(DelphiParserUSES, 0)
}

func (s *UsesFileClauseContext) NamespaceFileNameList() INamespaceFileNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceFileNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceFileNameListContext)
}

func (s *UsesFileClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsesFileClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsesFileClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterUsesFileClause(s)
	}
}

func (s *UsesFileClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitUsesFileClause(s)
	}
}

func (p *DelphiParser) UsesFileClause() (localctx IUsesFileClauseContext) {
	localctx = NewUsesFileClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, DelphiParserRULE_usesFileClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(474)
		p.Match(DelphiParserUSES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(475)
		p.NamespaceFileNameList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamespaceFileNameListContext is an interface to support dynamic dispatch.
type INamespaceFileNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNamespaceFileName() []INamespaceFileNameContext
	NamespaceFileName(i int) INamespaceFileNameContext
	SEMI() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNamespaceFileNameListContext differentiates from other interfaces.
	IsNamespaceFileNameListContext()
}

type NamespaceFileNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceFileNameListContext() *NamespaceFileNameListContext {
	var p = new(NamespaceFileNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_namespaceFileNameList
	return p
}

func InitEmptyNamespaceFileNameListContext(p *NamespaceFileNameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_namespaceFileNameList
}

func (*NamespaceFileNameListContext) IsNamespaceFileNameListContext() {}

func NewNamespaceFileNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceFileNameListContext {
	var p = new(NamespaceFileNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_namespaceFileNameList

	return p
}

func (s *NamespaceFileNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceFileNameListContext) AllNamespaceFileName() []INamespaceFileNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamespaceFileNameContext); ok {
			len++
		}
	}

	tst := make([]INamespaceFileNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamespaceFileNameContext); ok {
			tst[i] = t.(INamespaceFileNameContext)
			i++
		}
	}

	return tst
}

func (s *NamespaceFileNameListContext) NamespaceFileName(i int) INamespaceFileNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceFileNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceFileNameContext)
}

func (s *NamespaceFileNameListContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *NamespaceFileNameListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserCOMMA)
}

func (s *NamespaceFileNameListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserCOMMA, i)
}

func (s *NamespaceFileNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceFileNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceFileNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterNamespaceFileNameList(s)
	}
}

func (s *NamespaceFileNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitNamespaceFileNameList(s)
	}
}

func (p *DelphiParser) NamespaceFileNameList() (localctx INamespaceFileNameListContext) {
	localctx = NewNamespaceFileNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, DelphiParserRULE_namespaceFileNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(477)
		p.NamespaceFileName()
	}
	p.SetState(482)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DelphiParserCOMMA {
		{
			p.SetState(478)
			p.Match(DelphiParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(479)
			p.NamespaceFileName()
		}

		p.SetState(484)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(485)
		p.Match(DelphiParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamespaceFileNameContext is an interface to support dynamic dispatch.
type INamespaceFileNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NamespaceName() INamespaceNameContext
	IN() antlr.TerminalNode
	QuotedString() antlr.TerminalNode

	// IsNamespaceFileNameContext differentiates from other interfaces.
	IsNamespaceFileNameContext()
}

type NamespaceFileNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceFileNameContext() *NamespaceFileNameContext {
	var p = new(NamespaceFileNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_namespaceFileName
	return p
}

func InitEmptyNamespaceFileNameContext(p *NamespaceFileNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_namespaceFileName
}

func (*NamespaceFileNameContext) IsNamespaceFileNameContext() {}

func NewNamespaceFileNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceFileNameContext {
	var p = new(NamespaceFileNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_namespaceFileName

	return p
}

func (s *NamespaceFileNameContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceFileNameContext) NamespaceName() INamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameContext)
}

func (s *NamespaceFileNameContext) IN() antlr.TerminalNode {
	return s.GetToken(DelphiParserIN, 0)
}

func (s *NamespaceFileNameContext) QuotedString() antlr.TerminalNode {
	return s.GetToken(DelphiParserQuotedString, 0)
}

func (s *NamespaceFileNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceFileNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceFileNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterNamespaceFileName(s)
	}
}

func (s *NamespaceFileNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitNamespaceFileName(s)
	}
}

func (p *DelphiParser) NamespaceFileName() (localctx INamespaceFileNameContext) {
	localctx = NewNamespaceFileNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, DelphiParserRULE_namespaceFileName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(487)
		p.NamespaceName()
	}
	p.SetState(490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserIN {
		{
			p.SetState(488)
			p.Match(DelphiParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(489)
			p.Match(DelphiParserQuotedString)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamespaceNameListContext is an interface to support dynamic dispatch.
type INamespaceNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNamespaceName() []INamespaceNameContext
	NamespaceName(i int) INamespaceNameContext
	SEMI() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNamespaceNameListContext differentiates from other interfaces.
	IsNamespaceNameListContext()
}

type NamespaceNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceNameListContext() *NamespaceNameListContext {
	var p = new(NamespaceNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_namespaceNameList
	return p
}

func InitEmptyNamespaceNameListContext(p *NamespaceNameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_namespaceNameList
}

func (*NamespaceNameListContext) IsNamespaceNameListContext() {}

func NewNamespaceNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceNameListContext {
	var p = new(NamespaceNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_namespaceNameList

	return p
}

func (s *NamespaceNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceNameListContext) AllNamespaceName() []INamespaceNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamespaceNameContext); ok {
			len++
		}
	}

	tst := make([]INamespaceNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamespaceNameContext); ok {
			tst[i] = t.(INamespaceNameContext)
			i++
		}
	}

	return tst
}

func (s *NamespaceNameListContext) NamespaceName(i int) INamespaceNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameContext)
}

func (s *NamespaceNameListContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *NamespaceNameListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserCOMMA)
}

func (s *NamespaceNameListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserCOMMA, i)
}

func (s *NamespaceNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterNamespaceNameList(s)
	}
}

func (s *NamespaceNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitNamespaceNameList(s)
	}
}

func (p *DelphiParser) NamespaceNameList() (localctx INamespaceNameListContext) {
	localctx = NewNamespaceNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, DelphiParserRULE_namespaceNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(492)
		p.NamespaceName()
	}
	p.SetState(497)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DelphiParserCOMMA {
		{
			p.SetState(493)
			p.Match(DelphiParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(494)
			p.NamespaceName()
		}

		p.SetState(499)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(500)
		p.Match(DelphiParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDeclSection() []IDeclSectionContext
	DeclSection(i int) IDeclSectionContext
	BlockBody() IBlockBodyContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) AllDeclSection() []IDeclSectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclSectionContext); ok {
			len++
		}
	}

	tst := make([]IDeclSectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclSectionContext); ok {
			tst[i] = t.(IDeclSectionContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) DeclSection(i int) IDeclSectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclSectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclSectionContext)
}

func (s *BlockContext) BlockBody() IBlockBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockBodyContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *DelphiParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, DelphiParserRULE_block)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(505)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(502)
				p.DeclSection()
			}

		}
		p.SetState(507)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(509)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(508)
			p.BlockBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockBodyContext is an interface to support dynamic dispatch.
type IBlockBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CompoundStatement() ICompoundStatementContext
	AssemblerStatement() IAssemblerStatementContext

	// IsBlockBodyContext differentiates from other interfaces.
	IsBlockBodyContext()
}

type BlockBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockBodyContext() *BlockBodyContext {
	var p = new(BlockBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_blockBody
	return p
}

func InitEmptyBlockBodyContext(p *BlockBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_blockBody
}

func (*BlockBodyContext) IsBlockBodyContext() {}

func NewBlockBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockBodyContext {
	var p = new(BlockBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_blockBody

	return p
}

func (s *BlockBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockBodyContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *BlockBodyContext) AssemblerStatement() IAssemblerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblerStatementContext)
}

func (s *BlockBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterBlockBody(s)
	}
}

func (s *BlockBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitBlockBody(s)
	}
}

func (p *DelphiParser) BlockBody() (localctx IBlockBodyContext) {
	localctx = NewBlockBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, DelphiParserRULE_blockBody)
	p.SetState(513)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserBEGIN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(511)
			p.CompoundStatement()
		}

	case DelphiParserASM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(512)
			p.AssemblerStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclSectionContext is an interface to support dynamic dispatch.
type IDeclSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LabelDeclSection() ILabelDeclSectionContext
	ConstSection() IConstSectionContext
	TypeSection() ITypeSectionContext
	VarSection() IVarSectionContext
	ExportedProcHeading() IExportedProcHeadingContext
	MethodDecl() IMethodDeclContext
	ProcDecl() IProcDeclContext
	ExportsSection() IExportsSectionContext

	// IsDeclSectionContext differentiates from other interfaces.
	IsDeclSectionContext()
}

type DeclSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclSectionContext() *DeclSectionContext {
	var p = new(DeclSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_declSection
	return p
}

func InitEmptyDeclSectionContext(p *DeclSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_declSection
}

func (*DeclSectionContext) IsDeclSectionContext() {}

func NewDeclSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclSectionContext {
	var p = new(DeclSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_declSection

	return p
}

func (s *DeclSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclSectionContext) LabelDeclSection() ILabelDeclSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelDeclSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelDeclSectionContext)
}

func (s *DeclSectionContext) ConstSection() IConstSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstSectionContext)
}

func (s *DeclSectionContext) TypeSection() ITypeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSectionContext)
}

func (s *DeclSectionContext) VarSection() IVarSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarSectionContext)
}

func (s *DeclSectionContext) ExportedProcHeading() IExportedProcHeadingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportedProcHeadingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportedProcHeadingContext)
}

func (s *DeclSectionContext) MethodDecl() IMethodDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDeclContext)
}

func (s *DeclSectionContext) ProcDecl() IProcDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcDeclContext)
}

func (s *DeclSectionContext) ExportsSection() IExportsSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportsSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportsSectionContext)
}

func (s *DeclSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterDeclSection(s)
	}
}

func (s *DeclSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitDeclSection(s)
	}
}

func (p *DelphiParser) DeclSection() (localctx IDeclSectionContext) {
	localctx = NewDeclSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, DelphiParserRULE_declSection)
	p.SetState(523)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(515)
			p.LabelDeclSection()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(516)
			p.ConstSection()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(517)
			p.TypeSection()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(518)
			p.VarSection()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(519)
			p.ExportedProcHeading()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(520)
			p.MethodDecl()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(521)
			p.ProcDecl()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(522)
			p.ExportsSection()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclContext is an interface to support dynamic dispatch.
type IInterfaceDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcDecl() IProcDeclContext
	MethodDecl() IMethodDeclContext
	TypeSection() ITypeSectionContext
	VarSection() IVarSectionContext
	ExportedProcHeading() IExportedProcHeadingContext
	ExportsSection() IExportsSectionContext
	ConstSection() IConstSectionContext

	// IsInterfaceDeclContext differentiates from other interfaces.
	IsInterfaceDeclContext()
}

type InterfaceDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclContext() *InterfaceDeclContext {
	var p = new(InterfaceDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_interfaceDecl
	return p
}

func InitEmptyInterfaceDeclContext(p *InterfaceDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_interfaceDecl
}

func (*InterfaceDeclContext) IsInterfaceDeclContext() {}

func NewInterfaceDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclContext {
	var p = new(InterfaceDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_interfaceDecl

	return p
}

func (s *InterfaceDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclContext) ProcDecl() IProcDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcDeclContext)
}

func (s *InterfaceDeclContext) MethodDecl() IMethodDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDeclContext)
}

func (s *InterfaceDeclContext) TypeSection() ITypeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSectionContext)
}

func (s *InterfaceDeclContext) VarSection() IVarSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarSectionContext)
}

func (s *InterfaceDeclContext) ExportedProcHeading() IExportedProcHeadingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportedProcHeadingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportedProcHeadingContext)
}

func (s *InterfaceDeclContext) ExportsSection() IExportsSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportsSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportsSectionContext)
}

func (s *InterfaceDeclContext) ConstSection() IConstSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstSectionContext)
}

func (s *InterfaceDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterInterfaceDecl(s)
	}
}

func (s *InterfaceDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitInterfaceDecl(s)
	}
}

func (p *DelphiParser) InterfaceDecl() (localctx IInterfaceDeclContext) {
	localctx = NewInterfaceDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, DelphiParserRULE_interfaceDecl)
	p.SetState(532)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(525)
			p.ProcDecl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(526)
			p.MethodDecl()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(527)
			p.TypeSection()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(528)
			p.VarSection()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(529)
			p.ExportedProcHeading()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(530)
			p.ExportsSection()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(531)
			p.ConstSection()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelDeclSectionContext is an interface to support dynamic dispatch.
type ILabelDeclSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LABEL() antlr.TerminalNode
	AllLabel() []ILabelContext
	Label(i int) ILabelContext
	SEMI() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLabelDeclSectionContext differentiates from other interfaces.
	IsLabelDeclSectionContext()
}

type LabelDeclSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelDeclSectionContext() *LabelDeclSectionContext {
	var p = new(LabelDeclSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_labelDeclSection
	return p
}

func InitEmptyLabelDeclSectionContext(p *LabelDeclSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_labelDeclSection
}

func (*LabelDeclSectionContext) IsLabelDeclSectionContext() {}

func NewLabelDeclSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelDeclSectionContext {
	var p = new(LabelDeclSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_labelDeclSection

	return p
}

func (s *LabelDeclSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelDeclSectionContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DelphiParserLABEL, 0)
}

func (s *LabelDeclSectionContext) AllLabel() []ILabelContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelContext); ok {
			len++
		}
	}

	tst := make([]ILabelContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelContext); ok {
			tst[i] = t.(ILabelContext)
			i++
		}
	}

	return tst
}

func (s *LabelDeclSectionContext) Label(i int) ILabelContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *LabelDeclSectionContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *LabelDeclSectionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserCOMMA)
}

func (s *LabelDeclSectionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserCOMMA, i)
}

func (s *LabelDeclSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelDeclSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelDeclSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterLabelDeclSection(s)
	}
}

func (s *LabelDeclSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitLabelDeclSection(s)
	}
}

func (p *DelphiParser) LabelDeclSection() (localctx ILabelDeclSectionContext) {
	localctx = NewLabelDeclSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, DelphiParserRULE_labelDeclSection)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(534)
		p.Match(DelphiParserLABEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(535)
		p.Label()
	}
	p.SetState(540)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DelphiParserCOMMA {
		{
			p.SetState(536)
			p.Match(DelphiParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(537)
			p.Label()
		}

		p.SetState(542)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(543)
		p.Match(DelphiParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstSectionContext is an interface to support dynamic dispatch.
type IConstSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstKey() IConstKeyContext
	AllConstDeclaration() []IConstDeclarationContext
	ConstDeclaration(i int) IConstDeclarationContext

	// IsConstSectionContext differentiates from other interfaces.
	IsConstSectionContext()
}

type ConstSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstSectionContext() *ConstSectionContext {
	var p = new(ConstSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_constSection
	return p
}

func InitEmptyConstSectionContext(p *ConstSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_constSection
}

func (*ConstSectionContext) IsConstSectionContext() {}

func NewConstSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstSectionContext {
	var p = new(ConstSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_constSection

	return p
}

func (s *ConstSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstSectionContext) ConstKey() IConstKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstKeyContext)
}

func (s *ConstSectionContext) AllConstDeclaration() []IConstDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IConstDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstDeclarationContext); ok {
			tst[i] = t.(IConstDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ConstSectionContext) ConstDeclaration(i int) IConstDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstDeclarationContext)
}

func (s *ConstSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterConstSection(s)
	}
}

func (s *ConstSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitConstSection(s)
	}
}

func (p *DelphiParser) ConstSection() (localctx IConstSectionContext) {
	localctx = NewConstSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, DelphiParserRULE_constSection)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(545)
		p.ConstKey()
	}
	p.SetState(549)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(546)
				p.ConstDeclaration()
			}

		}
		p.SetState(551)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstKeyContext is an interface to support dynamic dispatch.
type IConstKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONST() antlr.TerminalNode
	RESOURCESTRING() antlr.TerminalNode

	// IsConstKeyContext differentiates from other interfaces.
	IsConstKeyContext()
}

type ConstKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstKeyContext() *ConstKeyContext {
	var p = new(ConstKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_constKey
	return p
}

func InitEmptyConstKeyContext(p *ConstKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_constKey
}

func (*ConstKeyContext) IsConstKeyContext() {}

func NewConstKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstKeyContext {
	var p = new(ConstKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_constKey

	return p
}

func (s *ConstKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstKeyContext) CONST() antlr.TerminalNode {
	return s.GetToken(DelphiParserCONST, 0)
}

func (s *ConstKeyContext) RESOURCESTRING() antlr.TerminalNode {
	return s.GetToken(DelphiParserRESOURCESTRING, 0)
}

func (s *ConstKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterConstKey(s)
	}
}

func (s *ConstKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitConstKey(s)
	}
}

func (p *DelphiParser) ConstKey() (localctx IConstKeyContext) {
	localctx = NewConstKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, DelphiParserRULE_constKey)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(552)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DelphiParserCONST || _la == DelphiParserRESOURCESTRING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstDeclarationContext is an interface to support dynamic dispatch.
type IConstDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ident() IIdentContext
	EQUAL() antlr.TerminalNode
	ConstExpression() IConstExpressionContext
	SEMI() antlr.TerminalNode
	CustomAttribute() ICustomAttributeContext
	COLON() antlr.TerminalNode
	TypeDecl() ITypeDeclContext
	AllHintingDirective() []IHintingDirectiveContext
	HintingDirective(i int) IHintingDirectiveContext

	// IsConstDeclarationContext differentiates from other interfaces.
	IsConstDeclarationContext()
}

type ConstDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstDeclarationContext() *ConstDeclarationContext {
	var p = new(ConstDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_constDeclaration
	return p
}

func InitEmptyConstDeclarationContext(p *ConstDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_constDeclaration
}

func (*ConstDeclarationContext) IsConstDeclarationContext() {}

func NewConstDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstDeclarationContext {
	var p = new(ConstDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_constDeclaration

	return p
}

func (s *ConstDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstDeclarationContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *ConstDeclarationContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(DelphiParserEQUAL, 0)
}

func (s *ConstDeclarationContext) ConstExpression() IConstExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstExpressionContext)
}

func (s *ConstDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *ConstDeclarationContext) CustomAttribute() ICustomAttributeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomAttributeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomAttributeContext)
}

func (s *ConstDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(DelphiParserCOLON, 0)
}

func (s *ConstDeclarationContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *ConstDeclarationContext) AllHintingDirective() []IHintingDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintingDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IHintingDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintingDirectiveContext); ok {
			tst[i] = t.(IHintingDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *ConstDeclarationContext) HintingDirective(i int) IHintingDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintingDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintingDirectiveContext)
}

func (s *ConstDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterConstDeclaration(s)
	}
}

func (s *ConstDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitConstDeclaration(s)
	}
}

func (p *DelphiParser) ConstDeclaration() (localctx IConstDeclarationContext) {
	localctx = NewConstDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, DelphiParserRULE_constDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(555)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserT__0 {
		{
			p.SetState(554)
			p.CustomAttribute()
		}

	}
	{
		p.SetState(557)
		p.Ident()
	}
	p.SetState(560)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserCOLON {
		{
			p.SetState(558)
			p.Match(DelphiParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(559)
			p.TypeDecl()
		}

	}
	{
		p.SetState(562)
		p.Match(DelphiParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(563)
		p.ConstExpression()
	}
	p.SetState(567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&576461302059253761) != 0 {
		{
			p.SetState(564)
			p.HintingDirective()
		}

		p.SetState(569)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(570)
		p.Match(DelphiParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeSectionContext is an interface to support dynamic dispatch.
type ITypeSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	AllTypeDeclaration() []ITypeDeclarationContext
	TypeDeclaration(i int) ITypeDeclarationContext

	// IsTypeSectionContext differentiates from other interfaces.
	IsTypeSectionContext()
}

type TypeSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSectionContext() *TypeSectionContext {
	var p = new(TypeSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_typeSection
	return p
}

func InitEmptyTypeSectionContext(p *TypeSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_typeSection
}

func (*TypeSectionContext) IsTypeSectionContext() {}

func NewTypeSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSectionContext {
	var p = new(TypeSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_typeSection

	return p
}

func (s *TypeSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSectionContext) TYPE() antlr.TerminalNode {
	return s.GetToken(DelphiParserTYPE, 0)
}

func (s *TypeSectionContext) AllTypeDeclaration() []ITypeDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeDeclarationContext); ok {
			len++
		}
	}

	tst := make([]ITypeDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeDeclarationContext); ok {
			tst[i] = t.(ITypeDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *TypeSectionContext) TypeDeclaration(i int) ITypeDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *TypeSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterTypeSection(s)
	}
}

func (s *TypeSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitTypeSection(s)
	}
}

func (p *DelphiParser) TypeSection() (localctx ITypeSectionContext) {
	localctx = NewTypeSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, DelphiParserRULE_typeSection)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(572)
		p.Match(DelphiParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(573)
		p.TypeDeclaration()
	}
	p.SetState(577)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(574)
				p.TypeDeclaration()
			}

		}
		p.SetState(579)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDeclarationContext is an interface to support dynamic dispatch.
type ITypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GenericTypeIdent() IGenericTypeIdentContext
	EQUAL() antlr.TerminalNode
	TypeDecl() ITypeDeclContext
	SEMI() antlr.TerminalNode
	CustomAttribute() ICustomAttributeContext
	AllHintingDirective() []IHintingDirectiveContext
	HintingDirective(i int) IHintingDirectiveContext

	// IsTypeDeclarationContext differentiates from other interfaces.
	IsTypeDeclarationContext()
}

type TypeDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclarationContext() *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_typeDeclaration
	return p
}

func InitEmptyTypeDeclarationContext(p *TypeDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_typeDeclaration
}

func (*TypeDeclarationContext) IsTypeDeclarationContext() {}

func NewTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_typeDeclaration

	return p
}

func (s *TypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclarationContext) GenericTypeIdent() IGenericTypeIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericTypeIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericTypeIdentContext)
}

func (s *TypeDeclarationContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(DelphiParserEQUAL, 0)
}

func (s *TypeDeclarationContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *TypeDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *TypeDeclarationContext) CustomAttribute() ICustomAttributeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomAttributeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomAttributeContext)
}

func (s *TypeDeclarationContext) AllHintingDirective() []IHintingDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintingDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IHintingDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintingDirectiveContext); ok {
			tst[i] = t.(IHintingDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *TypeDeclarationContext) HintingDirective(i int) IHintingDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintingDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintingDirectiveContext)
}

func (s *TypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterTypeDeclaration(s)
	}
}

func (s *TypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitTypeDeclaration(s)
	}
}

func (p *DelphiParser) TypeDeclaration() (localctx ITypeDeclarationContext) {
	localctx = NewTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, DelphiParserRULE_typeDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(581)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserT__0 {
		{
			p.SetState(580)
			p.CustomAttribute()
		}

	}
	{
		p.SetState(583)
		p.GenericTypeIdent()
	}
	{
		p.SetState(584)
		p.Match(DelphiParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(585)
		p.TypeDecl()
	}
	p.SetState(589)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&576461302059253761) != 0 {
		{
			p.SetState(586)
			p.HintingDirective()
		}

		p.SetState(591)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(592)
		p.Match(DelphiParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarSectionContext is an interface to support dynamic dispatch.
type IVarSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VarKey() IVarKeyContext
	AllVarDeclaration() []IVarDeclarationContext
	VarDeclaration(i int) IVarDeclarationContext

	// IsVarSectionContext differentiates from other interfaces.
	IsVarSectionContext()
}

type VarSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarSectionContext() *VarSectionContext {
	var p = new(VarSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_varSection
	return p
}

func InitEmptyVarSectionContext(p *VarSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_varSection
}

func (*VarSectionContext) IsVarSectionContext() {}

func NewVarSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarSectionContext {
	var p = new(VarSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_varSection

	return p
}

func (s *VarSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *VarSectionContext) VarKey() IVarKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarKeyContext)
}

func (s *VarSectionContext) AllVarDeclaration() []IVarDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVarDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVarDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVarDeclarationContext); ok {
			tst[i] = t.(IVarDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *VarSectionContext) VarDeclaration(i int) IVarDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarDeclarationContext)
}

func (s *VarSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterVarSection(s)
	}
}

func (s *VarSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitVarSection(s)
	}
}

func (p *DelphiParser) VarSection() (localctx IVarSectionContext) {
	localctx = NewVarSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, DelphiParserRULE_varSection)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(594)
		p.VarKey()
	}
	{
		p.SetState(595)
		p.VarDeclaration()
	}
	p.SetState(599)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(596)
				p.VarDeclaration()
			}

		}
		p.SetState(601)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarKeyContext is an interface to support dynamic dispatch.
type IVarKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VAR() antlr.TerminalNode
	THREADVAR() antlr.TerminalNode

	// IsVarKeyContext differentiates from other interfaces.
	IsVarKeyContext()
}

type VarKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarKeyContext() *VarKeyContext {
	var p = new(VarKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_varKey
	return p
}

func InitEmptyVarKeyContext(p *VarKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_varKey
}

func (*VarKeyContext) IsVarKeyContext() {}

func NewVarKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarKeyContext {
	var p = new(VarKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_varKey

	return p
}

func (s *VarKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *VarKeyContext) VAR() antlr.TerminalNode {
	return s.GetToken(DelphiParserVAR, 0)
}

func (s *VarKeyContext) THREADVAR() antlr.TerminalNode {
	return s.GetToken(DelphiParserTHREADVAR, 0)
}

func (s *VarKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterVarKey(s)
	}
}

func (s *VarKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitVarKey(s)
	}
}

func (p *DelphiParser) VarKey() (localctx IVarKeyContext) {
	localctx = NewVarKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, DelphiParserRULE_varKey)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(602)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DelphiParserTHREADVAR || _la == DelphiParserVAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarDeclarationContext is an interface to support dynamic dispatch.
type IVarDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentListFlat() IIdentListFlatContext
	COLON() antlr.TerminalNode
	TypeDecl() ITypeDeclContext
	SEMI() antlr.TerminalNode
	CustomAttribute() ICustomAttributeContext
	VarValueSpec() IVarValueSpecContext
	AllHintingDirective() []IHintingDirectiveContext
	HintingDirective(i int) IHintingDirectiveContext

	// IsVarDeclarationContext differentiates from other interfaces.
	IsVarDeclarationContext()
}

type VarDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarDeclarationContext() *VarDeclarationContext {
	var p = new(VarDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_varDeclaration
	return p
}

func InitEmptyVarDeclarationContext(p *VarDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_varDeclaration
}

func (*VarDeclarationContext) IsVarDeclarationContext() {}

func NewVarDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarDeclarationContext {
	var p = new(VarDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_varDeclaration

	return p
}

func (s *VarDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VarDeclarationContext) IdentListFlat() IIdentListFlatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentListFlatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentListFlatContext)
}

func (s *VarDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(DelphiParserCOLON, 0)
}

func (s *VarDeclarationContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *VarDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *VarDeclarationContext) CustomAttribute() ICustomAttributeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomAttributeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomAttributeContext)
}

func (s *VarDeclarationContext) VarValueSpec() IVarValueSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarValueSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarValueSpecContext)
}

func (s *VarDeclarationContext) AllHintingDirective() []IHintingDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintingDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IHintingDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintingDirectiveContext); ok {
			tst[i] = t.(IHintingDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *VarDeclarationContext) HintingDirective(i int) IHintingDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintingDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintingDirectiveContext)
}

func (s *VarDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterVarDeclaration(s)
	}
}

func (s *VarDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitVarDeclaration(s)
	}
}

func (p *DelphiParser) VarDeclaration() (localctx IVarDeclarationContext) {
	localctx = NewVarDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, DelphiParserRULE_varDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(605)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserT__0 {
		{
			p.SetState(604)
			p.CustomAttribute()
		}

	}
	{
		p.SetState(607)
		p.IdentListFlat()
	}
	{
		p.SetState(608)
		p.Match(DelphiParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(609)
		p.TypeDecl()
	}
	p.SetState(611)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserABSOLUTE || _la == DelphiParserEQUAL {
		{
			p.SetState(610)
			p.VarValueSpec()
		}

	}
	p.SetState(616)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&576461302059253761) != 0 {
		{
			p.SetState(613)
			p.HintingDirective()
		}

		p.SetState(618)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(619)
		p.Match(DelphiParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarValueSpecContext is an interface to support dynamic dispatch.
type IVarValueSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ABSOLUTE() antlr.TerminalNode
	Ident() IIdentContext
	ConstExpression() IConstExpressionContext
	EQUAL() antlr.TerminalNode

	// IsVarValueSpecContext differentiates from other interfaces.
	IsVarValueSpecContext()
}

type VarValueSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarValueSpecContext() *VarValueSpecContext {
	var p = new(VarValueSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_varValueSpec
	return p
}

func InitEmptyVarValueSpecContext(p *VarValueSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_varValueSpec
}

func (*VarValueSpecContext) IsVarValueSpecContext() {}

func NewVarValueSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarValueSpecContext {
	var p = new(VarValueSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_varValueSpec

	return p
}

func (s *VarValueSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *VarValueSpecContext) ABSOLUTE() antlr.TerminalNode {
	return s.GetToken(DelphiParserABSOLUTE, 0)
}

func (s *VarValueSpecContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *VarValueSpecContext) ConstExpression() IConstExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstExpressionContext)
}

func (s *VarValueSpecContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(DelphiParserEQUAL, 0)
}

func (s *VarValueSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarValueSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarValueSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterVarValueSpec(s)
	}
}

func (s *VarValueSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitVarValueSpec(s)
	}
}

func (p *DelphiParser) VarValueSpec() (localctx IVarValueSpecContext) {
	localctx = NewVarValueSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, DelphiParserRULE_varValueSpec)
	p.SetState(627)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(621)
			p.Match(DelphiParserABSOLUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(622)
			p.Ident()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(623)
			p.Match(DelphiParserABSOLUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(624)
			p.ConstExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(625)
			p.Match(DelphiParserEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(626)
			p.ConstExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportsSectionContext is an interface to support dynamic dispatch.
type IExportsSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPORTS() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	AllExportItem() []IExportItemContext
	ExportItem(i int) IExportItemContext
	SEMI() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExportsSectionContext differentiates from other interfaces.
	IsExportsSectionContext()
}

type ExportsSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportsSectionContext() *ExportsSectionContext {
	var p = new(ExportsSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_exportsSection
	return p
}

func InitEmptyExportsSectionContext(p *ExportsSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_exportsSection
}

func (*ExportsSectionContext) IsExportsSectionContext() {}

func NewExportsSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportsSectionContext {
	var p = new(ExportsSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_exportsSection

	return p
}

func (s *ExportsSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportsSectionContext) EXPORTS() antlr.TerminalNode {
	return s.GetToken(DelphiParserEXPORTS, 0)
}

func (s *ExportsSectionContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *ExportsSectionContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *ExportsSectionContext) AllExportItem() []IExportItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExportItemContext); ok {
			len++
		}
	}

	tst := make([]IExportItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExportItemContext); ok {
			tst[i] = t.(IExportItemContext)
			i++
		}
	}

	return tst
}

func (s *ExportsSectionContext) ExportItem(i int) IExportItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportItemContext)
}

func (s *ExportsSectionContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *ExportsSectionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserCOMMA)
}

func (s *ExportsSectionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserCOMMA, i)
}

func (s *ExportsSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportsSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportsSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterExportsSection(s)
	}
}

func (s *ExportsSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitExportsSection(s)
	}
}

func (p *DelphiParser) ExportsSection() (localctx IExportsSectionContext) {
	localctx = NewExportsSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, DelphiParserRULE_exportsSection)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(629)
		p.Match(DelphiParserEXPORTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(630)
		p.Ident()
	}
	{
		p.SetState(631)
		p.ExportItem()
	}
	p.SetState(638)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DelphiParserCOMMA {
		{
			p.SetState(632)
			p.Match(DelphiParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(633)
			p.Ident()
		}
		{
			p.SetState(634)
			p.ExportItem()
		}

		p.SetState(640)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(641)
		p.Match(DelphiParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportItemContext is an interface to support dynamic dispatch.
type IExportItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	NAME() antlr.TerminalNode
	RESIDENT() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsExportItemContext differentiates from other interfaces.
	IsExportItemContext()
}

type ExportItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportItemContext() *ExportItemContext {
	var p = new(ExportItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_exportItem
	return p
}

func InitEmptyExportItemContext(p *ExportItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_exportItem
}

func (*ExportItemContext) IsExportItemContext() {}

func NewExportItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportItemContext {
	var p = new(ExportItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_exportItem

	return p
}

func (s *ExportItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportItemContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserLPAREN, 0)
}

func (s *ExportItemContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserRPAREN, 0)
}

func (s *ExportItemContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DelphiParserINDEX, 0)
}

func (s *ExportItemContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExportItemContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExportItemContext) NAME() antlr.TerminalNode {
	return s.GetToken(DelphiParserNAME, 0)
}

func (s *ExportItemContext) RESIDENT() antlr.TerminalNode {
	return s.GetToken(DelphiParserRESIDENT, 0)
}

func (s *ExportItemContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ExportItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterExportItem(s)
	}
}

func (s *ExportItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitExportItem(s)
	}
}

func (p *DelphiParser) ExportItem() (localctx IExportItemContext) {
	localctx = NewExportItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, DelphiParserRULE_exportItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserLPAREN {
		{
			p.SetState(643)
			p.Match(DelphiParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(645)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&90090271943462992) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2883288972791916811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&18014400656965633) != 0) {
			{
				p.SetState(644)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(647)
			p.Match(DelphiParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(652)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserINDEX {
		{
			p.SetState(650)
			p.Match(DelphiParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(651)
			p.Expression()
		}

	}
	p.SetState(656)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserNAME {
		{
			p.SetState(654)
			p.Match(DelphiParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(655)
			p.Expression()
		}

	}
	p.SetState(659)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserRESIDENT {
		{
			p.SetState(658)
			p.Match(DelphiParserRESIDENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDeclContext is an interface to support dynamic dispatch.
type ITypeDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StrucType() IStrucTypeContext
	PointerType() IPointerTypeContext
	StringType() IStringTypeContext
	ProcedureType() IProcedureTypeContext
	VariantType() IVariantTypeContext
	TypeId() ITypeIdContext
	TYPE() antlr.TerminalNode
	GenericPostfix() IGenericPostfixContext
	SimpleType() ISimpleTypeContext

	// IsTypeDeclContext differentiates from other interfaces.
	IsTypeDeclContext()
}

type TypeDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclContext() *TypeDeclContext {
	var p = new(TypeDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_typeDecl
	return p
}

func InitEmptyTypeDeclContext(p *TypeDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_typeDecl
}

func (*TypeDeclContext) IsTypeDeclContext() {}

func NewTypeDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclContext {
	var p = new(TypeDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_typeDecl

	return p
}

func (s *TypeDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclContext) StrucType() IStrucTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrucTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrucTypeContext)
}

func (s *TypeDeclContext) PointerType() IPointerTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerTypeContext)
}

func (s *TypeDeclContext) StringType() IStringTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringTypeContext)
}

func (s *TypeDeclContext) ProcedureType() IProcedureTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureTypeContext)
}

func (s *TypeDeclContext) VariantType() IVariantTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariantTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariantTypeContext)
}

func (s *TypeDeclContext) TypeId() ITypeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdContext)
}

func (s *TypeDeclContext) TYPE() antlr.TerminalNode {
	return s.GetToken(DelphiParserTYPE, 0)
}

func (s *TypeDeclContext) GenericPostfix() IGenericPostfixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericPostfixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericPostfixContext)
}

func (s *TypeDeclContext) SimpleType() ISimpleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeContext)
}

func (s *TypeDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterTypeDecl(s)
	}
}

func (s *TypeDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitTypeDecl(s)
	}
}

func (p *DelphiParser) TypeDecl() (localctx ITypeDeclContext) {
	localctx = NewTypeDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, DelphiParserRULE_typeDecl)
	var _la int

	p.SetState(674)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(661)
			p.StrucType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(662)
			p.PointerType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(663)
			p.StringType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(664)
			p.ProcedureType()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(665)
			p.VariantType()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(667)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserTYPE {
			{
				p.SetState(666)
				p.Match(DelphiParserTYPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(669)
			p.TypeId()
		}
		p.SetState(671)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(670)
				p.GenericPostfix()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(673)
			p.SimpleType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStrucTypeContext is an interface to support dynamic dispatch.
type IStrucTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StrucTypePart() IStrucTypePartContext
	PACKED() antlr.TerminalNode

	// IsStrucTypeContext differentiates from other interfaces.
	IsStrucTypeContext()
}

type StrucTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrucTypeContext() *StrucTypeContext {
	var p = new(StrucTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_strucType
	return p
}

func InitEmptyStrucTypeContext(p *StrucTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_strucType
}

func (*StrucTypeContext) IsStrucTypeContext() {}

func NewStrucTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StrucTypeContext {
	var p = new(StrucTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_strucType

	return p
}

func (s *StrucTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StrucTypeContext) StrucTypePart() IStrucTypePartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrucTypePartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrucTypePartContext)
}

func (s *StrucTypeContext) PACKED() antlr.TerminalNode {
	return s.GetToken(DelphiParserPACKED, 0)
}

func (s *StrucTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StrucTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StrucTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterStrucType(s)
	}
}

func (s *StrucTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitStrucType(s)
	}
}

func (p *DelphiParser) StrucType() (localctx IStrucTypeContext) {
	localctx = NewStrucTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, DelphiParserRULE_strucType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserPACKED {
		{
			p.SetState(676)
			p.Match(DelphiParserPACKED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(679)
		p.StrucTypePart()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStrucTypePartContext is an interface to support dynamic dispatch.
type IStrucTypePartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ArrayType() IArrayTypeContext
	SetType() ISetTypeContext
	FileType() IFileTypeContext
	ClassDecl() IClassDeclContext

	// IsStrucTypePartContext differentiates from other interfaces.
	IsStrucTypePartContext()
}

type StrucTypePartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrucTypePartContext() *StrucTypePartContext {
	var p = new(StrucTypePartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_strucTypePart
	return p
}

func InitEmptyStrucTypePartContext(p *StrucTypePartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_strucTypePart
}

func (*StrucTypePartContext) IsStrucTypePartContext() {}

func NewStrucTypePartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StrucTypePartContext {
	var p = new(StrucTypePartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_strucTypePart

	return p
}

func (s *StrucTypePartContext) GetParser() antlr.Parser { return s.parser }

func (s *StrucTypePartContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *StrucTypePartContext) SetType() ISetTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetTypeContext)
}

func (s *StrucTypePartContext) FileType() IFileTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileTypeContext)
}

func (s *StrucTypePartContext) ClassDecl() IClassDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclContext)
}

func (s *StrucTypePartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StrucTypePartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StrucTypePartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterStrucTypePart(s)
	}
}

func (s *StrucTypePartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitStrucTypePart(s)
	}
}

func (p *DelphiParser) StrucTypePart() (localctx IStrucTypePartContext) {
	localctx = NewStrucTypePartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, DelphiParserRULE_strucTypePart)
	p.SetState(685)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserARRAY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(681)
			p.ArrayType()
		}

	case DelphiParserSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(682)
			p.SetType()
		}

	case DelphiParserFILE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(683)
			p.FileType()
		}

	case DelphiParserCLASS, DelphiParserDISPINTERFACE, DelphiParserINTERFACE, DelphiParserOBJECT, DelphiParserRECORD:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(684)
			p.ClassDecl()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY() antlr.TerminalNode
	OF() antlr.TerminalNode
	ArraySubType() IArraySubTypeContext
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	AllArrayIndex() []IArrayIndexContext
	ArrayIndex(i int) IArrayIndexContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(DelphiParserARRAY, 0)
}

func (s *ArrayTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(DelphiParserOF, 0)
}

func (s *ArrayTypeContext) ArraySubType() IArraySubTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArraySubTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArraySubTypeContext)
}

func (s *ArrayTypeContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(DelphiParserLBRACK, 0)
}

func (s *ArrayTypeContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(DelphiParserRBRACK, 0)
}

func (s *ArrayTypeContext) AllArrayIndex() []IArrayIndexContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayIndexContext); ok {
			len++
		}
	}

	tst := make([]IArrayIndexContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayIndexContext); ok {
			tst[i] = t.(IArrayIndexContext)
			i++
		}
	}

	return tst
}

func (s *ArrayTypeContext) ArrayIndex(i int) IArrayIndexContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayIndexContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayIndexContext)
}

func (s *ArrayTypeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserCOMMA)
}

func (s *ArrayTypeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserCOMMA, i)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (p *DelphiParser) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, DelphiParserRULE_arrayType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(687)
		p.Match(DelphiParserARRAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(702)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserLBRACK {
		{
			p.SetState(688)
			p.Match(DelphiParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(690)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2576640216473309552) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2306854608771758511) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&4017210874563387901) != 0) {
			{
				p.SetState(689)
				p.ArrayIndex()
			}

		}
		p.SetState(698)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DelphiParserCOMMA {
			{
				p.SetState(692)
				p.Match(DelphiParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(694)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2576640216473309552) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2306854608771758511) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&4017210874563387901) != 0) {
				{
					p.SetState(693)
					p.ArrayIndex()
				}

			}

			p.SetState(700)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(701)
			p.Match(DelphiParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(704)
		p.Match(DelphiParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(705)
		p.ArraySubType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayIndexContext is an interface to support dynamic dispatch.
type IArrayIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeId() ITypeIdContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	DOTDOT() antlr.TerminalNode

	// IsArrayIndexContext differentiates from other interfaces.
	IsArrayIndexContext()
}

type ArrayIndexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayIndexContext() *ArrayIndexContext {
	var p = new(ArrayIndexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_arrayIndex
	return p
}

func InitEmptyArrayIndexContext(p *ArrayIndexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_arrayIndex
}

func (*ArrayIndexContext) IsArrayIndexContext() {}

func NewArrayIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayIndexContext {
	var p = new(ArrayIndexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_arrayIndex

	return p
}

func (s *ArrayIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayIndexContext) TypeId() ITypeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdContext)
}

func (s *ArrayIndexContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArrayIndexContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayIndexContext) DOTDOT() antlr.TerminalNode {
	return s.GetToken(DelphiParserDOTDOT, 0)
}

func (s *ArrayIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterArrayIndex(s)
	}
}

func (s *ArrayIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitArrayIndex(s)
	}
}

func (p *DelphiParser) ArrayIndex() (localctx IArrayIndexContext) {
	localctx = NewArrayIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, DelphiParserRULE_arrayIndex)
	p.SetState(712)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(707)
			p.TypeId()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(708)
			p.Expression()
		}
		{
			p.SetState(709)
			p.Match(DelphiParserDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(710)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArraySubTypeContext is an interface to support dynamic dispatch.
type IArraySubTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONST() antlr.TerminalNode
	TypeDecl() ITypeDeclContext

	// IsArraySubTypeContext differentiates from other interfaces.
	IsArraySubTypeContext()
}

type ArraySubTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArraySubTypeContext() *ArraySubTypeContext {
	var p = new(ArraySubTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_arraySubType
	return p
}

func InitEmptyArraySubTypeContext(p *ArraySubTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_arraySubType
}

func (*ArraySubTypeContext) IsArraySubTypeContext() {}

func NewArraySubTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArraySubTypeContext {
	var p = new(ArraySubTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_arraySubType

	return p
}

func (s *ArraySubTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArraySubTypeContext) CONST() antlr.TerminalNode {
	return s.GetToken(DelphiParserCONST, 0)
}

func (s *ArraySubTypeContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *ArraySubTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArraySubTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArraySubTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterArraySubType(s)
	}
}

func (s *ArraySubTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitArraySubType(s)
	}
}

func (p *DelphiParser) ArraySubType() (localctx IArraySubTypeContext) {
	localctx = NewArraySubTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, DelphiParserRULE_arraySubType)
	p.SetState(716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(714)
			p.Match(DelphiParserCONST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(715)
			p.TypeDecl()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetTypeContext is an interface to support dynamic dispatch.
type ISetTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	OF() antlr.TerminalNode
	TypeDecl() ITypeDeclContext

	// IsSetTypeContext differentiates from other interfaces.
	IsSetTypeContext()
}

type SetTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetTypeContext() *SetTypeContext {
	var p = new(SetTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_setType
	return p
}

func InitEmptySetTypeContext(p *SetTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_setType
}

func (*SetTypeContext) IsSetTypeContext() {}

func NewSetTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetTypeContext {
	var p = new(SetTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_setType

	return p
}

func (s *SetTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SetTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(DelphiParserSET, 0)
}

func (s *SetTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(DelphiParserOF, 0)
}

func (s *SetTypeContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *SetTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterSetType(s)
	}
}

func (s *SetTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitSetType(s)
	}
}

func (p *DelphiParser) SetType() (localctx ISetTypeContext) {
	localctx = NewSetTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, DelphiParserRULE_setType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(718)
		p.Match(DelphiParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(719)
		p.Match(DelphiParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(720)
		p.TypeDecl()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFileTypeContext is an interface to support dynamic dispatch.
type IFileTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILE() antlr.TerminalNode
	OF() antlr.TerminalNode
	TypeDecl() ITypeDeclContext

	// IsFileTypeContext differentiates from other interfaces.
	IsFileTypeContext()
}

type FileTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileTypeContext() *FileTypeContext {
	var p = new(FileTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_fileType
	return p
}

func InitEmptyFileTypeContext(p *FileTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_fileType
}

func (*FileTypeContext) IsFileTypeContext() {}

func NewFileTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileTypeContext {
	var p = new(FileTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_fileType

	return p
}

func (s *FileTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FileTypeContext) FILE() antlr.TerminalNode {
	return s.GetToken(DelphiParserFILE, 0)
}

func (s *FileTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(DelphiParserOF, 0)
}

func (s *FileTypeContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *FileTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterFileType(s)
	}
}

func (s *FileTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitFileType(s)
	}
}

func (p *DelphiParser) FileType() (localctx IFileTypeContext) {
	localctx = NewFileTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, DelphiParserRULE_fileType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(722)
		p.Match(DelphiParserFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(725)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(723)
			p.Match(DelphiParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(724)
			p.TypeDecl()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPointerTypeContext is an interface to support dynamic dispatch.
type IPointerTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	POINTER2() antlr.TerminalNode
	TypeDecl() ITypeDeclContext
	POINTER() antlr.TerminalNode

	// IsPointerTypeContext differentiates from other interfaces.
	IsPointerTypeContext()
}

type PointerTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPointerTypeContext() *PointerTypeContext {
	var p = new(PointerTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_pointerType
	return p
}

func InitEmptyPointerTypeContext(p *PointerTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_pointerType
}

func (*PointerTypeContext) IsPointerTypeContext() {}

func NewPointerTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PointerTypeContext {
	var p = new(PointerTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_pointerType

	return p
}

func (s *PointerTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PointerTypeContext) POINTER2() antlr.TerminalNode {
	return s.GetToken(DelphiParserPOINTER2, 0)
}

func (s *PointerTypeContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *PointerTypeContext) POINTER() antlr.TerminalNode {
	return s.GetToken(DelphiParserPOINTER, 0)
}

func (s *PointerTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointerTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PointerTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterPointerType(s)
	}
}

func (s *PointerTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitPointerType(s)
	}
}

func (p *DelphiParser) PointerType() (localctx IPointerTypeContext) {
	localctx = NewPointerTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, DelphiParserRULE_pointerType)
	p.SetState(730)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserPOINTER2:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(727)
			p.Match(DelphiParserPOINTER2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(728)
			p.TypeDecl()
		}

	case DelphiParserPOINTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(729)
			p.Match(DelphiParserPOINTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringTypeContext is an interface to support dynamic dispatch.
type IStringTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	Expression() IExpressionContext
	RBRACK() antlr.TerminalNode
	ANSISTRING() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	CodePageNumber() ICodePageNumberContext

	// IsStringTypeContext differentiates from other interfaces.
	IsStringTypeContext()
}

type StringTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringTypeContext() *StringTypeContext {
	var p = new(StringTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_stringType
	return p
}

func InitEmptyStringTypeContext(p *StringTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_stringType
}

func (*StringTypeContext) IsStringTypeContext() {}

func NewStringTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringTypeContext {
	var p = new(StringTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_stringType

	return p
}

func (s *StringTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StringTypeContext) STRING() antlr.TerminalNode {
	return s.GetToken(DelphiParserSTRING, 0)
}

func (s *StringTypeContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(DelphiParserLBRACK, 0)
}

func (s *StringTypeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StringTypeContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(DelphiParserRBRACK, 0)
}

func (s *StringTypeContext) ANSISTRING() antlr.TerminalNode {
	return s.GetToken(DelphiParserANSISTRING, 0)
}

func (s *StringTypeContext) TYPE() antlr.TerminalNode {
	return s.GetToken(DelphiParserTYPE, 0)
}

func (s *StringTypeContext) CodePageNumber() ICodePageNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodePageNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodePageNumberContext)
}

func (s *StringTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterStringType(s)
	}
}

func (s *StringTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitStringType(s)
	}
}

func (p *DelphiParser) StringType() (localctx IStringTypeContext) {
	localctx = NewStringTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, DelphiParserRULE_stringType)
	var _la int

	p.SetState(746)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserSTRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(732)
			p.Match(DelphiParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(737)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(733)
				p.Match(DelphiParserLBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(734)
				p.Expression()
			}
			{
				p.SetState(735)
				p.Match(DelphiParserRBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case DelphiParserANSISTRING, DelphiParserTYPE:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(740)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserTYPE {
			{
				p.SetState(739)
				p.Match(DelphiParserTYPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(742)
			p.Match(DelphiParserANSISTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(744)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(743)
				p.CodePageNumber()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICodePageNumberContext is an interface to support dynamic dispatch.
type ICodePageNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	IntNum() IIntNumContext
	RPAREN() antlr.TerminalNode

	// IsCodePageNumberContext differentiates from other interfaces.
	IsCodePageNumberContext()
}

type CodePageNumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodePageNumberContext() *CodePageNumberContext {
	var p = new(CodePageNumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_codePageNumber
	return p
}

func InitEmptyCodePageNumberContext(p *CodePageNumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_codePageNumber
}

func (*CodePageNumberContext) IsCodePageNumberContext() {}

func NewCodePageNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodePageNumberContext {
	var p = new(CodePageNumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_codePageNumber

	return p
}

func (s *CodePageNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *CodePageNumberContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserLPAREN, 0)
}

func (s *CodePageNumberContext) IntNum() IIntNumContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntNumContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntNumContext)
}

func (s *CodePageNumberContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserRPAREN, 0)
}

func (s *CodePageNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodePageNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodePageNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterCodePageNumber(s)
	}
}

func (s *CodePageNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitCodePageNumber(s)
	}
}

func (p *DelphiParser) CodePageNumber() (localctx ICodePageNumberContext) {
	localctx = NewCodePageNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, DelphiParserRULE_codePageNumber)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(748)
		p.Match(DelphiParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(749)
		p.IntNum()
	}
	{
		p.SetState(750)
		p.Match(DelphiParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureTypeContext is an interface to support dynamic dispatch.
type IProcedureTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MethodType() IMethodTypeContext
	SimpleProcedureType() ISimpleProcedureTypeContext
	ProcedureReference() IProcedureReferenceContext

	// IsProcedureTypeContext differentiates from other interfaces.
	IsProcedureTypeContext()
}

type ProcedureTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureTypeContext() *ProcedureTypeContext {
	var p = new(ProcedureTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_procedureType
	return p
}

func InitEmptyProcedureTypeContext(p *ProcedureTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_procedureType
}

func (*ProcedureTypeContext) IsProcedureTypeContext() {}

func NewProcedureTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureTypeContext {
	var p = new(ProcedureTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_procedureType

	return p
}

func (s *ProcedureTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureTypeContext) MethodType() IMethodTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodTypeContext)
}

func (s *ProcedureTypeContext) SimpleProcedureType() ISimpleProcedureTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleProcedureTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleProcedureTypeContext)
}

func (s *ProcedureTypeContext) ProcedureReference() IProcedureReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureReferenceContext)
}

func (s *ProcedureTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterProcedureType(s)
	}
}

func (s *ProcedureTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitProcedureType(s)
	}
}

func (p *DelphiParser) ProcedureType() (localctx IProcedureTypeContext) {
	localctx = NewProcedureTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, DelphiParserRULE_procedureType)
	p.SetState(755)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(752)
			p.MethodType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(753)
			p.SimpleProcedureType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(754)
			p.ProcedureReference()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodTypeContext is an interface to support dynamic dispatch.
type IMethodTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcedureTypeHeading() IProcedureTypeHeadingContext
	OF() antlr.TerminalNode
	OBJECT() antlr.TerminalNode

	// IsMethodTypeContext differentiates from other interfaces.
	IsMethodTypeContext()
}

type MethodTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodTypeContext() *MethodTypeContext {
	var p = new(MethodTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_methodType
	return p
}

func InitEmptyMethodTypeContext(p *MethodTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_methodType
}

func (*MethodTypeContext) IsMethodTypeContext() {}

func NewMethodTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodTypeContext {
	var p = new(MethodTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_methodType

	return p
}

func (s *MethodTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodTypeContext) ProcedureTypeHeading() IProcedureTypeHeadingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureTypeHeadingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureTypeHeadingContext)
}

func (s *MethodTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(DelphiParserOF, 0)
}

func (s *MethodTypeContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(DelphiParserOBJECT, 0)
}

func (s *MethodTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterMethodType(s)
	}
}

func (s *MethodTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitMethodType(s)
	}
}

func (p *DelphiParser) MethodType() (localctx IMethodTypeContext) {
	localctx = NewMethodTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, DelphiParserRULE_methodType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(757)
		p.ProcedureTypeHeading()
	}
	{
		p.SetState(758)
		p.Match(DelphiParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(759)
		p.Match(DelphiParserOBJECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleProcedureTypeContext is an interface to support dynamic dispatch.
type ISimpleProcedureTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcedureTypeHeading() IProcedureTypeHeadingContext
	CallConventionNoSemi() ICallConventionNoSemiContext
	SEMI() antlr.TerminalNode

	// IsSimpleProcedureTypeContext differentiates from other interfaces.
	IsSimpleProcedureTypeContext()
}

type SimpleProcedureTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleProcedureTypeContext() *SimpleProcedureTypeContext {
	var p = new(SimpleProcedureTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_simpleProcedureType
	return p
}

func InitEmptySimpleProcedureTypeContext(p *SimpleProcedureTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_simpleProcedureType
}

func (*SimpleProcedureTypeContext) IsSimpleProcedureTypeContext() {}

func NewSimpleProcedureTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleProcedureTypeContext {
	var p = new(SimpleProcedureTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_simpleProcedureType

	return p
}

func (s *SimpleProcedureTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleProcedureTypeContext) ProcedureTypeHeading() IProcedureTypeHeadingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureTypeHeadingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureTypeHeadingContext)
}

func (s *SimpleProcedureTypeContext) CallConventionNoSemi() ICallConventionNoSemiContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallConventionNoSemiContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallConventionNoSemiContext)
}

func (s *SimpleProcedureTypeContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *SimpleProcedureTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleProcedureTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleProcedureTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterSimpleProcedureType(s)
	}
}

func (s *SimpleProcedureTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitSimpleProcedureType(s)
	}
}

func (p *DelphiParser) SimpleProcedureType() (localctx ISimpleProcedureTypeContext) {
	localctx = NewSimpleProcedureTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, DelphiParserRULE_simpleProcedureType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(761)
		p.ProcedureTypeHeading()
	}
	p.SetState(766)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) == 1 {
		p.SetState(763)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserSEMI {
			{
				p.SetState(762)
				p.Match(DelphiParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(765)
			p.CallConventionNoSemi()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureReferenceContext is an interface to support dynamic dispatch.
type IProcedureReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REFERENCE() antlr.TerminalNode
	TO() antlr.TerminalNode
	ProcedureTypeHeading() IProcedureTypeHeadingContext

	// IsProcedureReferenceContext differentiates from other interfaces.
	IsProcedureReferenceContext()
}

type ProcedureReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureReferenceContext() *ProcedureReferenceContext {
	var p = new(ProcedureReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_procedureReference
	return p
}

func InitEmptyProcedureReferenceContext(p *ProcedureReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_procedureReference
}

func (*ProcedureReferenceContext) IsProcedureReferenceContext() {}

func NewProcedureReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureReferenceContext {
	var p = new(ProcedureReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_procedureReference

	return p
}

func (s *ProcedureReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureReferenceContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(DelphiParserREFERENCE, 0)
}

func (s *ProcedureReferenceContext) TO() antlr.TerminalNode {
	return s.GetToken(DelphiParserTO, 0)
}

func (s *ProcedureReferenceContext) ProcedureTypeHeading() IProcedureTypeHeadingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureTypeHeadingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureTypeHeadingContext)
}

func (s *ProcedureReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterProcedureReference(s)
	}
}

func (s *ProcedureReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitProcedureReference(s)
	}
}

func (p *DelphiParser) ProcedureReference() (localctx IProcedureReferenceContext) {
	localctx = NewProcedureReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, DelphiParserRULE_procedureReference)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(768)
		p.Match(DelphiParserREFERENCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(769)
		p.Match(DelphiParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(770)
		p.ProcedureTypeHeading()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureTypeHeadingContext is an interface to support dynamic dispatch.
type IProcedureTypeHeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNCTION() antlr.TerminalNode
	COLON() antlr.TerminalNode
	TypeDecl() ITypeDeclContext
	FormalParameterSection() IFormalParameterSectionContext
	CustomAttribute() ICustomAttributeContext
	PROCEDURE() antlr.TerminalNode

	// IsProcedureTypeHeadingContext differentiates from other interfaces.
	IsProcedureTypeHeadingContext()
}

type ProcedureTypeHeadingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureTypeHeadingContext() *ProcedureTypeHeadingContext {
	var p = new(ProcedureTypeHeadingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_procedureTypeHeading
	return p
}

func InitEmptyProcedureTypeHeadingContext(p *ProcedureTypeHeadingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_procedureTypeHeading
}

func (*ProcedureTypeHeadingContext) IsProcedureTypeHeadingContext() {}

func NewProcedureTypeHeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureTypeHeadingContext {
	var p = new(ProcedureTypeHeadingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_procedureTypeHeading

	return p
}

func (s *ProcedureTypeHeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureTypeHeadingContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DelphiParserFUNCTION, 0)
}

func (s *ProcedureTypeHeadingContext) COLON() antlr.TerminalNode {
	return s.GetToken(DelphiParserCOLON, 0)
}

func (s *ProcedureTypeHeadingContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *ProcedureTypeHeadingContext) FormalParameterSection() IFormalParameterSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterSectionContext)
}

func (s *ProcedureTypeHeadingContext) CustomAttribute() ICustomAttributeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomAttributeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomAttributeContext)
}

func (s *ProcedureTypeHeadingContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DelphiParserPROCEDURE, 0)
}

func (s *ProcedureTypeHeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureTypeHeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureTypeHeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterProcedureTypeHeading(s)
	}
}

func (s *ProcedureTypeHeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitProcedureTypeHeading(s)
	}
}

func (p *DelphiParser) ProcedureTypeHeading() (localctx IProcedureTypeHeadingContext) {
	localctx = NewProcedureTypeHeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, DelphiParserRULE_procedureTypeHeading)
	var _la int

	p.SetState(785)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserFUNCTION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(772)
			p.Match(DelphiParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(774)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserLPAREN {
			{
				p.SetState(773)
				p.FormalParameterSection()
			}

		}
		{
			p.SetState(776)
			p.Match(DelphiParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(778)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(777)
				p.CustomAttribute()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(780)
			p.TypeDecl()
		}

	case DelphiParserPROCEDURE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(781)
			p.Match(DelphiParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(783)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(782)
				p.FormalParameterSection()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariantTypeContext is an interface to support dynamic dispatch.
type IVariantTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VARIANT() antlr.TerminalNode

	// IsVariantTypeContext differentiates from other interfaces.
	IsVariantTypeContext()
}

type VariantTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariantTypeContext() *VariantTypeContext {
	var p = new(VariantTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_variantType
	return p
}

func InitEmptyVariantTypeContext(p *VariantTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_variantType
}

func (*VariantTypeContext) IsVariantTypeContext() {}

func NewVariantTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariantTypeContext {
	var p = new(VariantTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_variantType

	return p
}

func (s *VariantTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *VariantTypeContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(DelphiParserVARIANT, 0)
}

func (s *VariantTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariantTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariantTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterVariantType(s)
	}
}

func (s *VariantTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitVariantType(s)
	}
}

func (p *DelphiParser) VariantType() (localctx IVariantTypeContext) {
	localctx = NewVariantTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, DelphiParserRULE_variantType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(787)
		p.Match(DelphiParserVARIANT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleTypeContext is an interface to support dynamic dispatch.
type ISimpleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ident() IIdentContext
	SubRangeType() ISubRangeTypeContext
	EnumType() IEnumTypeContext

	// IsSimpleTypeContext differentiates from other interfaces.
	IsSimpleTypeContext()
}

type SimpleTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleTypeContext() *SimpleTypeContext {
	var p = new(SimpleTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_simpleType
	return p
}

func InitEmptySimpleTypeContext(p *SimpleTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_simpleType
}

func (*SimpleTypeContext) IsSimpleTypeContext() {}

func NewSimpleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleTypeContext {
	var p = new(SimpleTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_simpleType

	return p
}

func (s *SimpleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleTypeContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *SimpleTypeContext) SubRangeType() ISubRangeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubRangeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubRangeTypeContext)
}

func (s *SimpleTypeContext) EnumType() IEnumTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumTypeContext)
}

func (s *SimpleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterSimpleType(s)
	}
}

func (s *SimpleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitSimpleType(s)
	}
}

func (p *DelphiParser) SimpleType() (localctx ISimpleTypeContext) {
	localctx = NewSimpleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, DelphiParserRULE_simpleType)
	p.SetState(792)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(789)
			p.Ident()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(790)
			p.SubRangeType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(791)
			p.EnumType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubRangeTypeContext is an interface to support dynamic dispatch.
type ISubRangeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConstExpression() []IConstExpressionContext
	ConstExpression(i int) IConstExpressionContext
	DOTDOT() antlr.TerminalNode

	// IsSubRangeTypeContext differentiates from other interfaces.
	IsSubRangeTypeContext()
}

type SubRangeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubRangeTypeContext() *SubRangeTypeContext {
	var p = new(SubRangeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_subRangeType
	return p
}

func InitEmptySubRangeTypeContext(p *SubRangeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_subRangeType
}

func (*SubRangeTypeContext) IsSubRangeTypeContext() {}

func NewSubRangeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubRangeTypeContext {
	var p = new(SubRangeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_subRangeType

	return p
}

func (s *SubRangeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SubRangeTypeContext) AllConstExpression() []IConstExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstExpressionContext); ok {
			len++
		}
	}

	tst := make([]IConstExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstExpressionContext); ok {
			tst[i] = t.(IConstExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SubRangeTypeContext) ConstExpression(i int) IConstExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstExpressionContext)
}

func (s *SubRangeTypeContext) DOTDOT() antlr.TerminalNode {
	return s.GetToken(DelphiParserDOTDOT, 0)
}

func (s *SubRangeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubRangeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubRangeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterSubRangeType(s)
	}
}

func (s *SubRangeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitSubRangeType(s)
	}
}

func (p *DelphiParser) SubRangeType() (localctx ISubRangeTypeContext) {
	localctx = NewSubRangeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, DelphiParserRULE_subRangeType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(794)
		p.ConstExpression()
	}
	p.SetState(797)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(795)
			p.Match(DelphiParserDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(796)
			p.ConstExpression()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumTypeContext is an interface to support dynamic dispatch.
type IEnumTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	RPAREN() antlr.TerminalNode
	AllEQUAL() []antlr.TerminalNode
	EQUAL(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsEnumTypeContext differentiates from other interfaces.
	IsEnumTypeContext()
}

type EnumTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumTypeContext() *EnumTypeContext {
	var p = new(EnumTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_enumType
	return p
}

func InitEmptyEnumTypeContext(p *EnumTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_enumType
}

func (*EnumTypeContext) IsEnumTypeContext() {}

func NewEnumTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumTypeContext {
	var p = new(EnumTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_enumType

	return p
}

func (s *EnumTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserLPAREN, 0)
}

func (s *EnumTypeContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *EnumTypeContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *EnumTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserRPAREN, 0)
}

func (s *EnumTypeContext) AllEQUAL() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserEQUAL)
}

func (s *EnumTypeContext) EQUAL(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserEQUAL, i)
}

func (s *EnumTypeContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *EnumTypeContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EnumTypeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserCOMMA)
}

func (s *EnumTypeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserCOMMA, i)
}

func (s *EnumTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterEnumType(s)
	}
}

func (s *EnumTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitEnumType(s)
	}
}

func (p *DelphiParser) EnumType() (localctx IEnumTypeContext) {
	localctx = NewEnumTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, DelphiParserRULE_enumType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(799)
		p.Match(DelphiParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(800)
		p.Ident()
	}
	p.SetState(803)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserEQUAL {
		{
			p.SetState(801)
			p.Match(DelphiParserEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(802)
			p.Expression()
		}

	}
	p.SetState(813)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DelphiParserCOMMA {
		{
			p.SetState(805)
			p.Match(DelphiParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(806)
			p.Ident()
		}
		p.SetState(809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserEQUAL {
			{
				p.SetState(807)
				p.Match(DelphiParserEQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(808)
				p.Expression()
			}

		}

		p.SetState(815)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(816)
		p.Match(DelphiParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeIdContext is an interface to support dynamic dispatch.
type ITypeIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NamespacedQualifiedIdent() INamespacedQualifiedIdentContext

	// IsTypeIdContext differentiates from other interfaces.
	IsTypeIdContext()
}

type TypeIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeIdContext() *TypeIdContext {
	var p = new(TypeIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_typeId
	return p
}

func InitEmptyTypeIdContext(p *TypeIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_typeId
}

func (*TypeIdContext) IsTypeIdContext() {}

func NewTypeIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeIdContext {
	var p = new(TypeIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_typeId

	return p
}

func (s *TypeIdContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeIdContext) NamespacedQualifiedIdent() INamespacedQualifiedIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespacedQualifiedIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespacedQualifiedIdentContext)
}

func (s *TypeIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterTypeId(s)
	}
}

func (s *TypeIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitTypeId(s)
	}
}

func (p *DelphiParser) TypeId() (localctx ITypeIdContext) {
	localctx = NewTypeIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, DelphiParserRULE_typeId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(818)
		p.NamespacedQualifiedIdent()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericTypeIdentContext is an interface to support dynamic dispatch.
type IGenericTypeIdentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdent() IQualifiedIdentContext
	GenericDefinition() IGenericDefinitionContext

	// IsGenericTypeIdentContext differentiates from other interfaces.
	IsGenericTypeIdentContext()
}

type GenericTypeIdentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericTypeIdentContext() *GenericTypeIdentContext {
	var p = new(GenericTypeIdentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_genericTypeIdent
	return p
}

func InitEmptyGenericTypeIdentContext(p *GenericTypeIdentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_genericTypeIdent
}

func (*GenericTypeIdentContext) IsGenericTypeIdentContext() {}

func NewGenericTypeIdentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericTypeIdentContext {
	var p = new(GenericTypeIdentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_genericTypeIdent

	return p
}

func (s *GenericTypeIdentContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericTypeIdentContext) QualifiedIdent() IQualifiedIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentContext)
}

func (s *GenericTypeIdentContext) GenericDefinition() IGenericDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericDefinitionContext)
}

func (s *GenericTypeIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericTypeIdentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericTypeIdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterGenericTypeIdent(s)
	}
}

func (s *GenericTypeIdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitGenericTypeIdent(s)
	}
}

func (p *DelphiParser) GenericTypeIdent() (localctx IGenericTypeIdentContext) {
	localctx = NewGenericTypeIdentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, DelphiParserRULE_genericTypeIdent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(820)
		p.QualifiedIdent()
	}
	p.SetState(822)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserLT {
		{
			p.SetState(821)
			p.GenericDefinition()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericDefinitionContext is an interface to support dynamic dispatch.
type IGenericDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleGenericDefinition() ISimpleGenericDefinitionContext
	ConstrainedGenericDefinition() IConstrainedGenericDefinitionContext

	// IsGenericDefinitionContext differentiates from other interfaces.
	IsGenericDefinitionContext()
}

type GenericDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericDefinitionContext() *GenericDefinitionContext {
	var p = new(GenericDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_genericDefinition
	return p
}

func InitEmptyGenericDefinitionContext(p *GenericDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_genericDefinition
}

func (*GenericDefinitionContext) IsGenericDefinitionContext() {}

func NewGenericDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericDefinitionContext {
	var p = new(GenericDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_genericDefinition

	return p
}

func (s *GenericDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericDefinitionContext) SimpleGenericDefinition() ISimpleGenericDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleGenericDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleGenericDefinitionContext)
}

func (s *GenericDefinitionContext) ConstrainedGenericDefinition() IConstrainedGenericDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstrainedGenericDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstrainedGenericDefinitionContext)
}

func (s *GenericDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterGenericDefinition(s)
	}
}

func (s *GenericDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitGenericDefinition(s)
	}
}

func (p *DelphiParser) GenericDefinition() (localctx IGenericDefinitionContext) {
	localctx = NewGenericDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, DelphiParserRULE_genericDefinition)
	p.SetState(826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(824)
			p.SimpleGenericDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(825)
			p.ConstrainedGenericDefinition()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleGenericDefinitionContext is an interface to support dynamic dispatch.
type ISimpleGenericDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	GT() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSimpleGenericDefinitionContext differentiates from other interfaces.
	IsSimpleGenericDefinitionContext()
}

type SimpleGenericDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleGenericDefinitionContext() *SimpleGenericDefinitionContext {
	var p = new(SimpleGenericDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_simpleGenericDefinition
	return p
}

func InitEmptySimpleGenericDefinitionContext(p *SimpleGenericDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_simpleGenericDefinition
}

func (*SimpleGenericDefinitionContext) IsSimpleGenericDefinitionContext() {}

func NewSimpleGenericDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleGenericDefinitionContext {
	var p = new(SimpleGenericDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_simpleGenericDefinition

	return p
}

func (s *SimpleGenericDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleGenericDefinitionContext) LT() antlr.TerminalNode {
	return s.GetToken(DelphiParserLT, 0)
}

func (s *SimpleGenericDefinitionContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *SimpleGenericDefinitionContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *SimpleGenericDefinitionContext) GT() antlr.TerminalNode {
	return s.GetToken(DelphiParserGT, 0)
}

func (s *SimpleGenericDefinitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserCOMMA)
}

func (s *SimpleGenericDefinitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserCOMMA, i)
}

func (s *SimpleGenericDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleGenericDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleGenericDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterSimpleGenericDefinition(s)
	}
}

func (s *SimpleGenericDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitSimpleGenericDefinition(s)
	}
}

func (p *DelphiParser) SimpleGenericDefinition() (localctx ISimpleGenericDefinitionContext) {
	localctx = NewSimpleGenericDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, DelphiParserRULE_simpleGenericDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(828)
		p.Match(DelphiParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(829)
		p.Ident()
	}
	p.SetState(834)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DelphiParserCOMMA {
		{
			p.SetState(830)
			p.Match(DelphiParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(831)
			p.Ident()
		}

		p.SetState(836)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(837)
		p.Match(DelphiParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstrainedGenericDefinitionContext is an interface to support dynamic dispatch.
type IConstrainedGenericDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	AllConstrainedGeneric() []IConstrainedGenericContext
	ConstrainedGeneric(i int) IConstrainedGenericContext
	GT() antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsConstrainedGenericDefinitionContext differentiates from other interfaces.
	IsConstrainedGenericDefinitionContext()
}

type ConstrainedGenericDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstrainedGenericDefinitionContext() *ConstrainedGenericDefinitionContext {
	var p = new(ConstrainedGenericDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_constrainedGenericDefinition
	return p
}

func InitEmptyConstrainedGenericDefinitionContext(p *ConstrainedGenericDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_constrainedGenericDefinition
}

func (*ConstrainedGenericDefinitionContext) IsConstrainedGenericDefinitionContext() {}

func NewConstrainedGenericDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstrainedGenericDefinitionContext {
	var p = new(ConstrainedGenericDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_constrainedGenericDefinition

	return p
}

func (s *ConstrainedGenericDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstrainedGenericDefinitionContext) LT() antlr.TerminalNode {
	return s.GetToken(DelphiParserLT, 0)
}

func (s *ConstrainedGenericDefinitionContext) AllConstrainedGeneric() []IConstrainedGenericContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstrainedGenericContext); ok {
			len++
		}
	}

	tst := make([]IConstrainedGenericContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstrainedGenericContext); ok {
			tst[i] = t.(IConstrainedGenericContext)
			i++
		}
	}

	return tst
}

func (s *ConstrainedGenericDefinitionContext) ConstrainedGeneric(i int) IConstrainedGenericContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstrainedGenericContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstrainedGenericContext)
}

func (s *ConstrainedGenericDefinitionContext) GT() antlr.TerminalNode {
	return s.GetToken(DelphiParserGT, 0)
}

func (s *ConstrainedGenericDefinitionContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserSEMI)
}

func (s *ConstrainedGenericDefinitionContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, i)
}

func (s *ConstrainedGenericDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstrainedGenericDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstrainedGenericDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterConstrainedGenericDefinition(s)
	}
}

func (s *ConstrainedGenericDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitConstrainedGenericDefinition(s)
	}
}

func (p *DelphiParser) ConstrainedGenericDefinition() (localctx IConstrainedGenericDefinitionContext) {
	localctx = NewConstrainedGenericDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, DelphiParserRULE_constrainedGenericDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(839)
		p.Match(DelphiParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(840)
		p.ConstrainedGeneric()
	}
	p.SetState(845)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DelphiParserSEMI {
		{
			p.SetState(841)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(842)
			p.ConstrainedGeneric()
		}

		p.SetState(847)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(848)
		p.Match(DelphiParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstrainedGenericContext is an interface to support dynamic dispatch.
type IConstrainedGenericContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ident() IIdentContext
	COLON() antlr.TerminalNode
	AllGenericConstraint() []IGenericConstraintContext
	GenericConstraint(i int) IGenericConstraintContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsConstrainedGenericContext differentiates from other interfaces.
	IsConstrainedGenericContext()
}

type ConstrainedGenericContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstrainedGenericContext() *ConstrainedGenericContext {
	var p = new(ConstrainedGenericContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_constrainedGeneric
	return p
}

func InitEmptyConstrainedGenericContext(p *ConstrainedGenericContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_constrainedGeneric
}

func (*ConstrainedGenericContext) IsConstrainedGenericContext() {}

func NewConstrainedGenericContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstrainedGenericContext {
	var p = new(ConstrainedGenericContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_constrainedGeneric

	return p
}

func (s *ConstrainedGenericContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstrainedGenericContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *ConstrainedGenericContext) COLON() antlr.TerminalNode {
	return s.GetToken(DelphiParserCOLON, 0)
}

func (s *ConstrainedGenericContext) AllGenericConstraint() []IGenericConstraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGenericConstraintContext); ok {
			len++
		}
	}

	tst := make([]IGenericConstraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGenericConstraintContext); ok {
			tst[i] = t.(IGenericConstraintContext)
			i++
		}
	}

	return tst
}

func (s *ConstrainedGenericContext) GenericConstraint(i int) IGenericConstraintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericConstraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericConstraintContext)
}

func (s *ConstrainedGenericContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserCOMMA)
}

func (s *ConstrainedGenericContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserCOMMA, i)
}

func (s *ConstrainedGenericContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstrainedGenericContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstrainedGenericContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterConstrainedGeneric(s)
	}
}

func (s *ConstrainedGenericContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitConstrainedGeneric(s)
	}
}

func (p *DelphiParser) ConstrainedGeneric() (localctx IConstrainedGenericContext) {
	localctx = NewConstrainedGenericContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, DelphiParserRULE_constrainedGeneric)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(850)
		p.Ident()
	}
	p.SetState(860)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserCOLON {
		{
			p.SetState(851)
			p.Match(DelphiParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(852)
			p.GenericConstraint()
		}
		p.SetState(857)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DelphiParserCOMMA {
			{
				p.SetState(853)
				p.Match(DelphiParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(854)
				p.GenericConstraint()
			}

			p.SetState(859)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericConstraintContext is an interface to support dynamic dispatch.
type IGenericConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ident() IIdentContext
	RECORD() antlr.TerminalNode
	CLASS() antlr.TerminalNode
	CONSTRUCTOR() antlr.TerminalNode

	// IsGenericConstraintContext differentiates from other interfaces.
	IsGenericConstraintContext()
}

type GenericConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericConstraintContext() *GenericConstraintContext {
	var p = new(GenericConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_genericConstraint
	return p
}

func InitEmptyGenericConstraintContext(p *GenericConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_genericConstraint
}

func (*GenericConstraintContext) IsGenericConstraintContext() {}

func NewGenericConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericConstraintContext {
	var p = new(GenericConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_genericConstraint

	return p
}

func (s *GenericConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericConstraintContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *GenericConstraintContext) RECORD() antlr.TerminalNode {
	return s.GetToken(DelphiParserRECORD, 0)
}

func (s *GenericConstraintContext) CLASS() antlr.TerminalNode {
	return s.GetToken(DelphiParserCLASS, 0)
}

func (s *GenericConstraintContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(DelphiParserCONSTRUCTOR, 0)
}

func (s *GenericConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterGenericConstraint(s)
	}
}

func (s *GenericConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitGenericConstraint(s)
	}
}

func (p *DelphiParser) GenericConstraint() (localctx IGenericConstraintContext) {
	localctx = NewGenericConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, DelphiParserRULE_genericConstraint)
	var _la int

	p.SetState(864)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserADD, DelphiParserANSISTRING, DelphiParserAT, DelphiParserBREAK, DelphiParserCONTAINS, DelphiParserCONTINUE, DelphiParserDEFAULT, DelphiParserEXIT, DelphiParserEXPORT, DelphiParserFINAL, DelphiParserIMPLEMENTS, DelphiParserINDEX, DelphiParserLOCAL, DelphiParserMESSAGE, DelphiParserNAME, DelphiParserOBJECT, DelphiParserOPERATOR, DelphiParserOUT, DelphiParserPOINTER, DelphiParserREAD, DelphiParserREADONLY, DelphiParserREFERENCE, DelphiParserREGISTER, DelphiParserREMOVE, DelphiParserSTORED, DelphiParserSTRICT, DelphiParserSTRING, DelphiParserVARIANT, DelphiParserWRITE, DelphiParserAMBER, DelphiParserTkIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(862)
			p.Ident()
		}

	case DelphiParserCLASS, DelphiParserCONSTRUCTOR, DelphiParserRECORD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(863)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DelphiParserCLASS || _la == DelphiParserCONSTRUCTOR || _la == DelphiParserRECORD) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericPostfixContext is an interface to support dynamic dispatch.
type IGenericPostfixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	AllTypeDecl() []ITypeDeclContext
	TypeDecl(i int) ITypeDeclContext
	GT() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGenericPostfixContext differentiates from other interfaces.
	IsGenericPostfixContext()
}

type GenericPostfixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericPostfixContext() *GenericPostfixContext {
	var p = new(GenericPostfixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_genericPostfix
	return p
}

func InitEmptyGenericPostfixContext(p *GenericPostfixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_genericPostfix
}

func (*GenericPostfixContext) IsGenericPostfixContext() {}

func NewGenericPostfixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericPostfixContext {
	var p = new(GenericPostfixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_genericPostfix

	return p
}

func (s *GenericPostfixContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericPostfixContext) LT() antlr.TerminalNode {
	return s.GetToken(DelphiParserLT, 0)
}

func (s *GenericPostfixContext) AllTypeDecl() []ITypeDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeDeclContext); ok {
			len++
		}
	}

	tst := make([]ITypeDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeDeclContext); ok {
			tst[i] = t.(ITypeDeclContext)
			i++
		}
	}

	return tst
}

func (s *GenericPostfixContext) TypeDecl(i int) ITypeDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *GenericPostfixContext) GT() antlr.TerminalNode {
	return s.GetToken(DelphiParserGT, 0)
}

func (s *GenericPostfixContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserCOMMA)
}

func (s *GenericPostfixContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserCOMMA, i)
}

func (s *GenericPostfixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericPostfixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericPostfixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterGenericPostfix(s)
	}
}

func (s *GenericPostfixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitGenericPostfix(s)
	}
}

func (p *DelphiParser) GenericPostfix() (localctx IGenericPostfixContext) {
	localctx = NewGenericPostfixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, DelphiParserRULE_genericPostfix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(866)
		p.Match(DelphiParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(867)
		p.TypeDecl()
	}
	p.SetState(872)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DelphiParserCOMMA {
		{
			p.SetState(868)
			p.Match(DelphiParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(869)
			p.TypeDecl()
		}

		p.SetState(874)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(875)
		p.Match(DelphiParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassDeclContext is an interface to support dynamic dispatch.
type IClassDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassTypeTypeDecl() IClassTypeTypeDeclContext
	ClassTypeDecl() IClassTypeDeclContext
	ClassHelperDecl() IClassHelperDeclContext
	InterfaceTypeDecl() IInterfaceTypeDeclContext
	ObjectDecl() IObjectDeclContext
	RecordDecl() IRecordDeclContext
	RecordHelperDecl() IRecordHelperDeclContext

	// IsClassDeclContext differentiates from other interfaces.
	IsClassDeclContext()
}

type ClassDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclContext() *ClassDeclContext {
	var p = new(ClassDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classDecl
	return p
}

func InitEmptyClassDeclContext(p *ClassDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classDecl
}

func (*ClassDeclContext) IsClassDeclContext() {}

func NewClassDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclContext {
	var p = new(ClassDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_classDecl

	return p
}

func (s *ClassDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclContext) ClassTypeTypeDecl() IClassTypeTypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTypeTypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTypeTypeDeclContext)
}

func (s *ClassDeclContext) ClassTypeDecl() IClassTypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTypeDeclContext)
}

func (s *ClassDeclContext) ClassHelperDecl() IClassHelperDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassHelperDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassHelperDeclContext)
}

func (s *ClassDeclContext) InterfaceTypeDecl() IInterfaceTypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceTypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceTypeDeclContext)
}

func (s *ClassDeclContext) ObjectDecl() IObjectDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectDeclContext)
}

func (s *ClassDeclContext) RecordDecl() IRecordDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclContext)
}

func (s *ClassDeclContext) RecordHelperDecl() IRecordHelperDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordHelperDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordHelperDeclContext)
}

func (s *ClassDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterClassDecl(s)
	}
}

func (s *ClassDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitClassDecl(s)
	}
}

func (p *DelphiParser) ClassDecl() (localctx IClassDeclContext) {
	localctx = NewClassDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, DelphiParserRULE_classDecl)
	p.SetState(884)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(877)
			p.ClassTypeTypeDecl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(878)
			p.ClassTypeDecl()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(879)
			p.ClassHelperDecl()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(880)
			p.InterfaceTypeDecl()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(881)
			p.ObjectDecl()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(882)
			p.RecordDecl()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(883)
			p.RecordHelperDecl()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassTypeTypeDeclContext is an interface to support dynamic dispatch.
type IClassTypeTypeDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	OF() antlr.TerminalNode
	TypeId() ITypeIdContext

	// IsClassTypeTypeDeclContext differentiates from other interfaces.
	IsClassTypeTypeDeclContext()
}

type ClassTypeTypeDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTypeTypeDeclContext() *ClassTypeTypeDeclContext {
	var p = new(ClassTypeTypeDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classTypeTypeDecl
	return p
}

func InitEmptyClassTypeTypeDeclContext(p *ClassTypeTypeDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classTypeTypeDecl
}

func (*ClassTypeTypeDeclContext) IsClassTypeTypeDeclContext() {}

func NewClassTypeTypeDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTypeTypeDeclContext {
	var p = new(ClassTypeTypeDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_classTypeTypeDecl

	return p
}

func (s *ClassTypeTypeDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTypeTypeDeclContext) CLASS() antlr.TerminalNode {
	return s.GetToken(DelphiParserCLASS, 0)
}

func (s *ClassTypeTypeDeclContext) OF() antlr.TerminalNode {
	return s.GetToken(DelphiParserOF, 0)
}

func (s *ClassTypeTypeDeclContext) TypeId() ITypeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdContext)
}

func (s *ClassTypeTypeDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTypeTypeDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTypeTypeDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterClassTypeTypeDecl(s)
	}
}

func (s *ClassTypeTypeDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitClassTypeTypeDecl(s)
	}
}

func (p *DelphiParser) ClassTypeTypeDecl() (localctx IClassTypeTypeDeclContext) {
	localctx = NewClassTypeTypeDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, DelphiParserRULE_classTypeTypeDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(886)
		p.Match(DelphiParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(887)
		p.Match(DelphiParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(888)
		p.TypeId()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassTypeDeclContext is an interface to support dynamic dispatch.
type IClassTypeDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	END() antlr.TerminalNode
	ClassState() IClassStateContext
	ClassParent() IClassParentContext
	AllClassItem() []IClassItemContext
	ClassItem(i int) IClassItemContext

	// IsClassTypeDeclContext differentiates from other interfaces.
	IsClassTypeDeclContext()
}

type ClassTypeDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTypeDeclContext() *ClassTypeDeclContext {
	var p = new(ClassTypeDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classTypeDecl
	return p
}

func InitEmptyClassTypeDeclContext(p *ClassTypeDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classTypeDecl
}

func (*ClassTypeDeclContext) IsClassTypeDeclContext() {}

func NewClassTypeDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTypeDeclContext {
	var p = new(ClassTypeDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_classTypeDecl

	return p
}

func (s *ClassTypeDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTypeDeclContext) CLASS() antlr.TerminalNode {
	return s.GetToken(DelphiParserCLASS, 0)
}

func (s *ClassTypeDeclContext) END() antlr.TerminalNode {
	return s.GetToken(DelphiParserEND, 0)
}

func (s *ClassTypeDeclContext) ClassState() IClassStateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassStateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassStateContext)
}

func (s *ClassTypeDeclContext) ClassParent() IClassParentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassParentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassParentContext)
}

func (s *ClassTypeDeclContext) AllClassItem() []IClassItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassItemContext); ok {
			len++
		}
	}

	tst := make([]IClassItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassItemContext); ok {
			tst[i] = t.(IClassItemContext)
			i++
		}
	}

	return tst
}

func (s *ClassTypeDeclContext) ClassItem(i int) IClassItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassItemContext)
}

func (s *ClassTypeDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTypeDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTypeDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterClassTypeDecl(s)
	}
}

func (s *ClassTypeDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitClassTypeDecl(s)
	}
}

func (p *DelphiParser) ClassTypeDecl() (localctx IClassTypeDeclContext) {
	localctx = NewClassTypeDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, DelphiParserRULE_classTypeDecl)
	var _la int

	p.SetState(908)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(890)
			p.Match(DelphiParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(892)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserABSTRACT || _la == DelphiParserSEALED {
			{
				p.SetState(891)
				p.ClassState()
			}

		}
		p.SetState(895)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserLPAREN {
			{
				p.SetState(894)
				p.ClassParent()
			}

		}
		p.SetState(900)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&90653221931757650) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2903555721128847627) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&18014400656965633) != 0) {
			{
				p.SetState(897)
				p.ClassItem()
			}

			p.SetState(902)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(903)
			p.Match(DelphiParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(904)
			p.Match(DelphiParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(906)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(905)
				p.ClassParent()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassStateContext is an interface to support dynamic dispatch.
type IClassStateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEALED() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode

	// IsClassStateContext differentiates from other interfaces.
	IsClassStateContext()
}

type ClassStateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassStateContext() *ClassStateContext {
	var p = new(ClassStateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classState
	return p
}

func InitEmptyClassStateContext(p *ClassStateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classState
}

func (*ClassStateContext) IsClassStateContext() {}

func NewClassStateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassStateContext {
	var p = new(ClassStateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_classState

	return p
}

func (s *ClassStateContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassStateContext) SEALED() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEALED, 0)
}

func (s *ClassStateContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(DelphiParserABSTRACT, 0)
}

func (s *ClassStateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassStateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassStateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterClassState(s)
	}
}

func (s *ClassStateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitClassState(s)
	}
}

func (p *DelphiParser) ClassState() (localctx IClassStateContext) {
	localctx = NewClassStateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, DelphiParserRULE_classState)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(910)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DelphiParserABSTRACT || _la == DelphiParserSEALED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassParentContext is an interface to support dynamic dispatch.
type IClassParentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllGenericTypeIdent() []IGenericTypeIdentContext
	GenericTypeIdent(i int) IGenericTypeIdentContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsClassParentContext differentiates from other interfaces.
	IsClassParentContext()
}

type ClassParentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassParentContext() *ClassParentContext {
	var p = new(ClassParentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classParent
	return p
}

func InitEmptyClassParentContext(p *ClassParentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classParent
}

func (*ClassParentContext) IsClassParentContext() {}

func NewClassParentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassParentContext {
	var p = new(ClassParentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_classParent

	return p
}

func (s *ClassParentContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassParentContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserLPAREN, 0)
}

func (s *ClassParentContext) AllGenericTypeIdent() []IGenericTypeIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGenericTypeIdentContext); ok {
			len++
		}
	}

	tst := make([]IGenericTypeIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGenericTypeIdentContext); ok {
			tst[i] = t.(IGenericTypeIdentContext)
			i++
		}
	}

	return tst
}

func (s *ClassParentContext) GenericTypeIdent(i int) IGenericTypeIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericTypeIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericTypeIdentContext)
}

func (s *ClassParentContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserRPAREN, 0)
}

func (s *ClassParentContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserCOMMA)
}

func (s *ClassParentContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserCOMMA, i)
}

func (s *ClassParentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassParentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassParentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterClassParent(s)
	}
}

func (s *ClassParentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitClassParent(s)
	}
}

func (p *DelphiParser) ClassParent() (localctx IClassParentContext) {
	localctx = NewClassParentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, DelphiParserRULE_classParent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(912)
		p.Match(DelphiParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(913)
		p.GenericTypeIdent()
	}
	p.SetState(918)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DelphiParserCOMMA {
		{
			p.SetState(914)
			p.Match(DelphiParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(915)
			p.GenericTypeIdent()
		}

		p.SetState(920)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(921)
		p.Match(DelphiParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassItemContext is an interface to support dynamic dispatch.
type IClassItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Visibility() IVisibilityContext
	ClassMethod() IClassMethodContext
	ClassField() IClassFieldContext
	ClassProperty() IClassPropertyContext
	ConstSection() IConstSectionContext
	TypeSection() ITypeSectionContext
	VarSection() IVarSectionContext
	CLASS() antlr.TerminalNode

	// IsClassItemContext differentiates from other interfaces.
	IsClassItemContext()
}

type ClassItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassItemContext() *ClassItemContext {
	var p = new(ClassItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classItem
	return p
}

func InitEmptyClassItemContext(p *ClassItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classItem
}

func (*ClassItemContext) IsClassItemContext() {}

func NewClassItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassItemContext {
	var p = new(ClassItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_classItem

	return p
}

func (s *ClassItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassItemContext) Visibility() IVisibilityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVisibilityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *ClassItemContext) ClassMethod() IClassMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassMethodContext)
}

func (s *ClassItemContext) ClassField() IClassFieldContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassFieldContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassFieldContext)
}

func (s *ClassItemContext) ClassProperty() IClassPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassPropertyContext)
}

func (s *ClassItemContext) ConstSection() IConstSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstSectionContext)
}

func (s *ClassItemContext) TypeSection() ITypeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSectionContext)
}

func (s *ClassItemContext) VarSection() IVarSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarSectionContext)
}

func (s *ClassItemContext) CLASS() antlr.TerminalNode {
	return s.GetToken(DelphiParserCLASS, 0)
}

func (s *ClassItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterClassItem(s)
	}
}

func (s *ClassItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitClassItem(s)
	}
}

func (p *DelphiParser) ClassItem() (localctx IClassItemContext) {
	localctx = NewClassItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, DelphiParserRULE_classItem)
	var _la int

	p.SetState(933)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(923)
			p.Visibility()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(924)
			p.ClassMethod()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(925)
			p.ClassField()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(926)
			p.ClassProperty()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(927)
			p.ConstSection()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(928)
			p.TypeSection()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(930)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserCLASS {
			{
				p.SetState(929)
				p.Match(DelphiParserCLASS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(932)
			p.VarSection()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassHelperDeclContext is an interface to support dynamic dispatch.
type IClassHelperDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	HELPER() antlr.TerminalNode
	FOR() antlr.TerminalNode
	TypeId() ITypeIdContext
	END() antlr.TerminalNode
	ClassParent() IClassParentContext
	AllClassHelperItem() []IClassHelperItemContext
	ClassHelperItem(i int) IClassHelperItemContext

	// IsClassHelperDeclContext differentiates from other interfaces.
	IsClassHelperDeclContext()
}

type ClassHelperDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassHelperDeclContext() *ClassHelperDeclContext {
	var p = new(ClassHelperDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classHelperDecl
	return p
}

func InitEmptyClassHelperDeclContext(p *ClassHelperDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classHelperDecl
}

func (*ClassHelperDeclContext) IsClassHelperDeclContext() {}

func NewClassHelperDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassHelperDeclContext {
	var p = new(ClassHelperDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_classHelperDecl

	return p
}

func (s *ClassHelperDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassHelperDeclContext) CLASS() antlr.TerminalNode {
	return s.GetToken(DelphiParserCLASS, 0)
}

func (s *ClassHelperDeclContext) HELPER() antlr.TerminalNode {
	return s.GetToken(DelphiParserHELPER, 0)
}

func (s *ClassHelperDeclContext) FOR() antlr.TerminalNode {
	return s.GetToken(DelphiParserFOR, 0)
}

func (s *ClassHelperDeclContext) TypeId() ITypeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdContext)
}

func (s *ClassHelperDeclContext) END() antlr.TerminalNode {
	return s.GetToken(DelphiParserEND, 0)
}

func (s *ClassHelperDeclContext) ClassParent() IClassParentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassParentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassParentContext)
}

func (s *ClassHelperDeclContext) AllClassHelperItem() []IClassHelperItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassHelperItemContext); ok {
			len++
		}
	}

	tst := make([]IClassHelperItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassHelperItemContext); ok {
			tst[i] = t.(IClassHelperItemContext)
			i++
		}
	}

	return tst
}

func (s *ClassHelperDeclContext) ClassHelperItem(i int) IClassHelperItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassHelperItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassHelperItemContext)
}

func (s *ClassHelperDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassHelperDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassHelperDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterClassHelperDecl(s)
	}
}

func (s *ClassHelperDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitClassHelperDecl(s)
	}
}

func (p *DelphiParser) ClassHelperDecl() (localctx IClassHelperDeclContext) {
	localctx = NewClassHelperDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, DelphiParserRULE_classHelperDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(935)
		p.Match(DelphiParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(936)
		p.Match(DelphiParserHELPER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(938)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserLPAREN {
		{
			p.SetState(937)
			p.ClassParent()
		}

	}
	{
		p.SetState(940)
		p.Match(DelphiParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(941)
		p.TypeId()
	}
	p.SetState(945)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&562949988294658) != 0) || ((int64((_la-75)) & ^0x3f) == 0 && ((int64(1)<<(_la-75))&282711927417857) != 0) {
		{
			p.SetState(942)
			p.ClassHelperItem()
		}

		p.SetState(947)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(948)
		p.Match(DelphiParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassHelperItemContext is an interface to support dynamic dispatch.
type IClassHelperItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Visibility() IVisibilityContext
	ClassMethod() IClassMethodContext
	ClassProperty() IClassPropertyContext
	VarSection() IVarSectionContext
	CLASS() antlr.TerminalNode

	// IsClassHelperItemContext differentiates from other interfaces.
	IsClassHelperItemContext()
}

type ClassHelperItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassHelperItemContext() *ClassHelperItemContext {
	var p = new(ClassHelperItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classHelperItem
	return p
}

func InitEmptyClassHelperItemContext(p *ClassHelperItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classHelperItem
}

func (*ClassHelperItemContext) IsClassHelperItemContext() {}

func NewClassHelperItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassHelperItemContext {
	var p = new(ClassHelperItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_classHelperItem

	return p
}

func (s *ClassHelperItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassHelperItemContext) Visibility() IVisibilityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVisibilityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *ClassHelperItemContext) ClassMethod() IClassMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassMethodContext)
}

func (s *ClassHelperItemContext) ClassProperty() IClassPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassPropertyContext)
}

func (s *ClassHelperItemContext) VarSection() IVarSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarSectionContext)
}

func (s *ClassHelperItemContext) CLASS() antlr.TerminalNode {
	return s.GetToken(DelphiParserCLASS, 0)
}

func (s *ClassHelperItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassHelperItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassHelperItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterClassHelperItem(s)
	}
}

func (s *ClassHelperItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitClassHelperItem(s)
	}
}

func (p *DelphiParser) ClassHelperItem() (localctx IClassHelperItemContext) {
	localctx = NewClassHelperItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, DelphiParserRULE_classHelperItem)
	var _la int

	p.SetState(957)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(950)
			p.Visibility()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(951)
			p.ClassMethod()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(952)
			p.ClassProperty()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(954)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserCLASS {
			{
				p.SetState(953)
				p.Match(DelphiParserCLASS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(956)
			p.VarSection()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceTypeDeclContext is an interface to support dynamic dispatch.
type IInterfaceTypeDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InterfaceKey() IInterfaceKeyContext
	END() antlr.TerminalNode
	ClassParent() IClassParentContext
	InterfaceGuid() IInterfaceGuidContext
	AllInterfaceItem() []IInterfaceItemContext
	InterfaceItem(i int) IInterfaceItemContext

	// IsInterfaceTypeDeclContext differentiates from other interfaces.
	IsInterfaceTypeDeclContext()
}

type InterfaceTypeDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceTypeDeclContext() *InterfaceTypeDeclContext {
	var p = new(InterfaceTypeDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_interfaceTypeDecl
	return p
}

func InitEmptyInterfaceTypeDeclContext(p *InterfaceTypeDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_interfaceTypeDecl
}

func (*InterfaceTypeDeclContext) IsInterfaceTypeDeclContext() {}

func NewInterfaceTypeDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceTypeDeclContext {
	var p = new(InterfaceTypeDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_interfaceTypeDecl

	return p
}

func (s *InterfaceTypeDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceTypeDeclContext) InterfaceKey() IInterfaceKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceKeyContext)
}

func (s *InterfaceTypeDeclContext) END() antlr.TerminalNode {
	return s.GetToken(DelphiParserEND, 0)
}

func (s *InterfaceTypeDeclContext) ClassParent() IClassParentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassParentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassParentContext)
}

func (s *InterfaceTypeDeclContext) InterfaceGuid() IInterfaceGuidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceGuidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceGuidContext)
}

func (s *InterfaceTypeDeclContext) AllInterfaceItem() []IInterfaceItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceItemContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceItemContext); ok {
			tst[i] = t.(IInterfaceItemContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceTypeDeclContext) InterfaceItem(i int) IInterfaceItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceItemContext)
}

func (s *InterfaceTypeDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceTypeDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceTypeDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterInterfaceTypeDecl(s)
	}
}

func (s *InterfaceTypeDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitInterfaceTypeDecl(s)
	}
}

func (p *DelphiParser) InterfaceTypeDecl() (localctx IInterfaceTypeDeclContext) {
	localctx = NewInterfaceTypeDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, DelphiParserRULE_interfaceTypeDecl)
	var _la int

	p.SetState(978)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(959)
			p.InterfaceKey()
		}
		p.SetState(961)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserLPAREN {
			{
				p.SetState(960)
				p.ClassParent()
			}

		}
		p.SetState(964)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserLBRACK {
			{
				p.SetState(963)
				p.InterfaceGuid()
			}

		}
		p.SetState(969)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&562949988286466) != 0) || ((int64((_la-75)) & ^0x3f) == 0 && ((int64(1)<<(_la-75))&10241) != 0) {
			{
				p.SetState(966)
				p.InterfaceItem()
			}

			p.SetState(971)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(972)
			p.Match(DelphiParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(974)
			p.InterfaceKey()
		}
		p.SetState(976)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(975)
				p.ClassParent()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceKeyContext is an interface to support dynamic dispatch.
type IInterfaceKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	DISPINTERFACE() antlr.TerminalNode

	// IsInterfaceKeyContext differentiates from other interfaces.
	IsInterfaceKeyContext()
}

type InterfaceKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceKeyContext() *InterfaceKeyContext {
	var p = new(InterfaceKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_interfaceKey
	return p
}

func InitEmptyInterfaceKeyContext(p *InterfaceKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_interfaceKey
}

func (*InterfaceKeyContext) IsInterfaceKeyContext() {}

func NewInterfaceKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceKeyContext {
	var p = new(InterfaceKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_interfaceKey

	return p
}

func (s *InterfaceKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceKeyContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(DelphiParserINTERFACE, 0)
}

func (s *InterfaceKeyContext) DISPINTERFACE() antlr.TerminalNode {
	return s.GetToken(DelphiParserDISPINTERFACE, 0)
}

func (s *InterfaceKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterInterfaceKey(s)
	}
}

func (s *InterfaceKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitInterfaceKey(s)
	}
}

func (p *DelphiParser) InterfaceKey() (localctx IInterfaceKeyContext) {
	localctx = NewInterfaceKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, DelphiParserRULE_interfaceKey)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(980)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DelphiParserDISPINTERFACE || _la == DelphiParserINTERFACE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceGuidContext is an interface to support dynamic dispatch.
type IInterfaceGuidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	QuotedString() antlr.TerminalNode
	RBRACK() antlr.TerminalNode

	// IsInterfaceGuidContext differentiates from other interfaces.
	IsInterfaceGuidContext()
}

type InterfaceGuidContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceGuidContext() *InterfaceGuidContext {
	var p = new(InterfaceGuidContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_interfaceGuid
	return p
}

func InitEmptyInterfaceGuidContext(p *InterfaceGuidContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_interfaceGuid
}

func (*InterfaceGuidContext) IsInterfaceGuidContext() {}

func NewInterfaceGuidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceGuidContext {
	var p = new(InterfaceGuidContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_interfaceGuid

	return p
}

func (s *InterfaceGuidContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceGuidContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(DelphiParserLBRACK, 0)
}

func (s *InterfaceGuidContext) QuotedString() antlr.TerminalNode {
	return s.GetToken(DelphiParserQuotedString, 0)
}

func (s *InterfaceGuidContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(DelphiParserRBRACK, 0)
}

func (s *InterfaceGuidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceGuidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceGuidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterInterfaceGuid(s)
	}
}

func (s *InterfaceGuidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitInterfaceGuid(s)
	}
}

func (p *DelphiParser) InterfaceGuid() (localctx IInterfaceGuidContext) {
	localctx = NewInterfaceGuidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, DelphiParserRULE_interfaceGuid)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(982)
		p.Match(DelphiParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(983)
		p.Match(DelphiParserQuotedString)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(984)
		p.Match(DelphiParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceItemContext is an interface to support dynamic dispatch.
type IInterfaceItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassMethod() IClassMethodContext
	ClassProperty() IClassPropertyContext
	CLASS() antlr.TerminalNode

	// IsInterfaceItemContext differentiates from other interfaces.
	IsInterfaceItemContext()
}

type InterfaceItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceItemContext() *InterfaceItemContext {
	var p = new(InterfaceItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_interfaceItem
	return p
}

func InitEmptyInterfaceItemContext(p *InterfaceItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_interfaceItem
}

func (*InterfaceItemContext) IsInterfaceItemContext() {}

func NewInterfaceItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceItemContext {
	var p = new(InterfaceItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_interfaceItem

	return p
}

func (s *InterfaceItemContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceItemContext) ClassMethod() IClassMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassMethodContext)
}

func (s *InterfaceItemContext) ClassProperty() IClassPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassPropertyContext)
}

func (s *InterfaceItemContext) CLASS() antlr.TerminalNode {
	return s.GetToken(DelphiParserCLASS, 0)
}

func (s *InterfaceItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterInterfaceItem(s)
	}
}

func (s *InterfaceItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitInterfaceItem(s)
	}
}

func (p *DelphiParser) InterfaceItem() (localctx IInterfaceItemContext) {
	localctx = NewInterfaceItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, DelphiParserRULE_interfaceItem)
	p.SetState(991)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(986)
			p.ClassMethod()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(988)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(987)
				p.Match(DelphiParserCLASS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(990)
			p.ClassProperty()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectDeclContext is an interface to support dynamic dispatch.
type IObjectDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT() antlr.TerminalNode
	END() antlr.TerminalNode
	ClassParent() IClassParentContext
	AllObjectItem() []IObjectItemContext
	ObjectItem(i int) IObjectItemContext

	// IsObjectDeclContext differentiates from other interfaces.
	IsObjectDeclContext()
}

type ObjectDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectDeclContext() *ObjectDeclContext {
	var p = new(ObjectDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_objectDecl
	return p
}

func InitEmptyObjectDeclContext(p *ObjectDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_objectDecl
}

func (*ObjectDeclContext) IsObjectDeclContext() {}

func NewObjectDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectDeclContext {
	var p = new(ObjectDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_objectDecl

	return p
}

func (s *ObjectDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectDeclContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(DelphiParserOBJECT, 0)
}

func (s *ObjectDeclContext) END() antlr.TerminalNode {
	return s.GetToken(DelphiParserEND, 0)
}

func (s *ObjectDeclContext) ClassParent() IClassParentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassParentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassParentContext)
}

func (s *ObjectDeclContext) AllObjectItem() []IObjectItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObjectItemContext); ok {
			len++
		}
	}

	tst := make([]IObjectItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObjectItemContext); ok {
			tst[i] = t.(IObjectItemContext)
			i++
		}
	}

	return tst
}

func (s *ObjectDeclContext) ObjectItem(i int) IObjectItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectItemContext)
}

func (s *ObjectDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterObjectDecl(s)
	}
}

func (s *ObjectDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitObjectDecl(s)
	}
}

func (p *DelphiParser) ObjectDecl() (localctx IObjectDeclContext) {
	localctx = NewObjectDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, DelphiParserRULE_objectDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(993)
		p.Match(DelphiParserOBJECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(995)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserLPAREN {
		{
			p.SetState(994)
			p.ClassParent()
		}

	}
	p.SetState(1000)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&90653221931233362) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2306828220729665803) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&18014400656965633) != 0) {
		{
			p.SetState(997)
			p.ObjectItem()
		}

		p.SetState(1002)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1003)
		p.Match(DelphiParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectItemContext is an interface to support dynamic dispatch.
type IObjectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Visibility() IVisibilityContext
	ClassMethod() IClassMethodContext
	ClassField() IClassFieldContext

	// IsObjectItemContext differentiates from other interfaces.
	IsObjectItemContext()
}

type ObjectItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectItemContext() *ObjectItemContext {
	var p = new(ObjectItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_objectItem
	return p
}

func InitEmptyObjectItemContext(p *ObjectItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_objectItem
}

func (*ObjectItemContext) IsObjectItemContext() {}

func NewObjectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectItemContext {
	var p = new(ObjectItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_objectItem

	return p
}

func (s *ObjectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectItemContext) Visibility() IVisibilityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVisibilityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *ObjectItemContext) ClassMethod() IClassMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassMethodContext)
}

func (s *ObjectItemContext) ClassField() IClassFieldContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassFieldContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassFieldContext)
}

func (s *ObjectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterObjectItem(s)
	}
}

func (s *ObjectItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitObjectItem(s)
	}
}

func (p *DelphiParser) ObjectItem() (localctx IObjectItemContext) {
	localctx = NewObjectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, DelphiParserRULE_objectItem)
	p.SetState(1008)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1005)
			p.Visibility()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1006)
			p.ClassMethod()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1007)
			p.ClassField()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordDeclContext is an interface to support dynamic dispatch.
type IRecordDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleRecord() ISimpleRecordContext
	VariantRecord() IVariantRecordContext

	// IsRecordDeclContext differentiates from other interfaces.
	IsRecordDeclContext()
}

type RecordDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordDeclContext() *RecordDeclContext {
	var p = new(RecordDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_recordDecl
	return p
}

func InitEmptyRecordDeclContext(p *RecordDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_recordDecl
}

func (*RecordDeclContext) IsRecordDeclContext() {}

func NewRecordDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordDeclContext {
	var p = new(RecordDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_recordDecl

	return p
}

func (s *RecordDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordDeclContext) SimpleRecord() ISimpleRecordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleRecordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleRecordContext)
}

func (s *RecordDeclContext) VariantRecord() IVariantRecordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariantRecordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariantRecordContext)
}

func (s *RecordDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterRecordDecl(s)
	}
}

func (s *RecordDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitRecordDecl(s)
	}
}

func (p *DelphiParser) RecordDecl() (localctx IRecordDeclContext) {
	localctx = NewRecordDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, DelphiParserRULE_recordDecl)
	p.SetState(1012)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1010)
			p.SimpleRecord()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1011)
			p.VariantRecord()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleRecordContext is an interface to support dynamic dispatch.
type ISimpleRecordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECORD() antlr.TerminalNode
	END() antlr.TerminalNode
	AllRecordField() []IRecordFieldContext
	RecordField(i int) IRecordFieldContext
	AllRecordItem() []IRecordItemContext
	RecordItem(i int) IRecordItemContext

	// IsSimpleRecordContext differentiates from other interfaces.
	IsSimpleRecordContext()
}

type SimpleRecordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleRecordContext() *SimpleRecordContext {
	var p = new(SimpleRecordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_simpleRecord
	return p
}

func InitEmptySimpleRecordContext(p *SimpleRecordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_simpleRecord
}

func (*SimpleRecordContext) IsSimpleRecordContext() {}

func NewSimpleRecordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleRecordContext {
	var p = new(SimpleRecordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_simpleRecord

	return p
}

func (s *SimpleRecordContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleRecordContext) RECORD() antlr.TerminalNode {
	return s.GetToken(DelphiParserRECORD, 0)
}

func (s *SimpleRecordContext) END() antlr.TerminalNode {
	return s.GetToken(DelphiParserEND, 0)
}

func (s *SimpleRecordContext) AllRecordField() []IRecordFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordFieldContext); ok {
			len++
		}
	}

	tst := make([]IRecordFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordFieldContext); ok {
			tst[i] = t.(IRecordFieldContext)
			i++
		}
	}

	return tst
}

func (s *SimpleRecordContext) RecordField(i int) IRecordFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordFieldContext)
}

func (s *SimpleRecordContext) AllRecordItem() []IRecordItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordItemContext); ok {
			len++
		}
	}

	tst := make([]IRecordItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordItemContext); ok {
			tst[i] = t.(IRecordItemContext)
			i++
		}
	}

	return tst
}

func (s *SimpleRecordContext) RecordItem(i int) IRecordItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordItemContext)
}

func (s *SimpleRecordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleRecordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleRecordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterSimpleRecord(s)
	}
}

func (s *SimpleRecordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitSimpleRecord(s)
	}
}

func (p *DelphiParser) SimpleRecord() (localctx ISimpleRecordContext) {
	localctx = NewSimpleRecordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, DelphiParserRULE_simpleRecord)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1014)
		p.Match(DelphiParserRECORD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1018)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1015)
				p.RecordField()
			}

		}
		p.SetState(1020)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1024)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&90653221931757650) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2903555721128847627) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&18014400656965633) != 0) {
		{
			p.SetState(1021)
			p.RecordItem()
		}

		p.SetState(1026)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1027)
		p.Match(DelphiParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariantRecordContext is an interface to support dynamic dispatch.
type IVariantRecordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECORD() antlr.TerminalNode
	RecordVariantSection() IRecordVariantSectionContext
	END() antlr.TerminalNode
	AllRecordField() []IRecordFieldContext
	RecordField(i int) IRecordFieldContext

	// IsVariantRecordContext differentiates from other interfaces.
	IsVariantRecordContext()
}

type VariantRecordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariantRecordContext() *VariantRecordContext {
	var p = new(VariantRecordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_variantRecord
	return p
}

func InitEmptyVariantRecordContext(p *VariantRecordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_variantRecord
}

func (*VariantRecordContext) IsVariantRecordContext() {}

func NewVariantRecordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariantRecordContext {
	var p = new(VariantRecordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_variantRecord

	return p
}

func (s *VariantRecordContext) GetParser() antlr.Parser { return s.parser }

func (s *VariantRecordContext) RECORD() antlr.TerminalNode {
	return s.GetToken(DelphiParserRECORD, 0)
}

func (s *VariantRecordContext) RecordVariantSection() IRecordVariantSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordVariantSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordVariantSectionContext)
}

func (s *VariantRecordContext) END() antlr.TerminalNode {
	return s.GetToken(DelphiParserEND, 0)
}

func (s *VariantRecordContext) AllRecordField() []IRecordFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordFieldContext); ok {
			len++
		}
	}

	tst := make([]IRecordFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordFieldContext); ok {
			tst[i] = t.(IRecordFieldContext)
			i++
		}
	}

	return tst
}

func (s *VariantRecordContext) RecordField(i int) IRecordFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordFieldContext)
}

func (s *VariantRecordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariantRecordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariantRecordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterVariantRecord(s)
	}
}

func (s *VariantRecordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitVariantRecord(s)
	}
}

func (p *DelphiParser) VariantRecord() (localctx IVariantRecordContext) {
	localctx = NewVariantRecordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, DelphiParserRULE_variantRecord)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1029)
		p.Match(DelphiParserRECORD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1033)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&90090271942938704) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2306828220488493323) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&18014400656965633) != 0) {
		{
			p.SetState(1030)
			p.RecordField()
		}

		p.SetState(1035)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1036)
		p.RecordVariantSection()
	}
	{
		p.SetState(1037)
		p.Match(DelphiParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordItemContext is an interface to support dynamic dispatch.
type IRecordItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Visibility() IVisibilityContext
	ClassMethod() IClassMethodContext
	ClassProperty() IClassPropertyContext
	ConstSection() IConstSectionContext
	TypeSection() ITypeSectionContext
	RecordField() IRecordFieldContext
	VarSection() IVarSectionContext
	CLASS() antlr.TerminalNode

	// IsRecordItemContext differentiates from other interfaces.
	IsRecordItemContext()
}

type RecordItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordItemContext() *RecordItemContext {
	var p = new(RecordItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_recordItem
	return p
}

func InitEmptyRecordItemContext(p *RecordItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_recordItem
}

func (*RecordItemContext) IsRecordItemContext() {}

func NewRecordItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordItemContext {
	var p = new(RecordItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_recordItem

	return p
}

func (s *RecordItemContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordItemContext) Visibility() IVisibilityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVisibilityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *RecordItemContext) ClassMethod() IClassMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassMethodContext)
}

func (s *RecordItemContext) ClassProperty() IClassPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassPropertyContext)
}

func (s *RecordItemContext) ConstSection() IConstSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstSectionContext)
}

func (s *RecordItemContext) TypeSection() ITypeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSectionContext)
}

func (s *RecordItemContext) RecordField() IRecordFieldContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordFieldContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordFieldContext)
}

func (s *RecordItemContext) VarSection() IVarSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarSectionContext)
}

func (s *RecordItemContext) CLASS() antlr.TerminalNode {
	return s.GetToken(DelphiParserCLASS, 0)
}

func (s *RecordItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterRecordItem(s)
	}
}

func (s *RecordItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitRecordItem(s)
	}
}

func (p *DelphiParser) RecordItem() (localctx IRecordItemContext) {
	localctx = NewRecordItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, DelphiParserRULE_recordItem)
	var _la int

	p.SetState(1049)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1039)
			p.Visibility()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1040)
			p.ClassMethod()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1041)
			p.ClassProperty()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1042)
			p.ConstSection()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1043)
			p.TypeSection()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1044)
			p.RecordField()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(1046)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserCLASS {
			{
				p.SetState(1045)
				p.Match(DelphiParserCLASS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1048)
			p.VarSection()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordFieldContext is an interface to support dynamic dispatch.
type IRecordFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentList() IIdentListContext
	COLON() antlr.TerminalNode
	TypeDecl() ITypeDeclContext
	AllHintingDirective() []IHintingDirectiveContext
	HintingDirective(i int) IHintingDirectiveContext
	SEMI() antlr.TerminalNode

	// IsRecordFieldContext differentiates from other interfaces.
	IsRecordFieldContext()
}

type RecordFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordFieldContext() *RecordFieldContext {
	var p = new(RecordFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_recordField
	return p
}

func InitEmptyRecordFieldContext(p *RecordFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_recordField
}

func (*RecordFieldContext) IsRecordFieldContext() {}

func NewRecordFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordFieldContext {
	var p = new(RecordFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_recordField

	return p
}

func (s *RecordFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordFieldContext) IdentList() IIdentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentListContext)
}

func (s *RecordFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(DelphiParserCOLON, 0)
}

func (s *RecordFieldContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *RecordFieldContext) AllHintingDirective() []IHintingDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintingDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IHintingDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintingDirectiveContext); ok {
			tst[i] = t.(IHintingDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *RecordFieldContext) HintingDirective(i int) IHintingDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintingDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintingDirectiveContext)
}

func (s *RecordFieldContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *RecordFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterRecordField(s)
	}
}

func (s *RecordFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitRecordField(s)
	}
}

func (p *DelphiParser) RecordField() (localctx IRecordFieldContext) {
	localctx = NewRecordFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, DelphiParserRULE_recordField)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1051)
		p.IdentList()
	}
	{
		p.SetState(1052)
		p.Match(DelphiParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1053)
		p.TypeDecl()
	}
	p.SetState(1057)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&576461302059253761) != 0 {
		{
			p.SetState(1054)
			p.HintingDirective()
		}

		p.SetState(1059)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserSEMI {
		{
			p.SetState(1060)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordVariantFieldContext is an interface to support dynamic dispatch.
type IRecordVariantFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentList() IIdentListContext
	COLON() antlr.TerminalNode
	TypeDecl() ITypeDeclContext
	AllHintingDirective() []IHintingDirectiveContext
	HintingDirective(i int) IHintingDirectiveContext
	SEMI() antlr.TerminalNode

	// IsRecordVariantFieldContext differentiates from other interfaces.
	IsRecordVariantFieldContext()
}

type RecordVariantFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordVariantFieldContext() *RecordVariantFieldContext {
	var p = new(RecordVariantFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_recordVariantField
	return p
}

func InitEmptyRecordVariantFieldContext(p *RecordVariantFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_recordVariantField
}

func (*RecordVariantFieldContext) IsRecordVariantFieldContext() {}

func NewRecordVariantFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordVariantFieldContext {
	var p = new(RecordVariantFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_recordVariantField

	return p
}

func (s *RecordVariantFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordVariantFieldContext) IdentList() IIdentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentListContext)
}

func (s *RecordVariantFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(DelphiParserCOLON, 0)
}

func (s *RecordVariantFieldContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *RecordVariantFieldContext) AllHintingDirective() []IHintingDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintingDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IHintingDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintingDirectiveContext); ok {
			tst[i] = t.(IHintingDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *RecordVariantFieldContext) HintingDirective(i int) IHintingDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintingDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintingDirectiveContext)
}

func (s *RecordVariantFieldContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *RecordVariantFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordVariantFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordVariantFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterRecordVariantField(s)
	}
}

func (s *RecordVariantFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitRecordVariantField(s)
	}
}

func (p *DelphiParser) RecordVariantField() (localctx IRecordVariantFieldContext) {
	localctx = NewRecordVariantFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, DelphiParserRULE_recordVariantField)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1063)
		p.IdentList()
	}
	{
		p.SetState(1064)
		p.Match(DelphiParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1065)
		p.TypeDecl()
	}
	p.SetState(1069)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&576461302059253761) != 0 {
		{
			p.SetState(1066)
			p.HintingDirective()
		}

		p.SetState(1071)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1073)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserSEMI {
		{
			p.SetState(1072)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordVariantSectionContext is an interface to support dynamic dispatch.
type IRecordVariantSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	TypeDecl() ITypeDeclContext
	OF() antlr.TerminalNode
	AllRecordVariant() []IRecordVariantContext
	RecordVariant(i int) IRecordVariantContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	Ident() IIdentContext
	COLON() antlr.TerminalNode

	// IsRecordVariantSectionContext differentiates from other interfaces.
	IsRecordVariantSectionContext()
}

type RecordVariantSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordVariantSectionContext() *RecordVariantSectionContext {
	var p = new(RecordVariantSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_recordVariantSection
	return p
}

func InitEmptyRecordVariantSectionContext(p *RecordVariantSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_recordVariantSection
}

func (*RecordVariantSectionContext) IsRecordVariantSectionContext() {}

func NewRecordVariantSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordVariantSectionContext {
	var p = new(RecordVariantSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_recordVariantSection

	return p
}

func (s *RecordVariantSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordVariantSectionContext) CASE() antlr.TerminalNode {
	return s.GetToken(DelphiParserCASE, 0)
}

func (s *RecordVariantSectionContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *RecordVariantSectionContext) OF() antlr.TerminalNode {
	return s.GetToken(DelphiParserOF, 0)
}

func (s *RecordVariantSectionContext) AllRecordVariant() []IRecordVariantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordVariantContext); ok {
			len++
		}
	}

	tst := make([]IRecordVariantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordVariantContext); ok {
			tst[i] = t.(IRecordVariantContext)
			i++
		}
	}

	return tst
}

func (s *RecordVariantSectionContext) RecordVariant(i int) IRecordVariantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordVariantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordVariantContext)
}

func (s *RecordVariantSectionContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserSEMI)
}

func (s *RecordVariantSectionContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, i)
}

func (s *RecordVariantSectionContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *RecordVariantSectionContext) COLON() antlr.TerminalNode {
	return s.GetToken(DelphiParserCOLON, 0)
}

func (s *RecordVariantSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordVariantSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordVariantSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterRecordVariantSection(s)
	}
}

func (s *RecordVariantSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitRecordVariantSection(s)
	}
}

func (p *DelphiParser) RecordVariantSection() (localctx IRecordVariantSectionContext) {
	localctx = NewRecordVariantSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, DelphiParserRULE_recordVariantSection)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1075)
		p.Match(DelphiParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1079)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1076)
			p.Ident()
		}
		{
			p.SetState(1077)
			p.Match(DelphiParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1081)
		p.TypeDecl()
	}
	{
		p.SetState(1082)
		p.Match(DelphiParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1085)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserADD, DelphiParserAND, DelphiParserANSISTRING, DelphiParserAS, DelphiParserAT, DelphiParserBREAK, DelphiParserCONTAINS, DelphiParserCONTINUE, DelphiParserDEFAULT, DelphiParserDIV, DelphiParserEXIT, DelphiParserEXPORT, DelphiParserFINAL, DelphiParserFUNCTION, DelphiParserIMPLEMENTS, DelphiParserIN, DelphiParserINDEX, DelphiParserINHERITED, DelphiParserIS, DelphiParserLOCAL, DelphiParserMESSAGE, DelphiParserMOD, DelphiParserNAME, DelphiParserNIL, DelphiParserNOT, DelphiParserOBJECT, DelphiParserOPERATOR, DelphiParserOR, DelphiParserOUT, DelphiParserPOINTER, DelphiParserPROCEDURE, DelphiParserREAD, DelphiParserREADONLY, DelphiParserREFERENCE, DelphiParserREGISTER, DelphiParserREMOVE, DelphiParserSHL, DelphiParserSHR, DelphiParserSTORED, DelphiParserSTRICT, DelphiParserSTRING, DelphiParserVARIANT, DelphiParserWRITE, DelphiParserXOR, DelphiParserFALSE, DelphiParserTRUE, DelphiParserPLUS, DelphiParserMINUS, DelphiParserSTAR, DelphiParserSLASH, DelphiParserCOMMA, DelphiParserCOLON, DelphiParserEQUAL, DelphiParserNOT_EQUAL, DelphiParserLT, DelphiParserLE, DelphiParserGE, DelphiParserGT, DelphiParserLPAREN, DelphiParserLBRACK, DelphiParserPOINTER2, DelphiParserAT2, DelphiParserDOT, DelphiParserAMBER, DelphiParserDOUBLEAT, DelphiParserTkIdentifier, DelphiParserTkIntNum, DelphiParserTkRealNum, DelphiParserTkHexNum, DelphiParserTkAsmHexNum, DelphiParserQuotedString, DelphiParserControlString:
		{
			p.SetState(1083)
			p.RecordVariant()
		}

	case DelphiParserSEMI:
		{
			p.SetState(1084)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1091)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2576640216473309552) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2306854608771758511) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&4017210874294959613) != 0) {
		p.SetState(1089)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DelphiParserADD, DelphiParserAND, DelphiParserANSISTRING, DelphiParserAS, DelphiParserAT, DelphiParserBREAK, DelphiParserCONTAINS, DelphiParserCONTINUE, DelphiParserDEFAULT, DelphiParserDIV, DelphiParserEXIT, DelphiParserEXPORT, DelphiParserFINAL, DelphiParserFUNCTION, DelphiParserIMPLEMENTS, DelphiParserIN, DelphiParserINDEX, DelphiParserINHERITED, DelphiParserIS, DelphiParserLOCAL, DelphiParserMESSAGE, DelphiParserMOD, DelphiParserNAME, DelphiParserNIL, DelphiParserNOT, DelphiParserOBJECT, DelphiParserOPERATOR, DelphiParserOR, DelphiParserOUT, DelphiParserPOINTER, DelphiParserPROCEDURE, DelphiParserREAD, DelphiParserREADONLY, DelphiParserREFERENCE, DelphiParserREGISTER, DelphiParserREMOVE, DelphiParserSHL, DelphiParserSHR, DelphiParserSTORED, DelphiParserSTRICT, DelphiParserSTRING, DelphiParserVARIANT, DelphiParserWRITE, DelphiParserXOR, DelphiParserFALSE, DelphiParserTRUE, DelphiParserPLUS, DelphiParserMINUS, DelphiParserSTAR, DelphiParserSLASH, DelphiParserCOMMA, DelphiParserCOLON, DelphiParserEQUAL, DelphiParserNOT_EQUAL, DelphiParserLT, DelphiParserLE, DelphiParserGE, DelphiParserGT, DelphiParserLPAREN, DelphiParserLBRACK, DelphiParserPOINTER2, DelphiParserAT2, DelphiParserDOT, DelphiParserAMBER, DelphiParserDOUBLEAT, DelphiParserTkIdentifier, DelphiParserTkIntNum, DelphiParserTkRealNum, DelphiParserTkHexNum, DelphiParserTkAsmHexNum, DelphiParserQuotedString, DelphiParserControlString:
			{
				p.SetState(1087)
				p.RecordVariant()
			}

		case DelphiParserSEMI:
			{
				p.SetState(1088)
				p.Match(DelphiParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1093)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordVariantContext is an interface to support dynamic dispatch.
type IRecordVariantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConstExpression() []IConstExpressionContext
	ConstExpression(i int) IConstExpressionContext
	COLON() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllRecordVariantField() []IRecordVariantFieldContext
	RecordVariantField(i int) IRecordVariantFieldContext

	// IsRecordVariantContext differentiates from other interfaces.
	IsRecordVariantContext()
}

type RecordVariantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordVariantContext() *RecordVariantContext {
	var p = new(RecordVariantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_recordVariant
	return p
}

func InitEmptyRecordVariantContext(p *RecordVariantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_recordVariant
}

func (*RecordVariantContext) IsRecordVariantContext() {}

func NewRecordVariantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordVariantContext {
	var p = new(RecordVariantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_recordVariant

	return p
}

func (s *RecordVariantContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordVariantContext) AllConstExpression() []IConstExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstExpressionContext); ok {
			len++
		}
	}

	tst := make([]IConstExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstExpressionContext); ok {
			tst[i] = t.(IConstExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RecordVariantContext) ConstExpression(i int) IConstExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstExpressionContext)
}

func (s *RecordVariantContext) COLON() antlr.TerminalNode {
	return s.GetToken(DelphiParserCOLON, 0)
}

func (s *RecordVariantContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserLPAREN, 0)
}

func (s *RecordVariantContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserRPAREN, 0)
}

func (s *RecordVariantContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserCOMMA)
}

func (s *RecordVariantContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserCOMMA, i)
}

func (s *RecordVariantContext) AllRecordVariantField() []IRecordVariantFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordVariantFieldContext); ok {
			len++
		}
	}

	tst := make([]IRecordVariantFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordVariantFieldContext); ok {
			tst[i] = t.(IRecordVariantFieldContext)
			i++
		}
	}

	return tst
}

func (s *RecordVariantContext) RecordVariantField(i int) IRecordVariantFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordVariantFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordVariantFieldContext)
}

func (s *RecordVariantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordVariantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordVariantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterRecordVariant(s)
	}
}

func (s *RecordVariantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitRecordVariant(s)
	}
}

func (p *DelphiParser) RecordVariant() (localctx IRecordVariantContext) {
	localctx = NewRecordVariantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, DelphiParserRULE_recordVariant)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1094)
		p.ConstExpression()
	}
	p.SetState(1099)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DelphiParserCOMMA {
		{
			p.SetState(1095)
			p.Match(DelphiParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1096)
			p.ConstExpression()
		}

		p.SetState(1101)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1102)
		p.Match(DelphiParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1103)
		p.Match(DelphiParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1107)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&90090271942938704) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2306828220488493323) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&18014400656965633) != 0) {
		{
			p.SetState(1104)
			p.RecordVariantField()
		}

		p.SetState(1109)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1110)
		p.Match(DelphiParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordHelperDeclContext is an interface to support dynamic dispatch.
type IRecordHelperDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECORD() antlr.TerminalNode
	HELPER() antlr.TerminalNode
	FOR() antlr.TerminalNode
	TypeId() ITypeIdContext
	END() antlr.TerminalNode
	AllRecordHelperItem() []IRecordHelperItemContext
	RecordHelperItem(i int) IRecordHelperItemContext

	// IsRecordHelperDeclContext differentiates from other interfaces.
	IsRecordHelperDeclContext()
}

type RecordHelperDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordHelperDeclContext() *RecordHelperDeclContext {
	var p = new(RecordHelperDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_recordHelperDecl
	return p
}

func InitEmptyRecordHelperDeclContext(p *RecordHelperDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_recordHelperDecl
}

func (*RecordHelperDeclContext) IsRecordHelperDeclContext() {}

func NewRecordHelperDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordHelperDeclContext {
	var p = new(RecordHelperDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_recordHelperDecl

	return p
}

func (s *RecordHelperDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordHelperDeclContext) RECORD() antlr.TerminalNode {
	return s.GetToken(DelphiParserRECORD, 0)
}

func (s *RecordHelperDeclContext) HELPER() antlr.TerminalNode {
	return s.GetToken(DelphiParserHELPER, 0)
}

func (s *RecordHelperDeclContext) FOR() antlr.TerminalNode {
	return s.GetToken(DelphiParserFOR, 0)
}

func (s *RecordHelperDeclContext) TypeId() ITypeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdContext)
}

func (s *RecordHelperDeclContext) END() antlr.TerminalNode {
	return s.GetToken(DelphiParserEND, 0)
}

func (s *RecordHelperDeclContext) AllRecordHelperItem() []IRecordHelperItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordHelperItemContext); ok {
			len++
		}
	}

	tst := make([]IRecordHelperItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordHelperItemContext); ok {
			tst[i] = t.(IRecordHelperItemContext)
			i++
		}
	}

	return tst
}

func (s *RecordHelperDeclContext) RecordHelperItem(i int) IRecordHelperItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordHelperItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordHelperItemContext)
}

func (s *RecordHelperDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordHelperDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordHelperDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterRecordHelperDecl(s)
	}
}

func (s *RecordHelperDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitRecordHelperDecl(s)
	}
}

func (p *DelphiParser) RecordHelperDecl() (localctx IRecordHelperDeclContext) {
	localctx = NewRecordHelperDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, DelphiParserRULE_recordHelperDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1112)
		p.Match(DelphiParserRECORD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1113)
		p.Match(DelphiParserHELPER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1114)
		p.Match(DelphiParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1115)
		p.TypeId()
	}
	p.SetState(1119)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&562949988294658) != 0) || ((int64((_la-75)) & ^0x3f) == 0 && ((int64(1)<<(_la-75))&137439079425) != 0) {
		{
			p.SetState(1116)
			p.RecordHelperItem()
		}

		p.SetState(1121)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1122)
		p.Match(DelphiParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordHelperItemContext is an interface to support dynamic dispatch.
type IRecordHelperItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Visibility() IVisibilityContext
	ClassMethod() IClassMethodContext
	ClassProperty() IClassPropertyContext

	// IsRecordHelperItemContext differentiates from other interfaces.
	IsRecordHelperItemContext()
}

type RecordHelperItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordHelperItemContext() *RecordHelperItemContext {
	var p = new(RecordHelperItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_recordHelperItem
	return p
}

func InitEmptyRecordHelperItemContext(p *RecordHelperItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_recordHelperItem
}

func (*RecordHelperItemContext) IsRecordHelperItemContext() {}

func NewRecordHelperItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordHelperItemContext {
	var p = new(RecordHelperItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_recordHelperItem

	return p
}

func (s *RecordHelperItemContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordHelperItemContext) Visibility() IVisibilityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVisibilityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *RecordHelperItemContext) ClassMethod() IClassMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassMethodContext)
}

func (s *RecordHelperItemContext) ClassProperty() IClassPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassPropertyContext)
}

func (s *RecordHelperItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordHelperItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordHelperItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterRecordHelperItem(s)
	}
}

func (s *RecordHelperItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitRecordHelperItem(s)
	}
}

func (p *DelphiParser) RecordHelperItem() (localctx IRecordHelperItemContext) {
	localctx = NewRecordHelperItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, DelphiParserRULE_recordHelperItem)
	p.SetState(1127)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1124)
			p.Visibility()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1125)
			p.ClassMethod()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1126)
			p.ClassProperty()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassMethodContext is an interface to support dynamic dispatch.
type IClassMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MethodKey() IMethodKeyContext
	Ident() IIdentContext
	SEMI() antlr.TerminalNode
	AllCustomAttribute() []ICustomAttributeContext
	CustomAttribute(i int) ICustomAttributeContext
	CLASS() antlr.TerminalNode
	GenericDefinition() IGenericDefinitionContext
	FormalParameterSection() IFormalParameterSectionContext
	AllMethodDirective() []IMethodDirectiveContext
	MethodDirective(i int) IMethodDirectiveContext
	FUNCTION() antlr.TerminalNode
	COLON() antlr.TerminalNode
	TypeDecl() ITypeDeclContext
	OPERATOR() antlr.TerminalNode

	// IsClassMethodContext differentiates from other interfaces.
	IsClassMethodContext()
}

type ClassMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassMethodContext() *ClassMethodContext {
	var p = new(ClassMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classMethod
	return p
}

func InitEmptyClassMethodContext(p *ClassMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classMethod
}

func (*ClassMethodContext) IsClassMethodContext() {}

func NewClassMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassMethodContext {
	var p = new(ClassMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_classMethod

	return p
}

func (s *ClassMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassMethodContext) MethodKey() IMethodKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodKeyContext)
}

func (s *ClassMethodContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *ClassMethodContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *ClassMethodContext) AllCustomAttribute() []ICustomAttributeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICustomAttributeContext); ok {
			len++
		}
	}

	tst := make([]ICustomAttributeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICustomAttributeContext); ok {
			tst[i] = t.(ICustomAttributeContext)
			i++
		}
	}

	return tst
}

func (s *ClassMethodContext) CustomAttribute(i int) ICustomAttributeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomAttributeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomAttributeContext)
}

func (s *ClassMethodContext) CLASS() antlr.TerminalNode {
	return s.GetToken(DelphiParserCLASS, 0)
}

func (s *ClassMethodContext) GenericDefinition() IGenericDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericDefinitionContext)
}

func (s *ClassMethodContext) FormalParameterSection() IFormalParameterSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterSectionContext)
}

func (s *ClassMethodContext) AllMethodDirective() []IMethodDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMethodDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IMethodDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMethodDirectiveContext); ok {
			tst[i] = t.(IMethodDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *ClassMethodContext) MethodDirective(i int) IMethodDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDirectiveContext)
}

func (s *ClassMethodContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DelphiParserFUNCTION, 0)
}

func (s *ClassMethodContext) COLON() antlr.TerminalNode {
	return s.GetToken(DelphiParserCOLON, 0)
}

func (s *ClassMethodContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *ClassMethodContext) OPERATOR() antlr.TerminalNode {
	return s.GetToken(DelphiParserOPERATOR, 0)
}

func (s *ClassMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterClassMethod(s)
	}
}

func (s *ClassMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitClassMethod(s)
	}
}

func (p *DelphiParser) ClassMethod() (localctx IClassMethodContext) {
	localctx = NewClassMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, DelphiParserRULE_classMethod)
	var _la int

	var _alt int

	p.SetState(1197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 137, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1130)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserT__0 {
			{
				p.SetState(1129)
				p.CustomAttribute()
			}

		}
		p.SetState(1133)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserCLASS {
			{
				p.SetState(1132)
				p.Match(DelphiParserCLASS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1135)
			p.MethodKey()
		}
		{
			p.SetState(1136)
			p.Ident()
		}
		p.SetState(1138)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserLT {
			{
				p.SetState(1137)
				p.GenericDefinition()
			}

		}
		p.SetState(1141)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserLPAREN {
			{
				p.SetState(1140)
				p.FormalParameterSection()
			}

		}
		{
			p.SetState(1143)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1147)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1144)
					p.MethodDirective()
				}

			}
			p.SetState(1149)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1151)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserT__0 {
			{
				p.SetState(1150)
				p.CustomAttribute()
			}

		}
		p.SetState(1154)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserCLASS {
			{
				p.SetState(1153)
				p.Match(DelphiParserCLASS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1156)
			p.Match(DelphiParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1157)
			p.Ident()
		}
		p.SetState(1159)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserLT {
			{
				p.SetState(1158)
				p.GenericDefinition()
			}

		}
		p.SetState(1162)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserLPAREN {
			{
				p.SetState(1161)
				p.FormalParameterSection()
			}

		}
		{
			p.SetState(1164)
			p.Match(DelphiParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1166)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserT__0 {
			{
				p.SetState(1165)
				p.CustomAttribute()
			}

		}
		{
			p.SetState(1168)
			p.TypeDecl()
		}
		{
			p.SetState(1169)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1173)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1170)
					p.MethodDirective()
				}

			}
			p.SetState(1175)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1177)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserT__0 {
			{
				p.SetState(1176)
				p.CustomAttribute()
			}

		}
		p.SetState(1180)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserCLASS {
			{
				p.SetState(1179)
				p.Match(DelphiParserCLASS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1182)
			p.Match(DelphiParserOPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1183)
			p.Ident()
		}
		p.SetState(1185)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserLT {
			{
				p.SetState(1184)
				p.GenericDefinition()
			}

		}
		p.SetState(1188)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserLPAREN {
			{
				p.SetState(1187)
				p.FormalParameterSection()
			}

		}
		{
			p.SetState(1190)
			p.Match(DelphiParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1192)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserT__0 {
			{
				p.SetState(1191)
				p.CustomAttribute()
			}

		}
		{
			p.SetState(1194)
			p.TypeDecl()
		}
		{
			p.SetState(1195)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassFieldContext is an interface to support dynamic dispatch.
type IClassFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentList() IIdentListContext
	COLON() antlr.TerminalNode
	TypeDecl() ITypeDeclContext
	SEMI() antlr.TerminalNode
	CustomAttribute() ICustomAttributeContext
	AllHintingDirective() []IHintingDirectiveContext
	HintingDirective(i int) IHintingDirectiveContext

	// IsClassFieldContext differentiates from other interfaces.
	IsClassFieldContext()
}

type ClassFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassFieldContext() *ClassFieldContext {
	var p = new(ClassFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classField
	return p
}

func InitEmptyClassFieldContext(p *ClassFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classField
}

func (*ClassFieldContext) IsClassFieldContext() {}

func NewClassFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassFieldContext {
	var p = new(ClassFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_classField

	return p
}

func (s *ClassFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassFieldContext) IdentList() IIdentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentListContext)
}

func (s *ClassFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(DelphiParserCOLON, 0)
}

func (s *ClassFieldContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *ClassFieldContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *ClassFieldContext) CustomAttribute() ICustomAttributeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomAttributeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomAttributeContext)
}

func (s *ClassFieldContext) AllHintingDirective() []IHintingDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintingDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IHintingDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintingDirectiveContext); ok {
			tst[i] = t.(IHintingDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *ClassFieldContext) HintingDirective(i int) IHintingDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintingDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintingDirectiveContext)
}

func (s *ClassFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterClassField(s)
	}
}

func (s *ClassFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitClassField(s)
	}
}

func (p *DelphiParser) ClassField() (localctx IClassFieldContext) {
	localctx = NewClassFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, DelphiParserRULE_classField)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserT__0 {
		{
			p.SetState(1199)
			p.CustomAttribute()
		}

	}
	{
		p.SetState(1202)
		p.IdentList()
	}
	{
		p.SetState(1203)
		p.Match(DelphiParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1204)
		p.TypeDecl()
	}
	{
		p.SetState(1205)
		p.Match(DelphiParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1209)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&576461302059253761) != 0 {
		{
			p.SetState(1206)
			p.HintingDirective()
		}

		p.SetState(1211)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassPropertyContext is an interface to support dynamic dispatch.
type IClassPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROPERTY() antlr.TerminalNode
	Ident() IIdentContext
	SEMI() antlr.TerminalNode
	CustomAttribute() ICustomAttributeContext
	CLASS() antlr.TerminalNode
	ClassPropertyArray() IClassPropertyArrayContext
	COLON() antlr.TerminalNode
	GenericTypeIdent() IGenericTypeIdentContext
	ClassPropertyIndex() IClassPropertyIndexContext
	AllClassPropertySpecifier() []IClassPropertySpecifierContext
	ClassPropertySpecifier(i int) IClassPropertySpecifierContext
	AllClassPropertyEndSpecifier() []IClassPropertyEndSpecifierContext
	ClassPropertyEndSpecifier(i int) IClassPropertyEndSpecifierContext

	// IsClassPropertyContext differentiates from other interfaces.
	IsClassPropertyContext()
}

type ClassPropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassPropertyContext() *ClassPropertyContext {
	var p = new(ClassPropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classProperty
	return p
}

func InitEmptyClassPropertyContext(p *ClassPropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classProperty
}

func (*ClassPropertyContext) IsClassPropertyContext() {}

func NewClassPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassPropertyContext {
	var p = new(ClassPropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_classProperty

	return p
}

func (s *ClassPropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassPropertyContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(DelphiParserPROPERTY, 0)
}

func (s *ClassPropertyContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *ClassPropertyContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *ClassPropertyContext) CustomAttribute() ICustomAttributeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomAttributeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomAttributeContext)
}

func (s *ClassPropertyContext) CLASS() antlr.TerminalNode {
	return s.GetToken(DelphiParserCLASS, 0)
}

func (s *ClassPropertyContext) ClassPropertyArray() IClassPropertyArrayContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassPropertyArrayContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassPropertyArrayContext)
}

func (s *ClassPropertyContext) COLON() antlr.TerminalNode {
	return s.GetToken(DelphiParserCOLON, 0)
}

func (s *ClassPropertyContext) GenericTypeIdent() IGenericTypeIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericTypeIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericTypeIdentContext)
}

func (s *ClassPropertyContext) ClassPropertyIndex() IClassPropertyIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassPropertyIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassPropertyIndexContext)
}

func (s *ClassPropertyContext) AllClassPropertySpecifier() []IClassPropertySpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassPropertySpecifierContext); ok {
			len++
		}
	}

	tst := make([]IClassPropertySpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassPropertySpecifierContext); ok {
			tst[i] = t.(IClassPropertySpecifierContext)
			i++
		}
	}

	return tst
}

func (s *ClassPropertyContext) ClassPropertySpecifier(i int) IClassPropertySpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassPropertySpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassPropertySpecifierContext)
}

func (s *ClassPropertyContext) AllClassPropertyEndSpecifier() []IClassPropertyEndSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassPropertyEndSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IClassPropertyEndSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassPropertyEndSpecifierContext); ok {
			tst[i] = t.(IClassPropertyEndSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *ClassPropertyContext) ClassPropertyEndSpecifier(i int) IClassPropertyEndSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassPropertyEndSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassPropertyEndSpecifierContext)
}

func (s *ClassPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterClassProperty(s)
	}
}

func (s *ClassPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitClassProperty(s)
	}
}

func (p *DelphiParser) ClassProperty() (localctx IClassPropertyContext) {
	localctx = NewClassPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, DelphiParserRULE_classProperty)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1213)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserT__0 {
		{
			p.SetState(1212)
			p.CustomAttribute()
		}

	}
	p.SetState(1216)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserCLASS {
		{
			p.SetState(1215)
			p.Match(DelphiParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1218)
		p.Match(DelphiParserPROPERTY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1219)
		p.Ident()
	}
	p.SetState(1221)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserLBRACK {
		{
			p.SetState(1220)
			p.ClassPropertyArray()
		}

	}
	p.SetState(1225)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserCOLON {
		{
			p.SetState(1223)
			p.Match(DelphiParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1224)
			p.GenericTypeIdent()
		}

	}
	p.SetState(1228)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserINDEX {
		{
			p.SetState(1227)
			p.ClassPropertyIndex()
		}

	}
	p.SetState(1233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&18014398584979456) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&1729384455958691841) != 0) {
		{
			p.SetState(1230)
			p.ClassPropertySpecifier()
		}

		p.SetState(1235)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1236)
		p.Match(DelphiParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1240)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1237)
				p.ClassPropertyEndSpecifier()
			}

		}
		p.SetState(1242)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassPropertyArrayContext is an interface to support dynamic dispatch.
type IClassPropertyArrayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext
	RBRACK() antlr.TerminalNode

	// IsClassPropertyArrayContext differentiates from other interfaces.
	IsClassPropertyArrayContext()
}

type ClassPropertyArrayContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassPropertyArrayContext() *ClassPropertyArrayContext {
	var p = new(ClassPropertyArrayContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classPropertyArray
	return p
}

func InitEmptyClassPropertyArrayContext(p *ClassPropertyArrayContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classPropertyArray
}

func (*ClassPropertyArrayContext) IsClassPropertyArrayContext() {}

func NewClassPropertyArrayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassPropertyArrayContext {
	var p = new(ClassPropertyArrayContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_classPropertyArray

	return p
}

func (s *ClassPropertyArrayContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassPropertyArrayContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(DelphiParserLBRACK, 0)
}

func (s *ClassPropertyArrayContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ClassPropertyArrayContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(DelphiParserRBRACK, 0)
}

func (s *ClassPropertyArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassPropertyArrayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassPropertyArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterClassPropertyArray(s)
	}
}

func (s *ClassPropertyArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitClassPropertyArray(s)
	}
}

func (p *DelphiParser) ClassPropertyArray() (localctx IClassPropertyArrayContext) {
	localctx = NewClassPropertyArrayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, DelphiParserRULE_classPropertyArray)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1243)
		p.Match(DelphiParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1244)
		p.FormalParameterList()
	}
	{
		p.SetState(1245)
		p.Match(DelphiParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassPropertyIndexContext is an interface to support dynamic dispatch.
type IClassPropertyIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INDEX() antlr.TerminalNode
	Expression() IExpressionContext
	SEMI() antlr.TerminalNode

	// IsClassPropertyIndexContext differentiates from other interfaces.
	IsClassPropertyIndexContext()
}

type ClassPropertyIndexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassPropertyIndexContext() *ClassPropertyIndexContext {
	var p = new(ClassPropertyIndexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classPropertyIndex
	return p
}

func InitEmptyClassPropertyIndexContext(p *ClassPropertyIndexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classPropertyIndex
}

func (*ClassPropertyIndexContext) IsClassPropertyIndexContext() {}

func NewClassPropertyIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassPropertyIndexContext {
	var p = new(ClassPropertyIndexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_classPropertyIndex

	return p
}

func (s *ClassPropertyIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassPropertyIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DelphiParserINDEX, 0)
}

func (s *ClassPropertyIndexContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ClassPropertyIndexContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *ClassPropertyIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassPropertyIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassPropertyIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterClassPropertyIndex(s)
	}
}

func (s *ClassPropertyIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitClassPropertyIndex(s)
	}
}

func (p *DelphiParser) ClassPropertyIndex() (localctx IClassPropertyIndexContext) {
	localctx = NewClassPropertyIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, DelphiParserRULE_classPropertyIndex)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1247)
		p.Match(DelphiParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1248)
		p.Expression()
	}
	p.SetState(1250)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1249)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassPropertySpecifierContext is an interface to support dynamic dispatch.
type IClassPropertySpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassPropertyReadWrite() IClassPropertyReadWriteContext
	ClassPropertyDispInterface() IClassPropertyDispInterfaceContext
	STORED() antlr.TerminalNode
	Expression() IExpressionContext
	DEFAULT() antlr.TerminalNode
	NODEFAULT() antlr.TerminalNode
	IMPLEMENTS() antlr.TerminalNode
	TypeId() ITypeIdContext

	// IsClassPropertySpecifierContext differentiates from other interfaces.
	IsClassPropertySpecifierContext()
}

type ClassPropertySpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassPropertySpecifierContext() *ClassPropertySpecifierContext {
	var p = new(ClassPropertySpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classPropertySpecifier
	return p
}

func InitEmptyClassPropertySpecifierContext(p *ClassPropertySpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classPropertySpecifier
}

func (*ClassPropertySpecifierContext) IsClassPropertySpecifierContext() {}

func NewClassPropertySpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassPropertySpecifierContext {
	var p = new(ClassPropertySpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_classPropertySpecifier

	return p
}

func (s *ClassPropertySpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassPropertySpecifierContext) ClassPropertyReadWrite() IClassPropertyReadWriteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassPropertyReadWriteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassPropertyReadWriteContext)
}

func (s *ClassPropertySpecifierContext) ClassPropertyDispInterface() IClassPropertyDispInterfaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassPropertyDispInterfaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassPropertyDispInterfaceContext)
}

func (s *ClassPropertySpecifierContext) STORED() antlr.TerminalNode {
	return s.GetToken(DelphiParserSTORED, 0)
}

func (s *ClassPropertySpecifierContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ClassPropertySpecifierContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DelphiParserDEFAULT, 0)
}

func (s *ClassPropertySpecifierContext) NODEFAULT() antlr.TerminalNode {
	return s.GetToken(DelphiParserNODEFAULT, 0)
}

func (s *ClassPropertySpecifierContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(DelphiParserIMPLEMENTS, 0)
}

func (s *ClassPropertySpecifierContext) TypeId() ITypeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdContext)
}

func (s *ClassPropertySpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassPropertySpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassPropertySpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterClassPropertySpecifier(s)
	}
}

func (s *ClassPropertySpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitClassPropertySpecifier(s)
	}
}

func (p *DelphiParser) ClassPropertySpecifier() (localctx IClassPropertySpecifierContext) {
	localctx = NewClassPropertySpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, DelphiParserRULE_classPropertySpecifier)
	var _la int

	p.SetState(1261)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1252)
			p.ClassPropertyReadWrite()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1253)
			p.ClassPropertyDispInterface()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1254)
			p.Match(DelphiParserSTORED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1255)
			p.Expression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1256)
			p.Match(DelphiParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1257)
			p.Expression()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1258)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DelphiParserDEFAULT || _la == DelphiParserNODEFAULT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1259)
			p.Match(DelphiParserIMPLEMENTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1260)
			p.TypeId()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassPropertyEndSpecifierContext is an interface to support dynamic dispatch.
type IClassPropertyEndSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STORED() antlr.TerminalNode
	Expression() IExpressionContext
	SEMI() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	NODEFAULT() antlr.TerminalNode

	// IsClassPropertyEndSpecifierContext differentiates from other interfaces.
	IsClassPropertyEndSpecifierContext()
}

type ClassPropertyEndSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassPropertyEndSpecifierContext() *ClassPropertyEndSpecifierContext {
	var p = new(ClassPropertyEndSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classPropertyEndSpecifier
	return p
}

func InitEmptyClassPropertyEndSpecifierContext(p *ClassPropertyEndSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classPropertyEndSpecifier
}

func (*ClassPropertyEndSpecifierContext) IsClassPropertyEndSpecifierContext() {}

func NewClassPropertyEndSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassPropertyEndSpecifierContext {
	var p = new(ClassPropertyEndSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_classPropertyEndSpecifier

	return p
}

func (s *ClassPropertyEndSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassPropertyEndSpecifierContext) STORED() antlr.TerminalNode {
	return s.GetToken(DelphiParserSTORED, 0)
}

func (s *ClassPropertyEndSpecifierContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ClassPropertyEndSpecifierContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *ClassPropertyEndSpecifierContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DelphiParserDEFAULT, 0)
}

func (s *ClassPropertyEndSpecifierContext) NODEFAULT() antlr.TerminalNode {
	return s.GetToken(DelphiParserNODEFAULT, 0)
}

func (s *ClassPropertyEndSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassPropertyEndSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassPropertyEndSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterClassPropertyEndSpecifier(s)
	}
}

func (s *ClassPropertyEndSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitClassPropertyEndSpecifier(s)
	}
}

func (p *DelphiParser) ClassPropertyEndSpecifier() (localctx IClassPropertyEndSpecifierContext) {
	localctx = NewClassPropertyEndSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, DelphiParserRULE_classPropertyEndSpecifier)
	p.SetState(1275)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 149, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1263)
			p.Match(DelphiParserSTORED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1264)
			p.Expression()
		}
		{
			p.SetState(1265)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1267)
			p.Match(DelphiParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1268)
			p.Expression()
		}
		{
			p.SetState(1269)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1271)
			p.Match(DelphiParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1272)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1273)
			p.Match(DelphiParserNODEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1274)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassPropertyReadWriteContext is an interface to support dynamic dispatch.
type IClassPropertyReadWriteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	QualifiedIdent() IQualifiedIdentContext
	LBRACK() antlr.TerminalNode
	Expression() IExpressionContext
	RBRACK() antlr.TerminalNode
	WRITE() antlr.TerminalNode

	// IsClassPropertyReadWriteContext differentiates from other interfaces.
	IsClassPropertyReadWriteContext()
}

type ClassPropertyReadWriteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassPropertyReadWriteContext() *ClassPropertyReadWriteContext {
	var p = new(ClassPropertyReadWriteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classPropertyReadWrite
	return p
}

func InitEmptyClassPropertyReadWriteContext(p *ClassPropertyReadWriteContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classPropertyReadWrite
}

func (*ClassPropertyReadWriteContext) IsClassPropertyReadWriteContext() {}

func NewClassPropertyReadWriteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassPropertyReadWriteContext {
	var p = new(ClassPropertyReadWriteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_classPropertyReadWrite

	return p
}

func (s *ClassPropertyReadWriteContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassPropertyReadWriteContext) READ() antlr.TerminalNode {
	return s.GetToken(DelphiParserREAD, 0)
}

func (s *ClassPropertyReadWriteContext) QualifiedIdent() IQualifiedIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentContext)
}

func (s *ClassPropertyReadWriteContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(DelphiParserLBRACK, 0)
}

func (s *ClassPropertyReadWriteContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ClassPropertyReadWriteContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(DelphiParserRBRACK, 0)
}

func (s *ClassPropertyReadWriteContext) WRITE() antlr.TerminalNode {
	return s.GetToken(DelphiParserWRITE, 0)
}

func (s *ClassPropertyReadWriteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassPropertyReadWriteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassPropertyReadWriteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterClassPropertyReadWrite(s)
	}
}

func (s *ClassPropertyReadWriteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitClassPropertyReadWrite(s)
	}
}

func (p *DelphiParser) ClassPropertyReadWrite() (localctx IClassPropertyReadWriteContext) {
	localctx = NewClassPropertyReadWriteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, DelphiParserRULE_classPropertyReadWrite)
	var _la int

	p.SetState(1293)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserREAD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1277)
			p.Match(DelphiParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1278)
			p.QualifiedIdent()
		}
		p.SetState(1283)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserLBRACK {
			{
				p.SetState(1279)
				p.Match(DelphiParserLBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1280)
				p.Expression()
			}
			{
				p.SetState(1281)
				p.Match(DelphiParserRBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DelphiParserWRITE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1285)
			p.Match(DelphiParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1286)
			p.QualifiedIdent()
		}
		p.SetState(1291)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserLBRACK {
			{
				p.SetState(1287)
				p.Match(DelphiParserLBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1288)
				p.Expression()
			}
			{
				p.SetState(1289)
				p.Match(DelphiParserRBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassPropertyDispInterfaceContext is an interface to support dynamic dispatch.
type IClassPropertyDispInterfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READONLY() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	WRITEONLY() antlr.TerminalNode
	DispIDDirective() IDispIDDirectiveContext

	// IsClassPropertyDispInterfaceContext differentiates from other interfaces.
	IsClassPropertyDispInterfaceContext()
}

type ClassPropertyDispInterfaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassPropertyDispInterfaceContext() *ClassPropertyDispInterfaceContext {
	var p = new(ClassPropertyDispInterfaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classPropertyDispInterface
	return p
}

func InitEmptyClassPropertyDispInterfaceContext(p *ClassPropertyDispInterfaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_classPropertyDispInterface
}

func (*ClassPropertyDispInterfaceContext) IsClassPropertyDispInterfaceContext() {}

func NewClassPropertyDispInterfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassPropertyDispInterfaceContext {
	var p = new(ClassPropertyDispInterfaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_classPropertyDispInterface

	return p
}

func (s *ClassPropertyDispInterfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassPropertyDispInterfaceContext) READONLY() antlr.TerminalNode {
	return s.GetToken(DelphiParserREADONLY, 0)
}

func (s *ClassPropertyDispInterfaceContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *ClassPropertyDispInterfaceContext) WRITEONLY() antlr.TerminalNode {
	return s.GetToken(DelphiParserWRITEONLY, 0)
}

func (s *ClassPropertyDispInterfaceContext) DispIDDirective() IDispIDDirectiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDispIDDirectiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDispIDDirectiveContext)
}

func (s *ClassPropertyDispInterfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassPropertyDispInterfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassPropertyDispInterfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterClassPropertyDispInterface(s)
	}
}

func (s *ClassPropertyDispInterfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitClassPropertyDispInterface(s)
	}
}

func (p *DelphiParser) ClassPropertyDispInterface() (localctx IClassPropertyDispInterfaceContext) {
	localctx = NewClassPropertyDispInterfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, DelphiParserRULE_classPropertyDispInterface)
	p.SetState(1300)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserREADONLY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1295)
			p.Match(DelphiParserREADONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1296)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserWRITEONLY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1297)
			p.Match(DelphiParserWRITEONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1298)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserDISPID:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1299)
			p.DispIDDirective()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVisibilityContext is an interface to support dynamic dispatch.
type IVisibilityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROTECTED() antlr.TerminalNode
	STRICT() antlr.TerminalNode
	PRIVATE() antlr.TerminalNode
	PUBLIC() antlr.TerminalNode
	PUBLISHED() antlr.TerminalNode
	AUTOMATED() antlr.TerminalNode

	// IsVisibilityContext differentiates from other interfaces.
	IsVisibilityContext()
}

type VisibilityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVisibilityContext() *VisibilityContext {
	var p = new(VisibilityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_visibility
	return p
}

func InitEmptyVisibilityContext(p *VisibilityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_visibility
}

func (*VisibilityContext) IsVisibilityContext() {}

func NewVisibilityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VisibilityContext {
	var p = new(VisibilityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_visibility

	return p
}

func (s *VisibilityContext) GetParser() antlr.Parser { return s.parser }

func (s *VisibilityContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(DelphiParserPROTECTED, 0)
}

func (s *VisibilityContext) STRICT() antlr.TerminalNode {
	return s.GetToken(DelphiParserSTRICT, 0)
}

func (s *VisibilityContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(DelphiParserPRIVATE, 0)
}

func (s *VisibilityContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(DelphiParserPUBLIC, 0)
}

func (s *VisibilityContext) PUBLISHED() antlr.TerminalNode {
	return s.GetToken(DelphiParserPUBLISHED, 0)
}

func (s *VisibilityContext) AUTOMATED() antlr.TerminalNode {
	return s.GetToken(DelphiParserAUTOMATED, 0)
}

func (s *VisibilityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VisibilityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VisibilityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterVisibility(s)
	}
}

func (s *VisibilityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitVisibility(s)
	}
}

func (p *DelphiParser) Visibility() (localctx IVisibilityContext) {
	localctx = NewVisibilityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, DelphiParserRULE_visibility)
	var _la int

	p.SetState(1311)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 156, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1303)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserSTRICT {
			{
				p.SetState(1302)
				p.Match(DelphiParserSTRICT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1305)
			p.Match(DelphiParserPROTECTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1307)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserSTRICT {
			{
				p.SetState(1306)
				p.Match(DelphiParserSTRICT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1309)
			p.Match(DelphiParserPRIVATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1310)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DelphiParserAUTOMATED || _la == DelphiParserPUBLIC || _la == DelphiParserPUBLISHED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportedProcHeadingContext is an interface to support dynamic dispatch.
type IExportedProcHeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCEDURE() antlr.TerminalNode
	Ident() IIdentContext
	COLON() antlr.TerminalNode
	TypeDecl() ITypeDeclContext
	SEMI() antlr.TerminalNode
	FormalParameterSection() IFormalParameterSectionContext
	CustomAttribute() ICustomAttributeContext
	AllFunctionDirective() []IFunctionDirectiveContext
	FunctionDirective(i int) IFunctionDirectiveContext
	FUNCTION() antlr.TerminalNode

	// IsExportedProcHeadingContext differentiates from other interfaces.
	IsExportedProcHeadingContext()
}

type ExportedProcHeadingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportedProcHeadingContext() *ExportedProcHeadingContext {
	var p = new(ExportedProcHeadingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_exportedProcHeading
	return p
}

func InitEmptyExportedProcHeadingContext(p *ExportedProcHeadingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_exportedProcHeading
}

func (*ExportedProcHeadingContext) IsExportedProcHeadingContext() {}

func NewExportedProcHeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportedProcHeadingContext {
	var p = new(ExportedProcHeadingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_exportedProcHeading

	return p
}

func (s *ExportedProcHeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportedProcHeadingContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DelphiParserPROCEDURE, 0)
}

func (s *ExportedProcHeadingContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *ExportedProcHeadingContext) COLON() antlr.TerminalNode {
	return s.GetToken(DelphiParserCOLON, 0)
}

func (s *ExportedProcHeadingContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *ExportedProcHeadingContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *ExportedProcHeadingContext) FormalParameterSection() IFormalParameterSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterSectionContext)
}

func (s *ExportedProcHeadingContext) CustomAttribute() ICustomAttributeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomAttributeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomAttributeContext)
}

func (s *ExportedProcHeadingContext) AllFunctionDirective() []IFunctionDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IFunctionDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionDirectiveContext); ok {
			tst[i] = t.(IFunctionDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *ExportedProcHeadingContext) FunctionDirective(i int) IFunctionDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDirectiveContext)
}

func (s *ExportedProcHeadingContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DelphiParserFUNCTION, 0)
}

func (s *ExportedProcHeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportedProcHeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportedProcHeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterExportedProcHeading(s)
	}
}

func (s *ExportedProcHeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitExportedProcHeading(s)
	}
}

func (p *DelphiParser) ExportedProcHeading() (localctx IExportedProcHeadingContext) {
	localctx = NewExportedProcHeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, DelphiParserRULE_exportedProcHeading)
	var _la int

	var _alt int

	p.SetState(1342)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserPROCEDURE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1313)
			p.Match(DelphiParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1314)
			p.Ident()
		}
		p.SetState(1316)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserLPAREN {
			{
				p.SetState(1315)
				p.FormalParameterSection()
			}

		}
		{
			p.SetState(1318)
			p.Match(DelphiParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1320)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserT__0 {
			{
				p.SetState(1319)
				p.CustomAttribute()
			}

		}
		{
			p.SetState(1322)
			p.TypeDecl()
		}
		{
			p.SetState(1323)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1327)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1324)
					p.FunctionDirective()
				}

			}
			p.SetState(1329)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case DelphiParserFUNCTION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1330)
			p.Match(DelphiParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1331)
			p.Ident()
		}
		p.SetState(1333)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserLPAREN {
			{
				p.SetState(1332)
				p.FormalParameterSection()
			}

		}
		{
			p.SetState(1335)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1339)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1336)
					p.FunctionDirective()
				}

			}
			p.SetState(1341)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodDeclContext is an interface to support dynamic dispatch.
type IMethodDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MethodDeclHeading() IMethodDeclHeadingContext
	SEMI() antlr.TerminalNode
	AllMethodDirective() []IMethodDirectiveContext
	MethodDirective(i int) IMethodDirectiveContext
	MethodBody() IMethodBodyContext

	// IsMethodDeclContext differentiates from other interfaces.
	IsMethodDeclContext()
}

type MethodDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodDeclContext() *MethodDeclContext {
	var p = new(MethodDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_methodDecl
	return p
}

func InitEmptyMethodDeclContext(p *MethodDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_methodDecl
}

func (*MethodDeclContext) IsMethodDeclContext() {}

func NewMethodDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDeclContext {
	var p = new(MethodDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_methodDecl

	return p
}

func (s *MethodDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDeclContext) MethodDeclHeading() IMethodDeclHeadingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDeclHeadingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDeclHeadingContext)
}

func (s *MethodDeclContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *MethodDeclContext) AllMethodDirective() []IMethodDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMethodDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IMethodDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMethodDirectiveContext); ok {
			tst[i] = t.(IMethodDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *MethodDeclContext) MethodDirective(i int) IMethodDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDirectiveContext)
}

func (s *MethodDeclContext) MethodBody() IMethodBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodBodyContext)
}

func (s *MethodDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterMethodDecl(s)
	}
}

func (s *MethodDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitMethodDecl(s)
	}
}

func (p *DelphiParser) MethodDecl() (localctx IMethodDeclContext) {
	localctx = NewMethodDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, DelphiParserRULE_methodDecl)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1344)
		p.MethodDeclHeading()
	}
	{
		p.SetState(1345)
		p.Match(DelphiParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1349)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 163, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1346)
				p.MethodDirective()
			}

		}
		p.SetState(1351)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 163, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1353)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 164, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1352)
			p.MethodBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodDeclHeadingContext is an interface to support dynamic dispatch.
type IMethodDeclHeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MethodKey() IMethodKeyContext
	MethodName() IMethodNameContext
	AllCustomAttribute() []ICustomAttributeContext
	CustomAttribute(i int) ICustomAttributeContext
	CLASS() antlr.TerminalNode
	FormalParameterSection() IFormalParameterSectionContext
	FUNCTION() antlr.TerminalNode
	COLON() antlr.TerminalNode
	TypeDecl() ITypeDeclContext
	OPERATOR() antlr.TerminalNode

	// IsMethodDeclHeadingContext differentiates from other interfaces.
	IsMethodDeclHeadingContext()
}

type MethodDeclHeadingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodDeclHeadingContext() *MethodDeclHeadingContext {
	var p = new(MethodDeclHeadingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_methodDeclHeading
	return p
}

func InitEmptyMethodDeclHeadingContext(p *MethodDeclHeadingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_methodDeclHeading
}

func (*MethodDeclHeadingContext) IsMethodDeclHeadingContext() {}

func NewMethodDeclHeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDeclHeadingContext {
	var p = new(MethodDeclHeadingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_methodDeclHeading

	return p
}

func (s *MethodDeclHeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDeclHeadingContext) MethodKey() IMethodKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodKeyContext)
}

func (s *MethodDeclHeadingContext) MethodName() IMethodNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodNameContext)
}

func (s *MethodDeclHeadingContext) AllCustomAttribute() []ICustomAttributeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICustomAttributeContext); ok {
			len++
		}
	}

	tst := make([]ICustomAttributeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICustomAttributeContext); ok {
			tst[i] = t.(ICustomAttributeContext)
			i++
		}
	}

	return tst
}

func (s *MethodDeclHeadingContext) CustomAttribute(i int) ICustomAttributeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomAttributeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomAttributeContext)
}

func (s *MethodDeclHeadingContext) CLASS() antlr.TerminalNode {
	return s.GetToken(DelphiParserCLASS, 0)
}

func (s *MethodDeclHeadingContext) FormalParameterSection() IFormalParameterSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterSectionContext)
}

func (s *MethodDeclHeadingContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DelphiParserFUNCTION, 0)
}

func (s *MethodDeclHeadingContext) COLON() antlr.TerminalNode {
	return s.GetToken(DelphiParserCOLON, 0)
}

func (s *MethodDeclHeadingContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *MethodDeclHeadingContext) OPERATOR() antlr.TerminalNode {
	return s.GetToken(DelphiParserOPERATOR, 0)
}

func (s *MethodDeclHeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclHeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDeclHeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterMethodDeclHeading(s)
	}
}

func (s *MethodDeclHeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitMethodDeclHeading(s)
	}
}

func (p *DelphiParser) MethodDeclHeading() (localctx IMethodDeclHeadingContext) {
	localctx = NewMethodDeclHeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, DelphiParserRULE_methodDeclHeading)
	var _la int

	p.SetState(1400)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 177, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1356)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserT__0 {
			{
				p.SetState(1355)
				p.CustomAttribute()
			}

		}
		p.SetState(1359)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserCLASS {
			{
				p.SetState(1358)
				p.Match(DelphiParserCLASS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1361)
			p.MethodKey()
		}
		{
			p.SetState(1362)
			p.MethodName()
		}
		p.SetState(1364)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserLPAREN {
			{
				p.SetState(1363)
				p.FormalParameterSection()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1367)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserT__0 {
			{
				p.SetState(1366)
				p.CustomAttribute()
			}

		}
		p.SetState(1370)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserCLASS {
			{
				p.SetState(1369)
				p.Match(DelphiParserCLASS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1372)
			p.Match(DelphiParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1373)
			p.MethodName()
		}
		p.SetState(1375)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserLPAREN {
			{
				p.SetState(1374)
				p.FormalParameterSection()
			}

		}
		p.SetState(1382)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserCOLON {
			{
				p.SetState(1377)
				p.Match(DelphiParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1379)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DelphiParserT__0 {
				{
					p.SetState(1378)
					p.CustomAttribute()
				}

			}
			{
				p.SetState(1381)
				p.TypeDecl()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1385)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserT__0 {
			{
				p.SetState(1384)
				p.CustomAttribute()
			}

		}
		{
			p.SetState(1387)
			p.Match(DelphiParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1388)
			p.Match(DelphiParserOPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1389)
			p.MethodName()
		}
		p.SetState(1391)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserLPAREN {
			{
				p.SetState(1390)
				p.FormalParameterSection()
			}

		}
		p.SetState(1398)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserCOLON {
			{
				p.SetState(1393)
				p.Match(DelphiParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1395)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DelphiParserT__0 {
				{
					p.SetState(1394)
					p.CustomAttribute()
				}

			}
			{
				p.SetState(1397)
				p.TypeDecl()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodKeyContext is an interface to support dynamic dispatch.
type IMethodKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCEDURE() antlr.TerminalNode
	CONSTRUCTOR() antlr.TerminalNode
	DESTRUCTOR() antlr.TerminalNode

	// IsMethodKeyContext differentiates from other interfaces.
	IsMethodKeyContext()
}

type MethodKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodKeyContext() *MethodKeyContext {
	var p = new(MethodKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_methodKey
	return p
}

func InitEmptyMethodKeyContext(p *MethodKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_methodKey
}

func (*MethodKeyContext) IsMethodKeyContext() {}

func NewMethodKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodKeyContext {
	var p = new(MethodKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_methodKey

	return p
}

func (s *MethodKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodKeyContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DelphiParserPROCEDURE, 0)
}

func (s *MethodKeyContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(DelphiParserCONSTRUCTOR, 0)
}

func (s *MethodKeyContext) DESTRUCTOR() antlr.TerminalNode {
	return s.GetToken(DelphiParserDESTRUCTOR, 0)
}

func (s *MethodKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterMethodKey(s)
	}
}

func (s *MethodKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitMethodKey(s)
	}
}

func (p *DelphiParser) MethodKey() (localctx IMethodKeyContext) {
	localctx = NewMethodKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, DelphiParserRULE_methodKey)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1402)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DelphiParserCONSTRUCTOR || _la == DelphiParserDESTRUCTOR || _la == DelphiParserPROCEDURE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodNameContext is an interface to support dynamic dispatch.
type IMethodNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllGenericDefinition() []IGenericDefinitionContext
	GenericDefinition(i int) IGenericDefinitionContext

	// IsMethodNameContext differentiates from other interfaces.
	IsMethodNameContext()
}

type MethodNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodNameContext() *MethodNameContext {
	var p = new(MethodNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_methodName
	return p
}

func InitEmptyMethodNameContext(p *MethodNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_methodName
}

func (*MethodNameContext) IsMethodNameContext() {}

func NewMethodNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodNameContext {
	var p = new(MethodNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_methodName

	return p
}

func (s *MethodNameContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodNameContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *MethodNameContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *MethodNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserDOT)
}

func (s *MethodNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserDOT, i)
}

func (s *MethodNameContext) AllGenericDefinition() []IGenericDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGenericDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IGenericDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGenericDefinitionContext); ok {
			tst[i] = t.(IGenericDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *MethodNameContext) GenericDefinition(i int) IGenericDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericDefinitionContext)
}

func (s *MethodNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterMethodName(s)
	}
}

func (s *MethodNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitMethodName(s)
	}
}

func (p *DelphiParser) MethodName() (localctx IMethodNameContext) {
	localctx = NewMethodNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, DelphiParserRULE_methodName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1404)
		p.Ident()
	}
	p.SetState(1406)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserLT {
		{
			p.SetState(1405)
			p.GenericDefinition()
		}

	}
	p.SetState(1413)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1408)
			p.Match(DelphiParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1409)
			p.Ident()
		}
		p.SetState(1411)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserLT {
			{
				p.SetState(1410)
				p.GenericDefinition()
			}

		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1415)
		p.Match(DelphiParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1416)
		p.Ident()
	}
	p.SetState(1418)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserLT {
		{
			p.SetState(1417)
			p.GenericDefinition()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcDeclContext is an interface to support dynamic dispatch.
type IProcDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcDeclHeading() IProcDeclHeadingContext
	SEMI() antlr.TerminalNode
	AllFunctionDirective() []IFunctionDirectiveContext
	FunctionDirective(i int) IFunctionDirectiveContext
	ProcBody() IProcBodyContext

	// IsProcDeclContext differentiates from other interfaces.
	IsProcDeclContext()
}

type ProcDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcDeclContext() *ProcDeclContext {
	var p = new(ProcDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_procDecl
	return p
}

func InitEmptyProcDeclContext(p *ProcDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_procDecl
}

func (*ProcDeclContext) IsProcDeclContext() {}

func NewProcDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcDeclContext {
	var p = new(ProcDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_procDecl

	return p
}

func (s *ProcDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcDeclContext) ProcDeclHeading() IProcDeclHeadingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcDeclHeadingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcDeclHeadingContext)
}

func (s *ProcDeclContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *ProcDeclContext) AllFunctionDirective() []IFunctionDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IFunctionDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionDirectiveContext); ok {
			tst[i] = t.(IFunctionDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *ProcDeclContext) FunctionDirective(i int) IFunctionDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDirectiveContext)
}

func (s *ProcDeclContext) ProcBody() IProcBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcBodyContext)
}

func (s *ProcDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterProcDecl(s)
	}
}

func (s *ProcDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitProcDecl(s)
	}
}

func (p *DelphiParser) ProcDecl() (localctx IProcDeclContext) {
	localctx = NewProcDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, DelphiParserRULE_procDecl)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1420)
		p.ProcDeclHeading()
	}
	{
		p.SetState(1421)
		p.Match(DelphiParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1425)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1422)
				p.FunctionDirective()
			}

		}
		p.SetState(1427)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1429)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 183, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1428)
			p.ProcBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcDeclHeadingContext is an interface to support dynamic dispatch.
type IProcDeclHeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCEDURE() antlr.TerminalNode
	Ident() IIdentContext
	CustomAttribute() ICustomAttributeContext
	FormalParameterSection() IFormalParameterSectionContext
	FUNCTION() antlr.TerminalNode
	COLON() antlr.TerminalNode
	TypeDecl() ITypeDeclContext

	// IsProcDeclHeadingContext differentiates from other interfaces.
	IsProcDeclHeadingContext()
}

type ProcDeclHeadingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcDeclHeadingContext() *ProcDeclHeadingContext {
	var p = new(ProcDeclHeadingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_procDeclHeading
	return p
}

func InitEmptyProcDeclHeadingContext(p *ProcDeclHeadingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_procDeclHeading
}

func (*ProcDeclHeadingContext) IsProcDeclHeadingContext() {}

func NewProcDeclHeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcDeclHeadingContext {
	var p = new(ProcDeclHeadingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_procDeclHeading

	return p
}

func (s *ProcDeclHeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcDeclHeadingContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DelphiParserPROCEDURE, 0)
}

func (s *ProcDeclHeadingContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *ProcDeclHeadingContext) CustomAttribute() ICustomAttributeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomAttributeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomAttributeContext)
}

func (s *ProcDeclHeadingContext) FormalParameterSection() IFormalParameterSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterSectionContext)
}

func (s *ProcDeclHeadingContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DelphiParserFUNCTION, 0)
}

func (s *ProcDeclHeadingContext) COLON() antlr.TerminalNode {
	return s.GetToken(DelphiParserCOLON, 0)
}

func (s *ProcDeclHeadingContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *ProcDeclHeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcDeclHeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcDeclHeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterProcDeclHeading(s)
	}
}

func (s *ProcDeclHeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitProcDeclHeading(s)
	}
}

func (p *DelphiParser) ProcDeclHeading() (localctx IProcDeclHeadingContext) {
	localctx = NewProcDeclHeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, DelphiParserRULE_procDeclHeading)
	var _la int

	p.SetState(1450)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1432)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserT__0 {
			{
				p.SetState(1431)
				p.CustomAttribute()
			}

		}
		{
			p.SetState(1434)
			p.Match(DelphiParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1435)
			p.Ident()
		}
		p.SetState(1437)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserLPAREN {
			{
				p.SetState(1436)
				p.FormalParameterSection()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1440)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserT__0 {
			{
				p.SetState(1439)
				p.CustomAttribute()
			}

		}
		{
			p.SetState(1442)
			p.Match(DelphiParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1443)
			p.Ident()
		}
		p.SetState(1445)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserLPAREN {
			{
				p.SetState(1444)
				p.FormalParameterSection()
			}

		}
		{
			p.SetState(1447)
			p.Match(DelphiParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1448)
			p.TypeDecl()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterSectionContext is an interface to support dynamic dispatch.
type IFormalParameterSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsFormalParameterSectionContext differentiates from other interfaces.
	IsFormalParameterSectionContext()
}

type FormalParameterSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterSectionContext() *FormalParameterSectionContext {
	var p = new(FormalParameterSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_formalParameterSection
	return p
}

func InitEmptyFormalParameterSectionContext(p *FormalParameterSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_formalParameterSection
}

func (*FormalParameterSectionContext) IsFormalParameterSectionContext() {}

func NewFormalParameterSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterSectionContext {
	var p = new(FormalParameterSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_formalParameterSection

	return p
}

func (s *FormalParameterSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterSectionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserLPAREN, 0)
}

func (s *FormalParameterSectionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserRPAREN, 0)
}

func (s *FormalParameterSectionContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FormalParameterSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterFormalParameterSection(s)
	}
}

func (s *FormalParameterSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitFormalParameterSection(s)
	}
}

func (p *DelphiParser) FormalParameterSection() (localctx IFormalParameterSectionContext) {
	localctx = NewFormalParameterSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, DelphiParserRULE_formalParameterSection)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1452)
		p.Match(DelphiParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1454)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&90090271943462992) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2883288972791916811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&18014400656965633) != 0) {
		{
			p.SetState(1453)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1456)
		p.Match(DelphiParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFormalParameter() []IFormalParameterContext
	FormalParameter(i int) IFormalParameterContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_formalParameterList
	return p
}

func InitEmptyFormalParameterListContext(p *FormalParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_formalParameterList
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) AllFormalParameter() []IFormalParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterContext); ok {
			tst[i] = t.(IFormalParameterContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameter(i int) IFormalParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterContext)
}

func (s *FormalParameterListContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserSEMI)
}

func (s *FormalParameterListContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, i)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}

func (p *DelphiParser) FormalParameterList() (localctx IFormalParameterListContext) {
	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, DelphiParserRULE_formalParameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1458)
		p.FormalParameter()
	}
	p.SetState(1463)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DelphiParserSEMI {
		{
			p.SetState(1459)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1460)
			p.FormalParameter()
		}

		p.SetState(1465)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterContext is an interface to support dynamic dispatch.
type IFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentListFlat() IIdentListFlatContext
	ParmType() IParmTypeContext
	COLON() antlr.TerminalNode
	TypeDecl() ITypeDeclContext
	EQUAL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsFormalParameterContext differentiates from other interfaces.
	IsFormalParameterContext()
}

type FormalParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterContext() *FormalParameterContext {
	var p = new(FormalParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_formalParameter
	return p
}

func InitEmptyFormalParameterContext(p *FormalParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_formalParameter
}

func (*FormalParameterContext) IsFormalParameterContext() {}

func NewFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterContext {
	var p = new(FormalParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_formalParameter

	return p
}

func (s *FormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterContext) IdentListFlat() IIdentListFlatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentListFlatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentListFlatContext)
}

func (s *FormalParameterContext) ParmType() IParmTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParmTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParmTypeContext)
}

func (s *FormalParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(DelphiParserCOLON, 0)
}

func (s *FormalParameterContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *FormalParameterContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(DelphiParserEQUAL, 0)
}

func (s *FormalParameterContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterFormalParameter(s)
	}
}

func (s *FormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitFormalParameter(s)
	}
}

func (p *DelphiParser) FormalParameter() (localctx IFormalParameterContext) {
	localctx = NewFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, DelphiParserRULE_formalParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1467)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 191, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1466)
			p.ParmType()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1469)
		p.IdentListFlat()
	}
	p.SetState(1472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserCOLON {
		{
			p.SetState(1470)
			p.Match(DelphiParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1471)
			p.TypeDecl()
		}

	}
	p.SetState(1476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserEQUAL {
		{
			p.SetState(1474)
			p.Match(DelphiParserEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1475)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParmTypeContext is an interface to support dynamic dispatch.
type IParmTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONST() antlr.TerminalNode
	VAR() antlr.TerminalNode
	OUT() antlr.TerminalNode

	// IsParmTypeContext differentiates from other interfaces.
	IsParmTypeContext()
}

type ParmTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParmTypeContext() *ParmTypeContext {
	var p = new(ParmTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_parmType
	return p
}

func InitEmptyParmTypeContext(p *ParmTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_parmType
}

func (*ParmTypeContext) IsParmTypeContext() {}

func NewParmTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParmTypeContext {
	var p = new(ParmTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_parmType

	return p
}

func (s *ParmTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ParmTypeContext) CONST() antlr.TerminalNode {
	return s.GetToken(DelphiParserCONST, 0)
}

func (s *ParmTypeContext) VAR() antlr.TerminalNode {
	return s.GetToken(DelphiParserVAR, 0)
}

func (s *ParmTypeContext) OUT() antlr.TerminalNode {
	return s.GetToken(DelphiParserOUT, 0)
}

func (s *ParmTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParmTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParmTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterParmType(s)
	}
}

func (s *ParmTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitParmType(s)
	}
}

func (p *DelphiParser) ParmType() (localctx IParmTypeContext) {
	localctx = NewParmTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, DelphiParserRULE_parmType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1478)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DelphiParserCONST || _la == DelphiParserOUT || _la == DelphiParserVAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodBodyContext is an interface to support dynamic dispatch.
type IMethodBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	SEMI() antlr.TerminalNode

	// IsMethodBodyContext differentiates from other interfaces.
	IsMethodBodyContext()
}

type MethodBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodBodyContext() *MethodBodyContext {
	var p = new(MethodBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_methodBody
	return p
}

func InitEmptyMethodBodyContext(p *MethodBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_methodBody
}

func (*MethodBodyContext) IsMethodBodyContext() {}

func NewMethodBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodBodyContext {
	var p = new(MethodBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_methodBody

	return p
}

func (s *MethodBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *MethodBodyContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *MethodBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterMethodBody(s)
	}
}

func (s *MethodBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitMethodBody(s)
	}
}

func (p *DelphiParser) MethodBody() (localctx IMethodBodyContext) {
	localctx = NewMethodBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, DelphiParserRULE_methodBody)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1480)
		p.Block()
	}
	{
		p.SetState(1481)
		p.Match(DelphiParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcBodyContext is an interface to support dynamic dispatch.
type IProcBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FORWARD() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	AllFunctionDirective() []IFunctionDirectiveContext
	FunctionDirective(i int) IFunctionDirectiveContext
	EXTERNAL() antlr.TerminalNode
	AllNAME() []antlr.TerminalNode
	NAME(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllINDEX() []antlr.TerminalNode
	INDEX(i int) antlr.TerminalNode
	Block() IBlockContext

	// IsProcBodyContext differentiates from other interfaces.
	IsProcBodyContext()
}

type ProcBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcBodyContext() *ProcBodyContext {
	var p = new(ProcBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_procBody
	return p
}

func InitEmptyProcBodyContext(p *ProcBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_procBody
}

func (*ProcBodyContext) IsProcBodyContext() {}

func NewProcBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcBodyContext {
	var p = new(ProcBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_procBody

	return p
}

func (s *ProcBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcBodyContext) FORWARD() antlr.TerminalNode {
	return s.GetToken(DelphiParserFORWARD, 0)
}

func (s *ProcBodyContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *ProcBodyContext) AllFunctionDirective() []IFunctionDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IFunctionDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionDirectiveContext); ok {
			tst[i] = t.(IFunctionDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *ProcBodyContext) FunctionDirective(i int) IFunctionDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDirectiveContext)
}

func (s *ProcBodyContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DelphiParserEXTERNAL, 0)
}

func (s *ProcBodyContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserNAME)
}

func (s *ProcBodyContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserNAME, i)
}

func (s *ProcBodyContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ProcBodyContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ProcBodyContext) AllINDEX() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserINDEX)
}

func (s *ProcBodyContext) INDEX(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserINDEX, i)
}

func (s *ProcBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ProcBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterProcBody(s)
	}
}

func (s *ProcBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitProcBody(s)
	}
}

func (p *DelphiParser) ProcBody() (localctx IProcBodyContext) {
	localctx = NewProcBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, DelphiParserRULE_procBody)
	var _alt int

	p.SetState(1510)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserFORWARD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1483)
			p.Match(DelphiParserFORWARD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1484)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1488)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 194, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1485)
					p.FunctionDirective()
				}

			}
			p.SetState(1490)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 194, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case DelphiParserEXTERNAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1491)
			p.Match(DelphiParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1498)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 196, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(1496)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DelphiParserNAME:
					{
						p.SetState(1492)
						p.Match(DelphiParserNAME)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1493)
						p.Expression()
					}

				case DelphiParserINDEX:
					{
						p.SetState(1494)
						p.Match(DelphiParserINDEX)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1495)
						p.Expression()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}
			p.SetState(1500)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 196, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1504)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 197, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1501)
					p.FunctionDirective()
				}

			}
			p.SetState(1506)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 197, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case DelphiParserT__0, DelphiParserASM, DelphiParserBEGIN, DelphiParserCLASS, DelphiParserCONST, DelphiParserCONSTRUCTOR, DelphiParserDESTRUCTOR, DelphiParserEXPORTS, DelphiParserFUNCTION, DelphiParserLABEL, DelphiParserPROCEDURE, DelphiParserRESOURCESTRING, DelphiParserTHREADVAR, DelphiParserTYPE, DelphiParserVAR, DelphiParserSEMI:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1507)
			p.Block()
		}
		{
			p.SetState(1508)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICustomAttributeContext is an interface to support dynamic dispatch.
type ICustomAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCustomAttributeContext differentiates from other interfaces.
	IsCustomAttributeContext()
}

type CustomAttributeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCustomAttributeContext() *CustomAttributeContext {
	var p = new(CustomAttributeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_customAttribute
	return p
}

func InitEmptyCustomAttributeContext(p *CustomAttributeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_customAttribute
}

func (*CustomAttributeContext) IsCustomAttributeContext() {}

func NewCustomAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CustomAttributeContext {
	var p = new(CustomAttributeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_customAttribute

	return p
}

func (s *CustomAttributeContext) GetParser() antlr.Parser { return s.parser }
func (s *CustomAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CustomAttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CustomAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterCustomAttribute(s)
	}
}

func (s *CustomAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitCustomAttribute(s)
	}
}

func (p *DelphiParser) CustomAttribute() (localctx ICustomAttributeContext) {
	localctx = NewCustomAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, DelphiParserRULE_customAttribute)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1512)
		p.Match(DelphiParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICustomAttributeListContext is an interface to support dynamic dispatch.
type ICustomAttributeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCustomAttributeDecl() []ICustomAttributeDeclContext
	CustomAttributeDecl(i int) ICustomAttributeDeclContext

	// IsCustomAttributeListContext differentiates from other interfaces.
	IsCustomAttributeListContext()
}

type CustomAttributeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCustomAttributeListContext() *CustomAttributeListContext {
	var p = new(CustomAttributeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_customAttributeList
	return p
}

func InitEmptyCustomAttributeListContext(p *CustomAttributeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_customAttributeList
}

func (*CustomAttributeListContext) IsCustomAttributeListContext() {}

func NewCustomAttributeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CustomAttributeListContext {
	var p = new(CustomAttributeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_customAttributeList

	return p
}

func (s *CustomAttributeListContext) GetParser() antlr.Parser { return s.parser }

func (s *CustomAttributeListContext) AllCustomAttributeDecl() []ICustomAttributeDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICustomAttributeDeclContext); ok {
			len++
		}
	}

	tst := make([]ICustomAttributeDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICustomAttributeDeclContext); ok {
			tst[i] = t.(ICustomAttributeDeclContext)
			i++
		}
	}

	return tst
}

func (s *CustomAttributeListContext) CustomAttributeDecl(i int) ICustomAttributeDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICustomAttributeDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICustomAttributeDeclContext)
}

func (s *CustomAttributeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CustomAttributeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CustomAttributeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterCustomAttributeList(s)
	}
}

func (s *CustomAttributeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitCustomAttributeList(s)
	}
}

func (p *DelphiParser) CustomAttributeList() (localctx ICustomAttributeListContext) {
	localctx = NewCustomAttributeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, DelphiParserRULE_customAttributeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1517)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DelphiParserLBRACK {
		{
			p.SetState(1514)
			p.CustomAttributeDecl()
		}

		p.SetState(1519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICustomAttributeDeclContext is an interface to support dynamic dispatch.
type ICustomAttributeDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	NamespacedQualifiedIdent() INamespacedQualifiedIdentContext
	RBRACK() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsCustomAttributeDeclContext differentiates from other interfaces.
	IsCustomAttributeDeclContext()
}

type CustomAttributeDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCustomAttributeDeclContext() *CustomAttributeDeclContext {
	var p = new(CustomAttributeDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_customAttributeDecl
	return p
}

func InitEmptyCustomAttributeDeclContext(p *CustomAttributeDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_customAttributeDecl
}

func (*CustomAttributeDeclContext) IsCustomAttributeDeclContext() {}

func NewCustomAttributeDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CustomAttributeDeclContext {
	var p = new(CustomAttributeDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_customAttributeDecl

	return p
}

func (s *CustomAttributeDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *CustomAttributeDeclContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(DelphiParserLBRACK, 0)
}

func (s *CustomAttributeDeclContext) NamespacedQualifiedIdent() INamespacedQualifiedIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespacedQualifiedIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespacedQualifiedIdentContext)
}

func (s *CustomAttributeDeclContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(DelphiParserRBRACK, 0)
}

func (s *CustomAttributeDeclContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserLPAREN, 0)
}

func (s *CustomAttributeDeclContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserRPAREN, 0)
}

func (s *CustomAttributeDeclContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *CustomAttributeDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CustomAttributeDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CustomAttributeDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterCustomAttributeDecl(s)
	}
}

func (s *CustomAttributeDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitCustomAttributeDecl(s)
	}
}

func (p *DelphiParser) CustomAttributeDecl() (localctx ICustomAttributeDeclContext) {
	localctx = NewCustomAttributeDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, DelphiParserRULE_customAttributeDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1520)
		p.Match(DelphiParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1521)
		p.NamespacedQualifiedIdent()
	}
	p.SetState(1527)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserLPAREN {
		{
			p.SetState(1522)
			p.Match(DelphiParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1524)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 200, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1523)
				p.ExpressionList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1526)
			p.Match(DelphiParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1529)
		p.Match(DelphiParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnonymousExpression() IAnonymousExpressionContext
	AllSimpleExpression() []ISimpleExpressionContext
	SimpleExpression(i int) ISimpleExpressionContext
	RelOp() IRelOpContext
	EQUAL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) AnonymousExpression() IAnonymousExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnonymousExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnonymousExpressionContext)
}

func (s *ExpressionContext) AllSimpleExpression() []ISimpleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISimpleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleExpressionContext); ok {
			tst[i] = t.(ISimpleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) SimpleExpression(i int) ISimpleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExpressionContext)
}

func (s *ExpressionContext) RelOp() IRelOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelOpContext)
}

func (s *ExpressionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(DelphiParserEQUAL, 0)
}

func (s *ExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *DelphiParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, DelphiParserRULE_expression)
	p.SetState(1542)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 204, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1531)
			p.AnonymousExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1532)
			p.SimpleExpression()
		}
		p.SetState(1536)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 202, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1533)
				p.RelOp()
			}
			{
				p.SetState(1534)
				p.SimpleExpression()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1540)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 203, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1538)
				p.Match(DelphiParserEQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1539)
				p.Expression()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnonymousExpressionContext is an interface to support dynamic dispatch.
type IAnonymousExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCEDURE() antlr.TerminalNode
	Block() IBlockContext
	FormalParameterSection() IFormalParameterSectionContext
	FUNCTION() antlr.TerminalNode
	COLON() antlr.TerminalNode
	TypeDecl() ITypeDeclContext

	// IsAnonymousExpressionContext differentiates from other interfaces.
	IsAnonymousExpressionContext()
}

type AnonymousExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonymousExpressionContext() *AnonymousExpressionContext {
	var p = new(AnonymousExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_anonymousExpression
	return p
}

func InitEmptyAnonymousExpressionContext(p *AnonymousExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_anonymousExpression
}

func (*AnonymousExpressionContext) IsAnonymousExpressionContext() {}

func NewAnonymousExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnonymousExpressionContext {
	var p = new(AnonymousExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_anonymousExpression

	return p
}

func (s *AnonymousExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AnonymousExpressionContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DelphiParserPROCEDURE, 0)
}

func (s *AnonymousExpressionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *AnonymousExpressionContext) FormalParameterSection() IFormalParameterSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterSectionContext)
}

func (s *AnonymousExpressionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DelphiParserFUNCTION, 0)
}

func (s *AnonymousExpressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(DelphiParserCOLON, 0)
}

func (s *AnonymousExpressionContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *AnonymousExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonymousExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnonymousExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterAnonymousExpression(s)
	}
}

func (s *AnonymousExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitAnonymousExpression(s)
	}
}

func (p *DelphiParser) AnonymousExpression() (localctx IAnonymousExpressionContext) {
	localctx = NewAnonymousExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, DelphiParserRULE_anonymousExpression)
	var _la int

	p.SetState(1557)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserPROCEDURE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1544)
			p.Match(DelphiParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1546)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1545)
				p.FormalParameterSection()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1548)
			p.Block()
		}

	case DelphiParserFUNCTION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1549)
			p.Match(DelphiParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1551)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserLPAREN {
			{
				p.SetState(1550)
				p.FormalParameterSection()
			}

		}
		{
			p.SetState(1553)
			p.Match(DelphiParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1554)
			p.TypeDecl()
		}
		{
			p.SetState(1555)
			p.Block()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleExpressionContext is an interface to support dynamic dispatch.
type ISimpleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFactor() []IFactorContext
	Factor(i int) IFactorContext
	AllOperator() []IOperatorContext
	Operator(i int) IOperatorContext

	// IsSimpleExpressionContext differentiates from other interfaces.
	IsSimpleExpressionContext()
}

type SimpleExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleExpressionContext() *SimpleExpressionContext {
	var p = new(SimpleExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_simpleExpression
	return p
}

func InitEmptySimpleExpressionContext(p *SimpleExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_simpleExpression
}

func (*SimpleExpressionContext) IsSimpleExpressionContext() {}

func NewSimpleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleExpressionContext {
	var p = new(SimpleExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_simpleExpression

	return p
}

func (s *SimpleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleExpressionContext) AllFactor() []IFactorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFactorContext); ok {
			len++
		}
	}

	tst := make([]IFactorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFactorContext); ok {
			tst[i] = t.(IFactorContext)
			i++
		}
	}

	return tst
}

func (s *SimpleExpressionContext) Factor(i int) IFactorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *SimpleExpressionContext) AllOperator() []IOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOperatorContext); ok {
			len++
		}
	}

	tst := make([]IOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOperatorContext); ok {
			tst[i] = t.(IOperatorContext)
			i++
		}
	}

	return tst
}

func (s *SimpleExpressionContext) Operator(i int) IOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperatorContext)
}

func (s *SimpleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterSimpleExpression(s)
	}
}

func (s *SimpleExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitSimpleExpression(s)
	}
}

func (p *DelphiParser) SimpleExpression() (localctx ISimpleExpressionContext) {
	localctx = NewSimpleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, DelphiParserRULE_simpleExpression)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1559)
		p.Factor()
	}
	p.SetState(1565)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 208, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1560)
				p.Operator()
			}
			{
				p.SetState(1561)
				p.Factor()
			}

		}
		p.SetState(1567)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 208, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFactorContext is an interface to support dynamic dispatch.
type IFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT2() antlr.TerminalNode
	Factor() IFactorContext
	DOUBLEAT() antlr.TerminalNode
	NOT() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	POINTER2() antlr.TerminalNode
	Ident() IIdentContext
	IntNum() IIntNumContext
	RealNum() IRealNumContext
	TkAsmHexNum() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode
	NIL() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	RPAREN() antlr.TerminalNode
	DOT() antlr.TerminalNode
	StringFactor() IStringFactorContext
	SetSection() ISetSectionContext
	Designator() IDesignatorContext
	TypeId() ITypeIdContext

	// IsFactorContext differentiates from other interfaces.
	IsFactorContext()
}

type FactorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactorContext() *FactorContext {
	var p = new(FactorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_factor
	return p
}

func InitEmptyFactorContext(p *FactorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_factor
}

func (*FactorContext) IsFactorContext() {}

func NewFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FactorContext {
	var p = new(FactorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_factor

	return p
}

func (s *FactorContext) GetParser() antlr.Parser { return s.parser }

func (s *FactorContext) AT2() antlr.TerminalNode {
	return s.GetToken(DelphiParserAT2, 0)
}

func (s *FactorContext) Factor() IFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *FactorContext) DOUBLEAT() antlr.TerminalNode {
	return s.GetToken(DelphiParserDOUBLEAT, 0)
}

func (s *FactorContext) NOT() antlr.TerminalNode {
	return s.GetToken(DelphiParserNOT, 0)
}

func (s *FactorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(DelphiParserPLUS, 0)
}

func (s *FactorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(DelphiParserMINUS, 0)
}

func (s *FactorContext) POINTER2() antlr.TerminalNode {
	return s.GetToken(DelphiParserPOINTER2, 0)
}

func (s *FactorContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *FactorContext) IntNum() IIntNumContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntNumContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntNumContext)
}

func (s *FactorContext) RealNum() IRealNumContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRealNumContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRealNumContext)
}

func (s *FactorContext) TkAsmHexNum() antlr.TerminalNode {
	return s.GetToken(DelphiParserTkAsmHexNum, 0)
}

func (s *FactorContext) TRUE() antlr.TerminalNode {
	return s.GetToken(DelphiParserTRUE, 0)
}

func (s *FactorContext) FALSE() antlr.TerminalNode {
	return s.GetToken(DelphiParserFALSE, 0)
}

func (s *FactorContext) NIL() antlr.TerminalNode {
	return s.GetToken(DelphiParserNIL, 0)
}

func (s *FactorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserLPAREN, 0)
}

func (s *FactorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *FactorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FactorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserRPAREN, 0)
}

func (s *FactorContext) DOT() antlr.TerminalNode {
	return s.GetToken(DelphiParserDOT, 0)
}

func (s *FactorContext) StringFactor() IStringFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringFactorContext)
}

func (s *FactorContext) SetSection() ISetSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetSectionContext)
}

func (s *FactorContext) Designator() IDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *FactorContext) TypeId() ITypeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdContext)
}

func (s *FactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterFactor(s)
	}
}

func (s *FactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitFactor(s)
	}
}

func (p *DelphiParser) Factor() (localctx IFactorContext) {
	localctx = NewFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, DelphiParserRULE_factor)
	var _la int

	p.SetState(1601)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 211, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1568)
			p.Match(DelphiParserAT2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1569)
			p.Factor()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1570)
			p.Match(DelphiParserDOUBLEAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1571)
			p.Factor()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1572)
			p.Match(DelphiParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1573)
			p.Factor()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1574)
			p.Match(DelphiParserPLUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1575)
			p.Factor()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1576)
			p.Match(DelphiParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1577)
			p.Factor()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1578)
			p.Match(DelphiParserPOINTER2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1579)
			p.Ident()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1580)
			p.IntNum()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1581)
			p.RealNum()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1582)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DelphiParserNIL || _la == DelphiParserFALSE || _la == DelphiParserTRUE || _la == DelphiParserTkAsmHexNum) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1583)
			p.Match(DelphiParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1584)
			p.Expression()
		}
		{
			p.SetState(1585)
			p.Match(DelphiParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1587)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 209, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1586)
				p.Match(DelphiParserPOINTER2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1591)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 210, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1589)
				p.Match(DelphiParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1590)
				p.Expression()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1593)
			p.StringFactor()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1594)
			p.SetSection()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1595)
			p.Designator()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1596)
			p.TypeId()
		}
		{
			p.SetState(1597)
			p.Match(DelphiParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1598)
			p.Expression()
		}
		{
			p.SetState(1599)
			p.Match(DelphiParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringFactorContext is an interface to support dynamic dispatch.
type IStringFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllControlString() []antlr.TerminalNode
	ControlString(i int) antlr.TerminalNode
	AllQuotedString() []antlr.TerminalNode
	QuotedString(i int) antlr.TerminalNode

	// IsStringFactorContext differentiates from other interfaces.
	IsStringFactorContext()
}

type StringFactorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringFactorContext() *StringFactorContext {
	var p = new(StringFactorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_stringFactor
	return p
}

func InitEmptyStringFactorContext(p *StringFactorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_stringFactor
}

func (*StringFactorContext) IsStringFactorContext() {}

func NewStringFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringFactorContext {
	var p = new(StringFactorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_stringFactor

	return p
}

func (s *StringFactorContext) GetParser() antlr.Parser { return s.parser }

func (s *StringFactorContext) AllControlString() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserControlString)
}

func (s *StringFactorContext) ControlString(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserControlString, i)
}

func (s *StringFactorContext) AllQuotedString() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserQuotedString)
}

func (s *StringFactorContext) QuotedString(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserQuotedString, i)
}

func (s *StringFactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringFactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringFactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterStringFactor(s)
	}
}

func (s *StringFactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitStringFactor(s)
	}
}

func (p *DelphiParser) StringFactor() (localctx IStringFactorContext) {
	localctx = NewStringFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, DelphiParserRULE_stringFactor)
	var _alt int

	p.SetState(1625)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserControlString:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1603)
			p.Match(DelphiParserControlString)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1608)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1604)
					p.Match(DelphiParserQuotedString)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1605)
					p.Match(DelphiParserControlString)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1610)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1612)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 213, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1611)
				p.Match(DelphiParserQuotedString)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case DelphiParserQuotedString:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1614)
			p.Match(DelphiParserQuotedString)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1619)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 214, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1615)
					p.Match(DelphiParserControlString)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1616)
					p.Match(DelphiParserQuotedString)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1621)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 214, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1623)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 215, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1622)
				p.Match(DelphiParserControlString)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetSectionContext is an interface to support dynamic dispatch.
type ISetSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllDOTDOT() []antlr.TerminalNode
	DOTDOT(i int) antlr.TerminalNode

	// IsSetSectionContext differentiates from other interfaces.
	IsSetSectionContext()
}

type SetSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetSectionContext() *SetSectionContext {
	var p = new(SetSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_setSection
	return p
}

func InitEmptySetSectionContext(p *SetSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_setSection
}

func (*SetSectionContext) IsSetSectionContext() {}

func NewSetSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetSectionContext {
	var p = new(SetSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_setSection

	return p
}

func (s *SetSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *SetSectionContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(DelphiParserLBRACK, 0)
}

func (s *SetSectionContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(DelphiParserRBRACK, 0)
}

func (s *SetSectionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SetSectionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetSectionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserCOMMA)
}

func (s *SetSectionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserCOMMA, i)
}

func (s *SetSectionContext) AllDOTDOT() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserDOTDOT)
}

func (s *SetSectionContext) DOTDOT(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserDOTDOT, i)
}

func (s *SetSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterSetSection(s)
	}
}

func (s *SetSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitSetSection(s)
	}
}

func (p *DelphiParser) SetSection() (localctx ISetSectionContext) {
	localctx = NewSetSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, DelphiParserRULE_setSection)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1627)
		p.Match(DelphiParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1636)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 218, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1628)
			p.Expression()
		}
		p.SetState(1633)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DelphiParserCOMMA || _la == DelphiParserDOTDOT {
			{
				p.SetState(1629)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DelphiParserCOMMA || _la == DelphiParserDOTDOT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1630)
				p.Expression()
			}

			p.SetState(1635)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1638)
		p.Match(DelphiParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDesignatorContext is an interface to support dynamic dispatch.
type IDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INHERITED() antlr.TerminalNode
	AllDesignatorItem() []IDesignatorItemContext
	DesignatorItem(i int) IDesignatorItemContext
	NamespacedQualifiedIdent() INamespacedQualifiedIdentContext
	TypeId() ITypeIdContext

	// IsDesignatorContext differentiates from other interfaces.
	IsDesignatorContext()
}

type DesignatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesignatorContext() *DesignatorContext {
	var p = new(DesignatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_designator
	return p
}

func InitEmptyDesignatorContext(p *DesignatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_designator
}

func (*DesignatorContext) IsDesignatorContext() {}

func NewDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DesignatorContext {
	var p = new(DesignatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_designator

	return p
}

func (s *DesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *DesignatorContext) INHERITED() antlr.TerminalNode {
	return s.GetToken(DelphiParserINHERITED, 0)
}

func (s *DesignatorContext) AllDesignatorItem() []IDesignatorItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDesignatorItemContext); ok {
			len++
		}
	}

	tst := make([]IDesignatorItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDesignatorItemContext); ok {
			tst[i] = t.(IDesignatorItemContext)
			i++
		}
	}

	return tst
}

func (s *DesignatorContext) DesignatorItem(i int) IDesignatorItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorItemContext)
}

func (s *DesignatorContext) NamespacedQualifiedIdent() INamespacedQualifiedIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespacedQualifiedIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespacedQualifiedIdentContext)
}

func (s *DesignatorContext) TypeId() ITypeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdContext)
}

func (s *DesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DesignatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterDesignator(s)
	}
}

func (s *DesignatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitDesignator(s)
	}
}

func (p *DelphiParser) Designator() (localctx IDesignatorContext) {
	localctx = NewDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, DelphiParserRULE_designator)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1641)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 219, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1640)
			p.Match(DelphiParserINHERITED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1647)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 221, p.GetParserRuleContext()) == 1 {
		p.SetState(1645)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 220, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1643)
				p.NamespacedQualifiedIdent()
			}

		case 2:
			{
				p.SetState(1644)
				p.TypeId()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1652)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 222, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1649)
				p.DesignatorItem()
			}

		}
		p.SetState(1654)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 222, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDesignatorItemContext is an interface to support dynamic dispatch.
type IDesignatorItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	POINTER2() antlr.TerminalNode
	Ident() IIdentContext
	DOT() antlr.TerminalNode
	AT2() antlr.TerminalNode
	LT() antlr.TerminalNode
	AllGenericTypeIdent() []IGenericTypeIdentContext
	GenericTypeIdent(i int) IGenericTypeIdentContext
	GT() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	RBRACK() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllColonConstruct() []IColonConstructContext
	ColonConstruct(i int) IColonConstructContext

	// IsDesignatorItemContext differentiates from other interfaces.
	IsDesignatorItemContext()
}

type DesignatorItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesignatorItemContext() *DesignatorItemContext {
	var p = new(DesignatorItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_designatorItem
	return p
}

func InitEmptyDesignatorItemContext(p *DesignatorItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_designatorItem
}

func (*DesignatorItemContext) IsDesignatorItemContext() {}

func NewDesignatorItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DesignatorItemContext {
	var p = new(DesignatorItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_designatorItem

	return p
}

func (s *DesignatorItemContext) GetParser() antlr.Parser { return s.parser }

func (s *DesignatorItemContext) POINTER2() antlr.TerminalNode {
	return s.GetToken(DelphiParserPOINTER2, 0)
}

func (s *DesignatorItemContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *DesignatorItemContext) DOT() antlr.TerminalNode {
	return s.GetToken(DelphiParserDOT, 0)
}

func (s *DesignatorItemContext) AT2() antlr.TerminalNode {
	return s.GetToken(DelphiParserAT2, 0)
}

func (s *DesignatorItemContext) LT() antlr.TerminalNode {
	return s.GetToken(DelphiParserLT, 0)
}

func (s *DesignatorItemContext) AllGenericTypeIdent() []IGenericTypeIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGenericTypeIdentContext); ok {
			len++
		}
	}

	tst := make([]IGenericTypeIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGenericTypeIdentContext); ok {
			tst[i] = t.(IGenericTypeIdentContext)
			i++
		}
	}

	return tst
}

func (s *DesignatorItemContext) GenericTypeIdent(i int) IGenericTypeIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericTypeIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericTypeIdentContext)
}

func (s *DesignatorItemContext) GT() antlr.TerminalNode {
	return s.GetToken(DelphiParserGT, 0)
}

func (s *DesignatorItemContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserCOMMA)
}

func (s *DesignatorItemContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserCOMMA, i)
}

func (s *DesignatorItemContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(DelphiParserLBRACK, 0)
}

func (s *DesignatorItemContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *DesignatorItemContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(DelphiParserRBRACK, 0)
}

func (s *DesignatorItemContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserLPAREN, 0)
}

func (s *DesignatorItemContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserRPAREN, 0)
}

func (s *DesignatorItemContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *DesignatorItemContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DesignatorItemContext) AllColonConstruct() []IColonConstructContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColonConstructContext); ok {
			len++
		}
	}

	tst := make([]IColonConstructContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColonConstructContext); ok {
			tst[i] = t.(IColonConstructContext)
			i++
		}
	}

	return tst
}

func (s *DesignatorItemContext) ColonConstruct(i int) IColonConstructContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColonConstructContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColonConstructContext)
}

func (s *DesignatorItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DesignatorItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DesignatorItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterDesignatorItem(s)
	}
}

func (s *DesignatorItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitDesignatorItem(s)
	}
}

func (p *DelphiParser) DesignatorItem() (localctx IDesignatorItemContext) {
	localctx = NewDesignatorItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, DelphiParserRULE_designatorItem)
	var _la int

	p.SetState(1691)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserPOINTER2:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1655)
			p.Match(DelphiParserPOINTER2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserAT2, DelphiParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1656)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DelphiParserAT2 || _la == DelphiParserDOT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1657)
			p.Ident()
		}

	case DelphiParserLT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1658)
			p.Match(DelphiParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1659)
			p.GenericTypeIdent()
		}
		p.SetState(1664)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DelphiParserCOMMA {
			{
				p.SetState(1660)
				p.Match(DelphiParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1661)
				p.GenericTypeIdent()
			}

			p.SetState(1666)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1667)
			p.Match(DelphiParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserLBRACK:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1669)
			p.Match(DelphiParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1670)
			p.ExpressionList()
		}
		{
			p.SetState(1671)
			p.Match(DelphiParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserLPAREN:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1673)
			p.Match(DelphiParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1688)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 227, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1674)
				p.Expression()
			}
			p.SetState(1676)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DelphiParserCOLON {
				{
					p.SetState(1675)
					p.ColonConstruct()
				}

			}
			p.SetState(1685)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DelphiParserCOMMA {
				{
					p.SetState(1678)
					p.Match(DelphiParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1679)
					p.Expression()
				}
				p.SetState(1681)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DelphiParserCOLON {
					{
						p.SetState(1680)
						p.ColonConstruct()
					}

				}

				p.SetState(1687)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1690)
			p.Match(DelphiParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserCOMMA)
}

func (s *ExpressionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserCOMMA, i)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (p *DelphiParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, DelphiParserRULE_expressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1693)
		p.Expression()
	}
	p.SetState(1698)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DelphiParserCOMMA {
		{
			p.SetState(1694)
			p.Match(DelphiParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1695)
			p.Expression()
		}

		p.SetState(1700)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColonConstructContext is an interface to support dynamic dispatch.
type IColonConstructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsColonConstructContext differentiates from other interfaces.
	IsColonConstructContext()
}

type ColonConstructContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColonConstructContext() *ColonConstructContext {
	var p = new(ColonConstructContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_colonConstruct
	return p
}

func InitEmptyColonConstructContext(p *ColonConstructContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_colonConstruct
}

func (*ColonConstructContext) IsColonConstructContext() {}

func NewColonConstructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColonConstructContext {
	var p = new(ColonConstructContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_colonConstruct

	return p
}

func (s *ColonConstructContext) GetParser() antlr.Parser { return s.parser }

func (s *ColonConstructContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserCOLON)
}

func (s *ColonConstructContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserCOLON, i)
}

func (s *ColonConstructContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ColonConstructContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ColonConstructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColonConstructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColonConstructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterColonConstruct(s)
	}
}

func (s *ColonConstructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitColonConstruct(s)
	}
}

func (p *DelphiParser) ColonConstruct() (localctx IColonConstructContext) {
	localctx = NewColonConstructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, DelphiParserRULE_colonConstruct)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1701)
		p.Match(DelphiParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1702)
		p.Expression()
	}
	p.SetState(1705)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserCOLON {
		{
			p.SetState(1703)
			p.Match(DelphiParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1704)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOperatorContext is an interface to support dynamic dispatch.
type IOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	OR() antlr.TerminalNode
	XOR() antlr.TerminalNode
	STAR() antlr.TerminalNode
	SLASH() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode
	AND() antlr.TerminalNode
	SHL() antlr.TerminalNode
	SHR() antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsOperatorContext differentiates from other interfaces.
	IsOperatorContext()
}

type OperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperatorContext() *OperatorContext {
	var p = new(OperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_operator
	return p
}

func InitEmptyOperatorContext(p *OperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_operator
}

func (*OperatorContext) IsOperatorContext() {}

func NewOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperatorContext {
	var p = new(OperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_operator

	return p
}

func (s *OperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *OperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(DelphiParserPLUS, 0)
}

func (s *OperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(DelphiParserMINUS, 0)
}

func (s *OperatorContext) OR() antlr.TerminalNode {
	return s.GetToken(DelphiParserOR, 0)
}

func (s *OperatorContext) XOR() antlr.TerminalNode {
	return s.GetToken(DelphiParserXOR, 0)
}

func (s *OperatorContext) STAR() antlr.TerminalNode {
	return s.GetToken(DelphiParserSTAR, 0)
}

func (s *OperatorContext) SLASH() antlr.TerminalNode {
	return s.GetToken(DelphiParserSLASH, 0)
}

func (s *OperatorContext) DIV() antlr.TerminalNode {
	return s.GetToken(DelphiParserDIV, 0)
}

func (s *OperatorContext) MOD() antlr.TerminalNode {
	return s.GetToken(DelphiParserMOD, 0)
}

func (s *OperatorContext) AND() antlr.TerminalNode {
	return s.GetToken(DelphiParserAND, 0)
}

func (s *OperatorContext) SHL() antlr.TerminalNode {
	return s.GetToken(DelphiParserSHL, 0)
}

func (s *OperatorContext) SHR() antlr.TerminalNode {
	return s.GetToken(DelphiParserSHR, 0)
}

func (s *OperatorContext) AS() antlr.TerminalNode {
	return s.GetToken(DelphiParserAS, 0)
}

func (s *OperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterOperator(s)
	}
}

func (s *OperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitOperator(s)
	}
}

func (p *DelphiParser) Operator() (localctx IOperatorContext) {
	localctx = NewOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, DelphiParserRULE_operator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1707)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-5)) & ^0x3f) == 0 && ((int64(1)<<(_la-5))&2305843009222082569) != 0) || ((int64((_la-76)) & ^0x3f) == 0 && ((int64(1)<<(_la-76))&4359484445737091073) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelOpContext is an interface to support dynamic dispatch.
type IRelOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	LE() antlr.TerminalNode
	GE() antlr.TerminalNode
	NOT_EQUAL() antlr.TerminalNode
	EQUAL() antlr.TerminalNode
	IN() antlr.TerminalNode
	IS() antlr.TerminalNode

	// IsRelOpContext differentiates from other interfaces.
	IsRelOpContext()
}

type RelOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelOpContext() *RelOpContext {
	var p = new(RelOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_relOp
	return p
}

func InitEmptyRelOpContext(p *RelOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_relOp
}

func (*RelOpContext) IsRelOpContext() {}

func NewRelOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelOpContext {
	var p = new(RelOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_relOp

	return p
}

func (s *RelOpContext) GetParser() antlr.Parser { return s.parser }

func (s *RelOpContext) LT() antlr.TerminalNode {
	return s.GetToken(DelphiParserLT, 0)
}

func (s *RelOpContext) GT() antlr.TerminalNode {
	return s.GetToken(DelphiParserGT, 0)
}

func (s *RelOpContext) LE() antlr.TerminalNode {
	return s.GetToken(DelphiParserLE, 0)
}

func (s *RelOpContext) GE() antlr.TerminalNode {
	return s.GetToken(DelphiParserGE, 0)
}

func (s *RelOpContext) NOT_EQUAL() antlr.TerminalNode {
	return s.GetToken(DelphiParserNOT_EQUAL, 0)
}

func (s *RelOpContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(DelphiParserEQUAL, 0)
}

func (s *RelOpContext) IN() antlr.TerminalNode {
	return s.GetToken(DelphiParserIN, 0)
}

func (s *RelOpContext) IS() antlr.TerminalNode {
	return s.GetToken(DelphiParserIS, 0)
}

func (s *RelOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterRelOp(s)
	}
}

func (s *RelOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitRelOp(s)
	}
}

func (p *DelphiParser) RelOp() (localctx IRelOpContext) {
	localctx = NewRelOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, DelphiParserRULE_relOp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1709)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DelphiParserIN || _la == DelphiParserIS || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&63) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IfStatement() IIfStatementContext
	CaseStatement() ICaseStatementContext
	RepeatStatement() IRepeatStatementContext
	WhileStatement() IWhileStatementContext
	ForStatement() IForStatementContext
	WithStatement() IWithStatementContext
	TryStatement() ITryStatementContext
	RaiseStatement() IRaiseStatementContext
	AssemblerStatement() IAssemblerStatementContext
	CompoundStatement() ICompoundStatementContext
	Label() ILabelContext
	COLON() antlr.TerminalNode
	Statement() IStatementContext
	SimpleStatement() ISimpleStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) CaseStatement() ICaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseStatementContext)
}

func (s *StatementContext) RepeatStatement() IRepeatStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepeatStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepeatStatementContext)
}

func (s *StatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *StatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *StatementContext) WithStatement() IWithStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithStatementContext)
}

func (s *StatementContext) TryStatement() ITryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryStatementContext)
}

func (s *StatementContext) RaiseStatement() IRaiseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRaiseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRaiseStatementContext)
}

func (s *StatementContext) AssemblerStatement() IAssemblerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssemblerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssemblerStatementContext)
}

func (s *StatementContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *StatementContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *StatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(DelphiParserCOLON, 0)
}

func (s *StatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementContext) SimpleStatement() ISimpleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *DelphiParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, DelphiParserRULE_statement)
	p.SetState(1726)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 231, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1711)
			p.IfStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1712)
			p.CaseStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1713)
			p.RepeatStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1714)
			p.WhileStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1715)
			p.ForStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1716)
			p.WithStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1717)
			p.TryStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1718)
			p.RaiseStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1719)
			p.AssemblerStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1720)
			p.CompoundStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1721)
			p.Label()
		}
		{
			p.SetState(1722)
			p.Match(DelphiParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1723)
			p.Statement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1725)
			p.SimpleStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	Expression() IExpressionContext
	THEN() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	ELSE() antlr.TerminalNode

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(DelphiParserIF, 0)
}

func (s *IfStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStatementContext) THEN() antlr.TerminalNode {
	return s.GetToken(DelphiParserTHEN, 0)
}

func (s *IfStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(DelphiParserELSE, 0)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (p *DelphiParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, DelphiParserRULE_ifStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1728)
		p.Match(DelphiParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1729)
		p.Expression()
	}
	{
		p.SetState(1730)
		p.Match(DelphiParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1731)
		p.Statement()
	}
	p.SetState(1734)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 232, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1732)
			p.Match(DelphiParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1733)
			p.Statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseStatementContext is an interface to support dynamic dispatch.
type ICaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	Expression() IExpressionContext
	OF() antlr.TerminalNode
	END() antlr.TerminalNode
	AllCaseItem() []ICaseItemContext
	CaseItem(i int) ICaseItemContext
	ELSE() antlr.TerminalNode
	StatementList() IStatementListContext
	SEMI() antlr.TerminalNode

	// IsCaseStatementContext differentiates from other interfaces.
	IsCaseStatementContext()
}

type CaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseStatementContext() *CaseStatementContext {
	var p = new(CaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_caseStatement
	return p
}

func InitEmptyCaseStatementContext(p *CaseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_caseStatement
}

func (*CaseStatementContext) IsCaseStatementContext() {}

func NewCaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseStatementContext {
	var p = new(CaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_caseStatement

	return p
}

func (s *CaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseStatementContext) CASE() antlr.TerminalNode {
	return s.GetToken(DelphiParserCASE, 0)
}

func (s *CaseStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseStatementContext) OF() antlr.TerminalNode {
	return s.GetToken(DelphiParserOF, 0)
}

func (s *CaseStatementContext) END() antlr.TerminalNode {
	return s.GetToken(DelphiParserEND, 0)
}

func (s *CaseStatementContext) AllCaseItem() []ICaseItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseItemContext); ok {
			len++
		}
	}

	tst := make([]ICaseItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseItemContext); ok {
			tst[i] = t.(ICaseItemContext)
			i++
		}
	}

	return tst
}

func (s *CaseStatementContext) CaseItem(i int) ICaseItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseItemContext)
}

func (s *CaseStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(DelphiParserELSE, 0)
}

func (s *CaseStatementContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *CaseStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *CaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterCaseStatement(s)
	}
}

func (s *CaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitCaseStatement(s)
	}
}

func (p *DelphiParser) CaseStatement() (localctx ICaseStatementContext) {
	localctx = NewCaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, DelphiParserRULE_caseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1736)
		p.Match(DelphiParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1737)
		p.Expression()
	}
	{
		p.SetState(1738)
		p.Match(DelphiParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1742)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2576640216473309552) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2306854608771758511) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&4017210874563393021) != 0) {
		{
			p.SetState(1739)
			p.CaseItem()
		}

		p.SetState(1744)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1750)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserELSE {
		{
			p.SetState(1745)
			p.Match(DelphiParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1746)
			p.StatementList()
		}
		p.SetState(1748)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserSEMI {
			{
				p.SetState(1747)
				p.Match(DelphiParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(1752)
		p.Match(DelphiParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseItemContext is an interface to support dynamic dispatch.
type ICaseItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCaseLabel() []ICaseLabelContext
	CaseLabel(i int) ICaseLabelContext
	COLON() antlr.TerminalNode
	Statement() IStatementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsCaseItemContext differentiates from other interfaces.
	IsCaseItemContext()
}

type CaseItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseItemContext() *CaseItemContext {
	var p = new(CaseItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_caseItem
	return p
}

func InitEmptyCaseItemContext(p *CaseItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_caseItem
}

func (*CaseItemContext) IsCaseItemContext() {}

func NewCaseItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseItemContext {
	var p = new(CaseItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_caseItem

	return p
}

func (s *CaseItemContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseItemContext) AllCaseLabel() []ICaseLabelContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseLabelContext); ok {
			len++
		}
	}

	tst := make([]ICaseLabelContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseLabelContext); ok {
			tst[i] = t.(ICaseLabelContext)
			i++
		}
	}

	return tst
}

func (s *CaseItemContext) CaseLabel(i int) ICaseLabelContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseLabelContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseLabelContext)
}

func (s *CaseItemContext) COLON() antlr.TerminalNode {
	return s.GetToken(DelphiParserCOLON, 0)
}

func (s *CaseItemContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *CaseItemContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserCOMMA)
}

func (s *CaseItemContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserCOMMA, i)
}

func (s *CaseItemContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *CaseItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterCaseItem(s)
	}
}

func (s *CaseItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitCaseItem(s)
	}
}

func (p *DelphiParser) CaseItem() (localctx ICaseItemContext) {
	localctx = NewCaseItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, DelphiParserRULE_caseItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1754)
		p.CaseLabel()
	}
	p.SetState(1759)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DelphiParserCOMMA {
		{
			p.SetState(1755)
			p.Match(DelphiParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1756)
			p.CaseLabel()
		}

		p.SetState(1761)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1762)
		p.Match(DelphiParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1763)
		p.Statement()
	}
	p.SetState(1765)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserSEMI {
		{
			p.SetState(1764)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseLabelContext is an interface to support dynamic dispatch.
type ICaseLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	DOTDOT() antlr.TerminalNode

	// IsCaseLabelContext differentiates from other interfaces.
	IsCaseLabelContext()
}

type CaseLabelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseLabelContext() *CaseLabelContext {
	var p = new(CaseLabelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_caseLabel
	return p
}

func InitEmptyCaseLabelContext(p *CaseLabelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_caseLabel
}

func (*CaseLabelContext) IsCaseLabelContext() {}

func NewCaseLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseLabelContext {
	var p = new(CaseLabelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_caseLabel

	return p
}

func (s *CaseLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseLabelContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CaseLabelContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseLabelContext) DOTDOT() antlr.TerminalNode {
	return s.GetToken(DelphiParserDOTDOT, 0)
}

func (s *CaseLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterCaseLabel(s)
	}
}

func (s *CaseLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitCaseLabel(s)
	}
}

func (p *DelphiParser) CaseLabel() (localctx ICaseLabelContext) {
	localctx = NewCaseLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, DelphiParserRULE_caseLabel)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1767)
		p.Expression()
	}
	p.SetState(1770)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DelphiParserDOTDOT {
		{
			p.SetState(1768)
			p.Match(DelphiParserDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1769)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRepeatStatementContext is an interface to support dynamic dispatch.
type IRepeatStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPEAT() antlr.TerminalNode
	UNTIL() antlr.TerminalNode
	Expression() IExpressionContext
	StatementList() IStatementListContext

	// IsRepeatStatementContext differentiates from other interfaces.
	IsRepeatStatementContext()
}

type RepeatStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepeatStatementContext() *RepeatStatementContext {
	var p = new(RepeatStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_repeatStatement
	return p
}

func InitEmptyRepeatStatementContext(p *RepeatStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_repeatStatement
}

func (*RepeatStatementContext) IsRepeatStatementContext() {}

func NewRepeatStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepeatStatementContext {
	var p = new(RepeatStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_repeatStatement

	return p
}

func (s *RepeatStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RepeatStatementContext) REPEAT() antlr.TerminalNode {
	return s.GetToken(DelphiParserREPEAT, 0)
}

func (s *RepeatStatementContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(DelphiParserUNTIL, 0)
}

func (s *RepeatStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RepeatStatementContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *RepeatStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepeatStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepeatStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterRepeatStatement(s)
	}
}

func (s *RepeatStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitRepeatStatement(s)
	}
}

func (p *DelphiParser) RepeatStatement() (localctx IRepeatStatementContext) {
	localctx = NewRepeatStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, DelphiParserRULE_repeatStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1772)
		p.Match(DelphiParserREPEAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1774)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 239, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1773)
			p.StatementList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1776)
		p.Match(DelphiParserUNTIL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1777)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHILE() antlr.TerminalNode
	Expression() IExpressionContext
	DO() antlr.TerminalNode
	Statement() IStatementContext

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(DelphiParserWHILE, 0)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(DelphiParserDO, 0)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (p *DelphiParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, DelphiParserRULE_whileStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1779)
		p.Match(DelphiParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1780)
		p.Expression()
	}
	{
		p.SetState(1781)
		p.Match(DelphiParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1782)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	Designator() IDesignatorContext
	ASSIGN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	TO() antlr.TerminalNode
	DO() antlr.TerminalNode
	Statement() IStatementContext
	DOWNTO() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_forStatement
	return p
}

func InitEmptyForStatementContext(p *ForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_forStatement
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(DelphiParserFOR, 0)
}

func (s *ForStatementContext) Designator() IDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *ForStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(DelphiParserASSIGN, 0)
}

func (s *ForStatementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ForStatementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(DelphiParserTO, 0)
}

func (s *ForStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(DelphiParserDO, 0)
}

func (s *ForStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) DOWNTO() antlr.TerminalNode {
	return s.GetToken(DelphiParserDOWNTO, 0)
}

func (s *ForStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(DelphiParserIN, 0)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (p *DelphiParser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, DelphiParserRULE_forStatement)
	p.SetState(1809)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 240, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1784)
			p.Match(DelphiParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1785)
			p.Designator()
		}
		{
			p.SetState(1786)
			p.Match(DelphiParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1787)
			p.Expression()
		}
		{
			p.SetState(1788)
			p.Match(DelphiParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1789)
			p.Expression()
		}
		{
			p.SetState(1790)
			p.Match(DelphiParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1791)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1793)
			p.Match(DelphiParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1794)
			p.Designator()
		}
		{
			p.SetState(1795)
			p.Match(DelphiParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1796)
			p.Expression()
		}
		{
			p.SetState(1797)
			p.Match(DelphiParserDOWNTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1798)
			p.Expression()
		}
		{
			p.SetState(1799)
			p.Match(DelphiParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1800)
			p.Statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1802)
			p.Match(DelphiParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1803)
			p.Designator()
		}
		{
			p.SetState(1804)
			p.Match(DelphiParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1805)
			p.Expression()
		}
		{
			p.SetState(1806)
			p.Match(DelphiParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1807)
			p.Statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithStatementContext is an interface to support dynamic dispatch.
type IWithStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	WithItem() IWithItemContext
	DO() antlr.TerminalNode
	Statement() IStatementContext

	// IsWithStatementContext differentiates from other interfaces.
	IsWithStatementContext()
}

type WithStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithStatementContext() *WithStatementContext {
	var p = new(WithStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_withStatement
	return p
}

func InitEmptyWithStatementContext(p *WithStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_withStatement
}

func (*WithStatementContext) IsWithStatementContext() {}

func NewWithStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithStatementContext {
	var p = new(WithStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_withStatement

	return p
}

func (s *WithStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WithStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DelphiParserWITH, 0)
}

func (s *WithStatementContext) WithItem() IWithItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithItemContext)
}

func (s *WithStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(DelphiParserDO, 0)
}

func (s *WithStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WithStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterWithStatement(s)
	}
}

func (s *WithStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitWithStatement(s)
	}
}

func (p *DelphiParser) WithStatement() (localctx IWithStatementContext) {
	localctx = NewWithStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, DelphiParserRULE_withStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1811)
		p.Match(DelphiParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1812)
		p.WithItem()
	}
	{
		p.SetState(1813)
		p.Match(DelphiParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1814)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithItemContext is an interface to support dynamic dispatch.
type IWithItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDesignator() []IDesignatorContext
	Designator(i int) IDesignatorContext
	AS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWithItemContext differentiates from other interfaces.
	IsWithItemContext()
}

type WithItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithItemContext() *WithItemContext {
	var p = new(WithItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_withItem
	return p
}

func InitEmptyWithItemContext(p *WithItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_withItem
}

func (*WithItemContext) IsWithItemContext() {}

func NewWithItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithItemContext {
	var p = new(WithItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_withItem

	return p
}

func (s *WithItemContext) GetParser() antlr.Parser { return s.parser }

func (s *WithItemContext) AllDesignator() []IDesignatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDesignatorContext); ok {
			len++
		}
	}

	tst := make([]IDesignatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDesignatorContext); ok {
			tst[i] = t.(IDesignatorContext)
			i++
		}
	}

	return tst
}

func (s *WithItemContext) Designator(i int) IDesignatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *WithItemContext) AS() antlr.TerminalNode {
	return s.GetToken(DelphiParserAS, 0)
}

func (s *WithItemContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserCOMMA)
}

func (s *WithItemContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserCOMMA, i)
}

func (s *WithItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterWithItem(s)
	}
}

func (s *WithItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitWithItem(s)
	}
}

func (p *DelphiParser) WithItem() (localctx IWithItemContext) {
	localctx = NewWithItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, DelphiParserRULE_withItem)
	var _la int

	p.SetState(1828)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 242, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1816)
			p.Designator()
		}
		{
			p.SetState(1817)
			p.Match(DelphiParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1818)
			p.Designator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1820)
			p.Designator()
		}
		p.SetState(1825)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DelphiParserCOMMA {
			{
				p.SetState(1821)
				p.Match(DelphiParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1822)
				p.Designator()
			}

			p.SetState(1827)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompoundStatementContext is an interface to support dynamic dispatch.
type ICompoundStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGIN() antlr.TerminalNode
	END() antlr.TerminalNode
	StatementList() IStatementListContext

	// IsCompoundStatementContext differentiates from other interfaces.
	IsCompoundStatementContext()
}

type CompoundStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundStatementContext() *CompoundStatementContext {
	var p = new(CompoundStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_compoundStatement
	return p
}

func InitEmptyCompoundStatementContext(p *CompoundStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_compoundStatement
}

func (*CompoundStatementContext) IsCompoundStatementContext() {}

func NewCompoundStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundStatementContext {
	var p = new(CompoundStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_compoundStatement

	return p
}

func (s *CompoundStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundStatementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(DelphiParserBEGIN, 0)
}

func (s *CompoundStatementContext) END() antlr.TerminalNode {
	return s.GetToken(DelphiParserEND, 0)
}

func (s *CompoundStatementContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *CompoundStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitCompoundStatement(s)
	}
}

func (p *DelphiParser) CompoundStatement() (localctx ICompoundStatementContext) {
	localctx = NewCompoundStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, DelphiParserRULE_compoundStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1830)
		p.Match(DelphiParserBEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1832)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 243, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1831)
			p.StatementList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1834)
		p.Match(DelphiParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementListContext is an interface to support dynamic dispatch.
type IStatementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsStatementListContext differentiates from other interfaces.
	IsStatementListContext()
}

type StatementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementListContext() *StatementListContext {
	var p = new(StatementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_statementList
	return p
}

func InitEmptyStatementListContext(p *StatementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_statementList
}

func (*StatementListContext) IsStatementListContext() {}

func NewStatementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementListContext {
	var p = new(StatementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_statementList

	return p
}

func (s *StatementListContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementListContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementListContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementListContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserSEMI)
}

func (s *StatementListContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, i)
}

func (s *StatementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterStatementList(s)
	}
}

func (s *StatementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitStatementList(s)
	}
}

func (p *DelphiParser) StatementList() (localctx IStatementListContext) {
	localctx = NewStatementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, DelphiParserRULE_statementList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1837)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 244, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1836)
			p.Statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1845)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 246, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1839)
				p.Match(DelphiParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1841)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 245, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1840)
					p.Statement()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		p.SetState(1847)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 246, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleStatementContext is an interface to support dynamic dispatch.
type ISimpleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Designator() IDesignatorContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext
	GotoStatement() IGotoStatementContext

	// IsSimpleStatementContext differentiates from other interfaces.
	IsSimpleStatementContext()
}

type SimpleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleStatementContext() *SimpleStatementContext {
	var p = new(SimpleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_simpleStatement
	return p
}

func InitEmptySimpleStatementContext(p *SimpleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_simpleStatement
}

func (*SimpleStatementContext) IsSimpleStatementContext() {}

func NewSimpleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleStatementContext {
	var p = new(SimpleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_simpleStatement

	return p
}

func (s *SimpleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleStatementContext) Designator() IDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *SimpleStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(DelphiParserASSIGN, 0)
}

func (s *SimpleStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleStatementContext) GotoStatement() IGotoStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGotoStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGotoStatementContext)
}

func (s *SimpleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterSimpleStatement(s)
	}
}

func (s *SimpleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitSimpleStatement(s)
	}
}

func (p *DelphiParser) SimpleStatement() (localctx ISimpleStatementContext) {
	localctx = NewSimpleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, DelphiParserRULE_simpleStatement)
	p.SetState(1854)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 247, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1848)
			p.Designator()
		}
		{
			p.SetState(1849)
			p.Match(DelphiParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1850)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1852)
			p.Designator()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1853)
			p.GotoStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGotoStatementContext is an interface to support dynamic dispatch.
type IGotoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GOTO() antlr.TerminalNode
	Label() ILabelContext
	EXIT() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	BREAK() antlr.TerminalNode
	CONTINUE() antlr.TerminalNode

	// IsGotoStatementContext differentiates from other interfaces.
	IsGotoStatementContext()
}

type GotoStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGotoStatementContext() *GotoStatementContext {
	var p = new(GotoStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_gotoStatement
	return p
}

func InitEmptyGotoStatementContext(p *GotoStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_gotoStatement
}

func (*GotoStatementContext) IsGotoStatementContext() {}

func NewGotoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GotoStatementContext {
	var p = new(GotoStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_gotoStatement

	return p
}

func (s *GotoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GotoStatementContext) GOTO() antlr.TerminalNode {
	return s.GetToken(DelphiParserGOTO, 0)
}

func (s *GotoStatementContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *GotoStatementContext) EXIT() antlr.TerminalNode {
	return s.GetToken(DelphiParserEXIT, 0)
}

func (s *GotoStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserLPAREN, 0)
}

func (s *GotoStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GotoStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserRPAREN, 0)
}

func (s *GotoStatementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(DelphiParserBREAK, 0)
}

func (s *GotoStatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(DelphiParserCONTINUE, 0)
}

func (s *GotoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GotoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GotoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterGotoStatement(s)
	}
}

func (s *GotoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitGotoStatement(s)
	}
}

func (p *DelphiParser) GotoStatement() (localctx IGotoStatementContext) {
	localctx = NewGotoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, DelphiParserRULE_gotoStatement)
	var _la int

	p.SetState(1866)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserGOTO:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1856)
			p.Match(DelphiParserGOTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1857)
			p.Label()
		}

	case DelphiParserEXIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1858)
			p.Match(DelphiParserEXIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1863)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 248, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1859)
				p.Match(DelphiParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1860)
				p.Expression()
			}
			{
				p.SetState(1861)
				p.Match(DelphiParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case DelphiParserBREAK, DelphiParserCONTINUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1865)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DelphiParserBREAK || _la == DelphiParserCONTINUE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstExpressionContext is an interface to support dynamic dispatch.
type IConstExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllRecordConstExpression() []IRecordConstExpressionContext
	RecordConstExpression(i int) IRecordConstExpressionContext
	RPAREN() antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllConstExpression() []IConstExpressionContext
	ConstExpression(i int) IConstExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	Expression() IExpressionContext

	// IsConstExpressionContext differentiates from other interfaces.
	IsConstExpressionContext()
}

type ConstExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstExpressionContext() *ConstExpressionContext {
	var p = new(ConstExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_constExpression
	return p
}

func InitEmptyConstExpressionContext(p *ConstExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_constExpression
}

func (*ConstExpressionContext) IsConstExpressionContext() {}

func NewConstExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstExpressionContext {
	var p = new(ConstExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_constExpression

	return p
}

func (s *ConstExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserLPAREN, 0)
}

func (s *ConstExpressionContext) AllRecordConstExpression() []IRecordConstExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordConstExpressionContext); ok {
			len++
		}
	}

	tst := make([]IRecordConstExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordConstExpressionContext); ok {
			tst[i] = t.(IRecordConstExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ConstExpressionContext) RecordConstExpression(i int) IRecordConstExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordConstExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordConstExpressionContext)
}

func (s *ConstExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(DelphiParserRPAREN, 0)
}

func (s *ConstExpressionContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserSEMI)
}

func (s *ConstExpressionContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, i)
}

func (s *ConstExpressionContext) AllConstExpression() []IConstExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstExpressionContext); ok {
			len++
		}
	}

	tst := make([]IConstExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstExpressionContext); ok {
			tst[i] = t.(IConstExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ConstExpressionContext) ConstExpression(i int) IConstExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstExpressionContext)
}

func (s *ConstExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserCOMMA)
}

func (s *ConstExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserCOMMA, i)
}

func (s *ConstExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConstExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterConstExpression(s)
	}
}

func (s *ConstExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitConstExpression(s)
	}
}

func (p *DelphiParser) ConstExpression() (localctx IConstExpressionContext) {
	localctx = NewConstExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, DelphiParserRULE_constExpression)
	var _la int

	p.SetState(1891)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 252, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1868)
			p.Match(DelphiParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1869)
			p.RecordConstExpression()
		}
		p.SetState(1874)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DelphiParserSEMI {
			{
				p.SetState(1870)
				p.Match(DelphiParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1871)
				p.RecordConstExpression()
			}

			p.SetState(1876)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1877)
			p.Match(DelphiParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1879)
			p.Match(DelphiParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1880)
			p.ConstExpression()
		}
		p.SetState(1885)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DelphiParserCOMMA {
			{
				p.SetState(1881)
				p.Match(DelphiParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1882)
				p.ConstExpression()
			}

			p.SetState(1887)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1888)
			p.Match(DelphiParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1890)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordConstExpressionContext is an interface to support dynamic dispatch.
type IRecordConstExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ident() IIdentContext
	COLON() antlr.TerminalNode
	ConstExpression() IConstExpressionContext

	// IsRecordConstExpressionContext differentiates from other interfaces.
	IsRecordConstExpressionContext()
}

type RecordConstExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordConstExpressionContext() *RecordConstExpressionContext {
	var p = new(RecordConstExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_recordConstExpression
	return p
}

func InitEmptyRecordConstExpressionContext(p *RecordConstExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_recordConstExpression
}

func (*RecordConstExpressionContext) IsRecordConstExpressionContext() {}

func NewRecordConstExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordConstExpressionContext {
	var p = new(RecordConstExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_recordConstExpression

	return p
}

func (s *RecordConstExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordConstExpressionContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *RecordConstExpressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(DelphiParserCOLON, 0)
}

func (s *RecordConstExpressionContext) ConstExpression() IConstExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstExpressionContext)
}

func (s *RecordConstExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordConstExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordConstExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterRecordConstExpression(s)
	}
}

func (s *RecordConstExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitRecordConstExpression(s)
	}
}

func (p *DelphiParser) RecordConstExpression() (localctx IRecordConstExpressionContext) {
	localctx = NewRecordConstExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, DelphiParserRULE_recordConstExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1893)
		p.Ident()
	}
	{
		p.SetState(1894)
		p.Match(DelphiParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1895)
		p.ConstExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryStatementContext is an interface to support dynamic dispatch.
type ITryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	HandlerList() IHandlerListContext
	END() antlr.TerminalNode
	AllStatementList() []IStatementListContext
	StatementList(i int) IStatementListContext
	FINALLY() antlr.TerminalNode

	// IsTryStatementContext differentiates from other interfaces.
	IsTryStatementContext()
}

type TryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryStatementContext() *TryStatementContext {
	var p = new(TryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_tryStatement
	return p
}

func InitEmptyTryStatementContext(p *TryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_tryStatement
}

func (*TryStatementContext) IsTryStatementContext() {}

func NewTryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryStatementContext {
	var p = new(TryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_tryStatement

	return p
}

func (s *TryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryStatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(DelphiParserTRY, 0)
}

func (s *TryStatementContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(DelphiParserEXCEPT, 0)
}

func (s *TryStatementContext) HandlerList() IHandlerListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerListContext)
}

func (s *TryStatementContext) END() antlr.TerminalNode {
	return s.GetToken(DelphiParserEND, 0)
}

func (s *TryStatementContext) AllStatementList() []IStatementListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementListContext); ok {
			len++
		}
	}

	tst := make([]IStatementListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementListContext); ok {
			tst[i] = t.(IStatementListContext)
			i++
		}
	}

	return tst
}

func (s *TryStatementContext) StatementList(i int) IStatementListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *TryStatementContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(DelphiParserFINALLY, 0)
}

func (s *TryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterTryStatement(s)
	}
}

func (s *TryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitTryStatement(s)
	}
}

func (p *DelphiParser) TryStatement() (localctx ITryStatementContext) {
	localctx = NewTryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, DelphiParserRULE_tryStatement)
	p.SetState(1914)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 256, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1897)
			p.Match(DelphiParserTRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1899)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 253, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1898)
				p.StatementList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1901)
			p.Match(DelphiParserEXCEPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1902)
			p.HandlerList()
		}
		{
			p.SetState(1903)
			p.Match(DelphiParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1905)
			p.Match(DelphiParserTRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1907)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 254, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1906)
				p.StatementList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1909)
			p.Match(DelphiParserFINALLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1911)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 255, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1910)
				p.StatementList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1913)
			p.Match(DelphiParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerListContext is an interface to support dynamic dispatch.
type IHandlerListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllHandler() []IHandlerContext
	Handler(i int) IHandlerContext
	ELSE() antlr.TerminalNode
	StatementList() IStatementListContext

	// IsHandlerListContext differentiates from other interfaces.
	IsHandlerListContext()
}

type HandlerListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerListContext() *HandlerListContext {
	var p = new(HandlerListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_handlerList
	return p
}

func InitEmptyHandlerListContext(p *HandlerListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_handlerList
}

func (*HandlerListContext) IsHandlerListContext() {}

func NewHandlerListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerListContext {
	var p = new(HandlerListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_handlerList

	return p
}

func (s *HandlerListContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerListContext) AllHandler() []IHandlerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHandlerContext); ok {
			len++
		}
	}

	tst := make([]IHandlerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHandlerContext); ok {
			tst[i] = t.(IHandlerContext)
			i++
		}
	}

	return tst
}

func (s *HandlerListContext) Handler(i int) IHandlerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerContext)
}

func (s *HandlerListContext) ELSE() antlr.TerminalNode {
	return s.GetToken(DelphiParserELSE, 0)
}

func (s *HandlerListContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *HandlerListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterHandlerList(s)
	}
}

func (s *HandlerListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitHandlerList(s)
	}
}

func (p *DelphiParser) HandlerList() (localctx IHandlerListContext) {
	localctx = NewHandlerListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, DelphiParserRULE_handlerList)
	var _la int

	p.SetState(1927)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 259, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1919)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DelphiParserON {
			{
				p.SetState(1916)
				p.Handler()
			}

			p.SetState(1921)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1924)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserELSE {
			{
				p.SetState(1922)
				p.Match(DelphiParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1923)
				p.StatementList()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1926)
			p.StatementList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerContext is an interface to support dynamic dispatch.
type IHandlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	TypeId() ITypeIdContext
	DO() antlr.TerminalNode
	HandlerStatement() IHandlerStatementContext
	HandlerIdent() IHandlerIdentContext

	// IsHandlerContext differentiates from other interfaces.
	IsHandlerContext()
}

type HandlerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerContext() *HandlerContext {
	var p = new(HandlerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_handler
	return p
}

func InitEmptyHandlerContext(p *HandlerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_handler
}

func (*HandlerContext) IsHandlerContext() {}

func NewHandlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerContext {
	var p = new(HandlerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_handler

	return p
}

func (s *HandlerContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerContext) ON() antlr.TerminalNode {
	return s.GetToken(DelphiParserON, 0)
}

func (s *HandlerContext) TypeId() ITypeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdContext)
}

func (s *HandlerContext) DO() antlr.TerminalNode {
	return s.GetToken(DelphiParserDO, 0)
}

func (s *HandlerContext) HandlerStatement() IHandlerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerStatementContext)
}

func (s *HandlerContext) HandlerIdent() IHandlerIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerIdentContext)
}

func (s *HandlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterHandler(s)
	}
}

func (s *HandlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitHandler(s)
	}
}

func (p *DelphiParser) Handler() (localctx IHandlerContext) {
	localctx = NewHandlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, DelphiParserRULE_handler)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1929)
		p.Match(DelphiParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1931)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 260, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1930)
			p.HandlerIdent()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1933)
		p.TypeId()
	}
	{
		p.SetState(1934)
		p.Match(DelphiParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1935)
		p.HandlerStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerIdentContext is an interface to support dynamic dispatch.
type IHandlerIdentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ident() IIdentContext
	COLON() antlr.TerminalNode

	// IsHandlerIdentContext differentiates from other interfaces.
	IsHandlerIdentContext()
}

type HandlerIdentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerIdentContext() *HandlerIdentContext {
	var p = new(HandlerIdentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_handlerIdent
	return p
}

func InitEmptyHandlerIdentContext(p *HandlerIdentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_handlerIdent
}

func (*HandlerIdentContext) IsHandlerIdentContext() {}

func NewHandlerIdentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerIdentContext {
	var p = new(HandlerIdentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_handlerIdent

	return p
}

func (s *HandlerIdentContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerIdentContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *HandlerIdentContext) COLON() antlr.TerminalNode {
	return s.GetToken(DelphiParserCOLON, 0)
}

func (s *HandlerIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerIdentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerIdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterHandlerIdent(s)
	}
}

func (s *HandlerIdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitHandlerIdent(s)
	}
}

func (p *DelphiParser) HandlerIdent() (localctx IHandlerIdentContext) {
	localctx = NewHandlerIdentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, DelphiParserRULE_handlerIdent)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1937)
		p.Ident()
	}
	{
		p.SetState(1938)
		p.Match(DelphiParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerStatementContext is an interface to support dynamic dispatch.
type IHandlerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext
	SEMI() antlr.TerminalNode

	// IsHandlerStatementContext differentiates from other interfaces.
	IsHandlerStatementContext()
}

type HandlerStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerStatementContext() *HandlerStatementContext {
	var p = new(HandlerStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_handlerStatement
	return p
}

func InitEmptyHandlerStatementContext(p *HandlerStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_handlerStatement
}

func (*HandlerStatementContext) IsHandlerStatementContext() {}

func NewHandlerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerStatementContext {
	var p = new(HandlerStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_handlerStatement

	return p
}

func (s *HandlerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *HandlerStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *HandlerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterHandlerStatement(s)
	}
}

func (s *HandlerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitHandlerStatement(s)
	}
}

func (p *DelphiParser) HandlerStatement() (localctx IHandlerStatementContext) {
	localctx = NewHandlerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, DelphiParserRULE_handlerStatement)
	var _la int

	p.SetState(1945)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 262, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1940)
			p.Statement()
		}
		p.SetState(1942)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserSEMI {
			{
				p.SetState(1941)
				p.Match(DelphiParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1944)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRaiseStatementContext is an interface to support dynamic dispatch.
type IRaiseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RAISE() antlr.TerminalNode
	AllDesignator() []IDesignatorContext
	Designator(i int) IDesignatorContext
	AT() antlr.TerminalNode

	// IsRaiseStatementContext differentiates from other interfaces.
	IsRaiseStatementContext()
}

type RaiseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaiseStatementContext() *RaiseStatementContext {
	var p = new(RaiseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_raiseStatement
	return p
}

func InitEmptyRaiseStatementContext(p *RaiseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_raiseStatement
}

func (*RaiseStatementContext) IsRaiseStatementContext() {}

func NewRaiseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RaiseStatementContext {
	var p = new(RaiseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_raiseStatement

	return p
}

func (s *RaiseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RaiseStatementContext) RAISE() antlr.TerminalNode {
	return s.GetToken(DelphiParserRAISE, 0)
}

func (s *RaiseStatementContext) AllDesignator() []IDesignatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDesignatorContext); ok {
			len++
		}
	}

	tst := make([]IDesignatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDesignatorContext); ok {
			tst[i] = t.(IDesignatorContext)
			i++
		}
	}

	return tst
}

func (s *RaiseStatementContext) Designator(i int) IDesignatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *RaiseStatementContext) AT() antlr.TerminalNode {
	return s.GetToken(DelphiParserAT, 0)
}

func (s *RaiseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RaiseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RaiseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterRaiseStatement(s)
	}
}

func (s *RaiseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitRaiseStatement(s)
	}
}

func (p *DelphiParser) RaiseStatement() (localctx IRaiseStatementContext) {
	localctx = NewRaiseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, DelphiParserRULE_raiseStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1947)
		p.Match(DelphiParserRAISE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1949)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 263, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1948)
			p.Designator()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1953)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 264, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1951)
			p.Match(DelphiParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1952)
			p.Designator()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssemblerStatementContext is an interface to support dynamic dispatch.
type IAssemblerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASM() antlr.TerminalNode
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode

	// IsAssemblerStatementContext differentiates from other interfaces.
	IsAssemblerStatementContext()
}

type AssemblerStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblerStatementContext() *AssemblerStatementContext {
	var p = new(AssemblerStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_assemblerStatement
	return p
}

func InitEmptyAssemblerStatementContext(p *AssemblerStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_assemblerStatement
}

func (*AssemblerStatementContext) IsAssemblerStatementContext() {}

func NewAssemblerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblerStatementContext {
	var p = new(AssemblerStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_assemblerStatement

	return p
}

func (s *AssemblerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblerStatementContext) ASM() antlr.TerminalNode {
	return s.GetToken(DelphiParserASM, 0)
}

func (s *AssemblerStatementContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserEND)
}

func (s *AssemblerStatementContext) END(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserEND, i)
}

func (s *AssemblerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterAssemblerStatement(s)
	}
}

func (s *AssemblerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitAssemblerStatement(s)
	}
}

func (p *DelphiParser) AssemblerStatement() (localctx IAssemblerStatementContext) {
	localctx = NewAssemblerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, DelphiParserRULE_assemblerStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1955)
		p.Match(DelphiParserASM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1959)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-34359738370) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-1) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&7) != 0) {
		{
			p.SetState(1956)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == DelphiParserEND {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		p.SetState(1961)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1962)
		p.Match(DelphiParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodDirectiveContext is an interface to support dynamic dispatch.
type IMethodDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReintroduceDirective() IReintroduceDirectiveContext
	OverloadDirective() IOverloadDirectiveContext
	BindingDirective() IBindingDirectiveContext
	AbstractDirective() IAbstractDirectiveContext
	InlineDirective() IInlineDirectiveContext
	CallConvention() ICallConventionContext
	HintingDirective() IHintingDirectiveContext
	SEMI() antlr.TerminalNode
	OldCallConventionDirective() IOldCallConventionDirectiveContext
	DispIDDirective() IDispIDDirectiveContext

	// IsMethodDirectiveContext differentiates from other interfaces.
	IsMethodDirectiveContext()
}

type MethodDirectiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodDirectiveContext() *MethodDirectiveContext {
	var p = new(MethodDirectiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_methodDirective
	return p
}

func InitEmptyMethodDirectiveContext(p *MethodDirectiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_methodDirective
}

func (*MethodDirectiveContext) IsMethodDirectiveContext() {}

func NewMethodDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDirectiveContext {
	var p = new(MethodDirectiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_methodDirective

	return p
}

func (s *MethodDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDirectiveContext) ReintroduceDirective() IReintroduceDirectiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReintroduceDirectiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReintroduceDirectiveContext)
}

func (s *MethodDirectiveContext) OverloadDirective() IOverloadDirectiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverloadDirectiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverloadDirectiveContext)
}

func (s *MethodDirectiveContext) BindingDirective() IBindingDirectiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingDirectiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingDirectiveContext)
}

func (s *MethodDirectiveContext) AbstractDirective() IAbstractDirectiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbstractDirectiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbstractDirectiveContext)
}

func (s *MethodDirectiveContext) InlineDirective() IInlineDirectiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineDirectiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineDirectiveContext)
}

func (s *MethodDirectiveContext) CallConvention() ICallConventionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallConventionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallConventionContext)
}

func (s *MethodDirectiveContext) HintingDirective() IHintingDirectiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintingDirectiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintingDirectiveContext)
}

func (s *MethodDirectiveContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *MethodDirectiveContext) OldCallConventionDirective() IOldCallConventionDirectiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOldCallConventionDirectiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOldCallConventionDirectiveContext)
}

func (s *MethodDirectiveContext) DispIDDirective() IDispIDDirectiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDispIDDirectiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDispIDDirectiveContext)
}

func (s *MethodDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterMethodDirective(s)
	}
}

func (s *MethodDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitMethodDirective(s)
	}
}

func (p *DelphiParser) MethodDirective() (localctx IMethodDirectiveContext) {
	localctx = NewMethodDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, DelphiParserRULE_methodDirective)
	p.SetState(1975)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserREINTRODUCE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1964)
			p.ReintroduceDirective()
		}

	case DelphiParserOVERLOAD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1965)
			p.OverloadDirective()
		}

	case DelphiParserDYNAMIC, DelphiParserMESSAGE, DelphiParserOVERRIDE, DelphiParserSTATIC, DelphiParserVIRTUAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1966)
			p.BindingDirective()
		}

	case DelphiParserABSTRACT, DelphiParserFINAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1967)
			p.AbstractDirective()
		}

	case DelphiParserASSEMBLER, DelphiParserINLINE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1968)
			p.InlineDirective()
		}

	case DelphiParserCDECL, DelphiParserEXPORT, DelphiParserPASCAL, DelphiParserREGISTER, DelphiParserSAFECALL, DelphiParserSTDCALL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1969)
			p.CallConvention()
		}

	case DelphiParserDEPRECATED, DelphiParserEXPERIMENTAL, DelphiParserLIBRARY, DelphiParserPLATFORM:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1970)
			p.HintingDirective()
		}
		{
			p.SetState(1971)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserFAR, DelphiParserLOCAL, DelphiParserNEAR:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1973)
			p.OldCallConventionDirective()
		}

	case DelphiParserDISPID:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1974)
			p.DispIDDirective()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDirectiveContext is an interface to support dynamic dispatch.
type IFunctionDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OverloadDirective() IOverloadDirectiveContext
	InlineDirective() IInlineDirectiveContext
	CallConvention() ICallConventionContext
	OldCallConventionDirective() IOldCallConventionDirectiveContext
	HintingDirective() IHintingDirectiveContext
	SEMI() antlr.TerminalNode
	ExternalDirective() IExternalDirectiveContext
	CallConventionNoSemi() ICallConventionNoSemiContext
	UNSAFE() antlr.TerminalNode

	// IsFunctionDirectiveContext differentiates from other interfaces.
	IsFunctionDirectiveContext()
}

type FunctionDirectiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDirectiveContext() *FunctionDirectiveContext {
	var p = new(FunctionDirectiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_functionDirective
	return p
}

func InitEmptyFunctionDirectiveContext(p *FunctionDirectiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_functionDirective
}

func (*FunctionDirectiveContext) IsFunctionDirectiveContext() {}

func NewFunctionDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDirectiveContext {
	var p = new(FunctionDirectiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_functionDirective

	return p
}

func (s *FunctionDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDirectiveContext) OverloadDirective() IOverloadDirectiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverloadDirectiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverloadDirectiveContext)
}

func (s *FunctionDirectiveContext) InlineDirective() IInlineDirectiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineDirectiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineDirectiveContext)
}

func (s *FunctionDirectiveContext) CallConvention() ICallConventionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallConventionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallConventionContext)
}

func (s *FunctionDirectiveContext) OldCallConventionDirective() IOldCallConventionDirectiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOldCallConventionDirectiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOldCallConventionDirectiveContext)
}

func (s *FunctionDirectiveContext) HintingDirective() IHintingDirectiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintingDirectiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintingDirectiveContext)
}

func (s *FunctionDirectiveContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *FunctionDirectiveContext) ExternalDirective() IExternalDirectiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternalDirectiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternalDirectiveContext)
}

func (s *FunctionDirectiveContext) CallConventionNoSemi() ICallConventionNoSemiContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallConventionNoSemiContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallConventionNoSemiContext)
}

func (s *FunctionDirectiveContext) UNSAFE() antlr.TerminalNode {
	return s.GetToken(DelphiParserUNSAFE, 0)
}

func (s *FunctionDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterFunctionDirective(s)
	}
}

func (s *FunctionDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitFunctionDirective(s)
	}
}

func (p *DelphiParser) FunctionDirective() (localctx IFunctionDirectiveContext) {
	localctx = NewFunctionDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, DelphiParserRULE_functionDirective)
	var _la int

	p.SetState(1990)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 268, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1977)
			p.OverloadDirective()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1978)
			p.InlineDirective()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1979)
			p.CallConvention()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1980)
			p.OldCallConventionDirective()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1981)
			p.HintingDirective()
		}
		{
			p.SetState(1982)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1985)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserCDECL || _la == DelphiParserEXPORT || ((int64((_la-82)) & ^0x3f) == 0 && ((int64(1)<<(_la-82))&272662529) != 0) {
			{
				p.SetState(1984)
				p.CallConventionNoSemi()
			}

		}
		{
			p.SetState(1987)
			p.ExternalDirective()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1988)
			p.Match(DelphiParserUNSAFE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1989)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReintroduceDirectiveContext is an interface to support dynamic dispatch.
type IReintroduceDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REINTRODUCE() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsReintroduceDirectiveContext differentiates from other interfaces.
	IsReintroduceDirectiveContext()
}

type ReintroduceDirectiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReintroduceDirectiveContext() *ReintroduceDirectiveContext {
	var p = new(ReintroduceDirectiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_reintroduceDirective
	return p
}

func InitEmptyReintroduceDirectiveContext(p *ReintroduceDirectiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_reintroduceDirective
}

func (*ReintroduceDirectiveContext) IsReintroduceDirectiveContext() {}

func NewReintroduceDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReintroduceDirectiveContext {
	var p = new(ReintroduceDirectiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_reintroduceDirective

	return p
}

func (s *ReintroduceDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *ReintroduceDirectiveContext) REINTRODUCE() antlr.TerminalNode {
	return s.GetToken(DelphiParserREINTRODUCE, 0)
}

func (s *ReintroduceDirectiveContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *ReintroduceDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReintroduceDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReintroduceDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterReintroduceDirective(s)
	}
}

func (s *ReintroduceDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitReintroduceDirective(s)
	}
}

func (p *DelphiParser) ReintroduceDirective() (localctx IReintroduceDirectiveContext) {
	localctx = NewReintroduceDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, DelphiParserRULE_reintroduceDirective)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1992)
		p.Match(DelphiParserREINTRODUCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1993)
		p.Match(DelphiParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOverloadDirectiveContext is an interface to support dynamic dispatch.
type IOverloadDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OVERLOAD() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsOverloadDirectiveContext differentiates from other interfaces.
	IsOverloadDirectiveContext()
}

type OverloadDirectiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOverloadDirectiveContext() *OverloadDirectiveContext {
	var p = new(OverloadDirectiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_overloadDirective
	return p
}

func InitEmptyOverloadDirectiveContext(p *OverloadDirectiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_overloadDirective
}

func (*OverloadDirectiveContext) IsOverloadDirectiveContext() {}

func NewOverloadDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverloadDirectiveContext {
	var p = new(OverloadDirectiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_overloadDirective

	return p
}

func (s *OverloadDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *OverloadDirectiveContext) OVERLOAD() antlr.TerminalNode {
	return s.GetToken(DelphiParserOVERLOAD, 0)
}

func (s *OverloadDirectiveContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *OverloadDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverloadDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverloadDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterOverloadDirective(s)
	}
}

func (s *OverloadDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitOverloadDirective(s)
	}
}

func (p *DelphiParser) OverloadDirective() (localctx IOverloadDirectiveContext) {
	localctx = NewOverloadDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, DelphiParserRULE_overloadDirective)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1995)
		p.Match(DelphiParserOVERLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1997)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 269, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1996)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindingDirectiveContext is an interface to support dynamic dispatch.
type IBindingDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MESSAGE() antlr.TerminalNode
	Expression() IExpressionContext
	SEMI() antlr.TerminalNode
	STATIC() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	OVERRIDE() antlr.TerminalNode
	VIRTUAL() antlr.TerminalNode

	// IsBindingDirectiveContext differentiates from other interfaces.
	IsBindingDirectiveContext()
}

type BindingDirectiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindingDirectiveContext() *BindingDirectiveContext {
	var p = new(BindingDirectiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_bindingDirective
	return p
}

func InitEmptyBindingDirectiveContext(p *BindingDirectiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_bindingDirective
}

func (*BindingDirectiveContext) IsBindingDirectiveContext() {}

func NewBindingDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindingDirectiveContext {
	var p = new(BindingDirectiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_bindingDirective

	return p
}

func (s *BindingDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *BindingDirectiveContext) MESSAGE() antlr.TerminalNode {
	return s.GetToken(DelphiParserMESSAGE, 0)
}

func (s *BindingDirectiveContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BindingDirectiveContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *BindingDirectiveContext) STATIC() antlr.TerminalNode {
	return s.GetToken(DelphiParserSTATIC, 0)
}

func (s *BindingDirectiveContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(DelphiParserDYNAMIC, 0)
}

func (s *BindingDirectiveContext) OVERRIDE() antlr.TerminalNode {
	return s.GetToken(DelphiParserOVERRIDE, 0)
}

func (s *BindingDirectiveContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(DelphiParserVIRTUAL, 0)
}

func (s *BindingDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindingDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BindingDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterBindingDirective(s)
	}
}

func (s *BindingDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitBindingDirective(s)
	}
}

func (p *DelphiParser) BindingDirective() (localctx IBindingDirectiveContext) {
	localctx = NewBindingDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, DelphiParserRULE_bindingDirective)
	p.SetState(2011)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserMESSAGE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1999)
			p.Match(DelphiParserMESSAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2000)
			p.Expression()
		}
		{
			p.SetState(2001)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserSTATIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2003)
			p.Match(DelphiParserSTATIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2004)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserDYNAMIC:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2005)
			p.Match(DelphiParserDYNAMIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2006)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserOVERRIDE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2007)
			p.Match(DelphiParserOVERRIDE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2008)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserVIRTUAL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2009)
			p.Match(DelphiParserVIRTUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2010)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAbstractDirectiveContext is an interface to support dynamic dispatch.
type IAbstractDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ABSTRACT() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	FINAL() antlr.TerminalNode

	// IsAbstractDirectiveContext differentiates from other interfaces.
	IsAbstractDirectiveContext()
}

type AbstractDirectiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstractDirectiveContext() *AbstractDirectiveContext {
	var p = new(AbstractDirectiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_abstractDirective
	return p
}

func InitEmptyAbstractDirectiveContext(p *AbstractDirectiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_abstractDirective
}

func (*AbstractDirectiveContext) IsAbstractDirectiveContext() {}

func NewAbstractDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbstractDirectiveContext {
	var p = new(AbstractDirectiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_abstractDirective

	return p
}

func (s *AbstractDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *AbstractDirectiveContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(DelphiParserABSTRACT, 0)
}

func (s *AbstractDirectiveContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *AbstractDirectiveContext) FINAL() antlr.TerminalNode {
	return s.GetToken(DelphiParserFINAL, 0)
}

func (s *AbstractDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbstractDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbstractDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterAbstractDirective(s)
	}
}

func (s *AbstractDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitAbstractDirective(s)
	}
}

func (p *DelphiParser) AbstractDirective() (localctx IAbstractDirectiveContext) {
	localctx = NewAbstractDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, DelphiParserRULE_abstractDirective)
	p.SetState(2017)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserABSTRACT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2013)
			p.Match(DelphiParserABSTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2014)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserFINAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2015)
			p.Match(DelphiParserFINAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2016)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlineDirectiveContext is an interface to support dynamic dispatch.
type IInlineDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INLINE() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	ASSEMBLER() antlr.TerminalNode

	// IsInlineDirectiveContext differentiates from other interfaces.
	IsInlineDirectiveContext()
}

type InlineDirectiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineDirectiveContext() *InlineDirectiveContext {
	var p = new(InlineDirectiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_inlineDirective
	return p
}

func InitEmptyInlineDirectiveContext(p *InlineDirectiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_inlineDirective
}

func (*InlineDirectiveContext) IsInlineDirectiveContext() {}

func NewInlineDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineDirectiveContext {
	var p = new(InlineDirectiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_inlineDirective

	return p
}

func (s *InlineDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineDirectiveContext) INLINE() antlr.TerminalNode {
	return s.GetToken(DelphiParserINLINE, 0)
}

func (s *InlineDirectiveContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *InlineDirectiveContext) ASSEMBLER() antlr.TerminalNode {
	return s.GetToken(DelphiParserASSEMBLER, 0)
}

func (s *InlineDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterInlineDirective(s)
	}
}

func (s *InlineDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitInlineDirective(s)
	}
}

func (p *DelphiParser) InlineDirective() (localctx IInlineDirectiveContext) {
	localctx = NewInlineDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, DelphiParserRULE_inlineDirective)
	p.SetState(2023)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserINLINE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2019)
			p.Match(DelphiParserINLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2020)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserASSEMBLER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2021)
			p.Match(DelphiParserASSEMBLER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2022)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallConventionContext is an interface to support dynamic dispatch.
type ICallConventionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CDECL() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	PASCAL() antlr.TerminalNode
	REGISTER() antlr.TerminalNode
	SAFECALL() antlr.TerminalNode
	STDCALL() antlr.TerminalNode
	EXPORT() antlr.TerminalNode

	// IsCallConventionContext differentiates from other interfaces.
	IsCallConventionContext()
}

type CallConventionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallConventionContext() *CallConventionContext {
	var p = new(CallConventionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_callConvention
	return p
}

func InitEmptyCallConventionContext(p *CallConventionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_callConvention
}

func (*CallConventionContext) IsCallConventionContext() {}

func NewCallConventionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallConventionContext {
	var p = new(CallConventionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_callConvention

	return p
}

func (s *CallConventionContext) GetParser() antlr.Parser { return s.parser }

func (s *CallConventionContext) CDECL() antlr.TerminalNode {
	return s.GetToken(DelphiParserCDECL, 0)
}

func (s *CallConventionContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *CallConventionContext) PASCAL() antlr.TerminalNode {
	return s.GetToken(DelphiParserPASCAL, 0)
}

func (s *CallConventionContext) REGISTER() antlr.TerminalNode {
	return s.GetToken(DelphiParserREGISTER, 0)
}

func (s *CallConventionContext) SAFECALL() antlr.TerminalNode {
	return s.GetToken(DelphiParserSAFECALL, 0)
}

func (s *CallConventionContext) STDCALL() antlr.TerminalNode {
	return s.GetToken(DelphiParserSTDCALL, 0)
}

func (s *CallConventionContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DelphiParserEXPORT, 0)
}

func (s *CallConventionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallConventionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallConventionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterCallConvention(s)
	}
}

func (s *CallConventionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitCallConvention(s)
	}
}

func (p *DelphiParser) CallConvention() (localctx ICallConventionContext) {
	localctx = NewCallConventionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, DelphiParserRULE_callConvention)
	p.SetState(2037)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserCDECL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2025)
			p.Match(DelphiParserCDECL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2026)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserPASCAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2027)
			p.Match(DelphiParserPASCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2028)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserREGISTER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2029)
			p.Match(DelphiParserREGISTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2030)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserSAFECALL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2031)
			p.Match(DelphiParserSAFECALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2032)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserSTDCALL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2033)
			p.Match(DelphiParserSTDCALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2034)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserEXPORT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2035)
			p.Match(DelphiParserEXPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2036)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallConventionNoSemiContext is an interface to support dynamic dispatch.
type ICallConventionNoSemiContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CDECL() antlr.TerminalNode
	PASCAL() antlr.TerminalNode
	REGISTER() antlr.TerminalNode
	SAFECALL() antlr.TerminalNode
	STDCALL() antlr.TerminalNode
	EXPORT() antlr.TerminalNode

	// IsCallConventionNoSemiContext differentiates from other interfaces.
	IsCallConventionNoSemiContext()
}

type CallConventionNoSemiContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallConventionNoSemiContext() *CallConventionNoSemiContext {
	var p = new(CallConventionNoSemiContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_callConventionNoSemi
	return p
}

func InitEmptyCallConventionNoSemiContext(p *CallConventionNoSemiContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_callConventionNoSemi
}

func (*CallConventionNoSemiContext) IsCallConventionNoSemiContext() {}

func NewCallConventionNoSemiContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallConventionNoSemiContext {
	var p = new(CallConventionNoSemiContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_callConventionNoSemi

	return p
}

func (s *CallConventionNoSemiContext) GetParser() antlr.Parser { return s.parser }

func (s *CallConventionNoSemiContext) CDECL() antlr.TerminalNode {
	return s.GetToken(DelphiParserCDECL, 0)
}

func (s *CallConventionNoSemiContext) PASCAL() antlr.TerminalNode {
	return s.GetToken(DelphiParserPASCAL, 0)
}

func (s *CallConventionNoSemiContext) REGISTER() antlr.TerminalNode {
	return s.GetToken(DelphiParserREGISTER, 0)
}

func (s *CallConventionNoSemiContext) SAFECALL() antlr.TerminalNode {
	return s.GetToken(DelphiParserSAFECALL, 0)
}

func (s *CallConventionNoSemiContext) STDCALL() antlr.TerminalNode {
	return s.GetToken(DelphiParserSTDCALL, 0)
}

func (s *CallConventionNoSemiContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DelphiParserEXPORT, 0)
}

func (s *CallConventionNoSemiContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallConventionNoSemiContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallConventionNoSemiContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterCallConventionNoSemi(s)
	}
}

func (s *CallConventionNoSemiContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitCallConventionNoSemi(s)
	}
}

func (p *DelphiParser) CallConventionNoSemi() (localctx ICallConventionNoSemiContext) {
	localctx = NewCallConventionNoSemiContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, DelphiParserRULE_callConventionNoSemi)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2039)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DelphiParserCDECL || _la == DelphiParserEXPORT || ((int64((_la-82)) & ^0x3f) == 0 && ((int64(1)<<(_la-82))&272662529) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOldCallConventionDirectiveContext is an interface to support dynamic dispatch.
type IOldCallConventionDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FAR() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	NEAR() antlr.TerminalNode

	// IsOldCallConventionDirectiveContext differentiates from other interfaces.
	IsOldCallConventionDirectiveContext()
}

type OldCallConventionDirectiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOldCallConventionDirectiveContext() *OldCallConventionDirectiveContext {
	var p = new(OldCallConventionDirectiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_oldCallConventionDirective
	return p
}

func InitEmptyOldCallConventionDirectiveContext(p *OldCallConventionDirectiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_oldCallConventionDirective
}

func (*OldCallConventionDirectiveContext) IsOldCallConventionDirectiveContext() {}

func NewOldCallConventionDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OldCallConventionDirectiveContext {
	var p = new(OldCallConventionDirectiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_oldCallConventionDirective

	return p
}

func (s *OldCallConventionDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *OldCallConventionDirectiveContext) FAR() antlr.TerminalNode {
	return s.GetToken(DelphiParserFAR, 0)
}

func (s *OldCallConventionDirectiveContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *OldCallConventionDirectiveContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DelphiParserLOCAL, 0)
}

func (s *OldCallConventionDirectiveContext) NEAR() antlr.TerminalNode {
	return s.GetToken(DelphiParserNEAR, 0)
}

func (s *OldCallConventionDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OldCallConventionDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OldCallConventionDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterOldCallConventionDirective(s)
	}
}

func (s *OldCallConventionDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitOldCallConventionDirective(s)
	}
}

func (p *DelphiParser) OldCallConventionDirective() (localctx IOldCallConventionDirectiveContext) {
	localctx = NewOldCallConventionDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, DelphiParserRULE_oldCallConventionDirective)
	p.SetState(2047)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserFAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2041)
			p.Match(DelphiParserFAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2042)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserLOCAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2043)
			p.Match(DelphiParserLOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2044)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserNEAR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2045)
			p.Match(DelphiParserNEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2046)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHintingDirectiveContext is an interface to support dynamic dispatch.
type IHintingDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEPRECATED() antlr.TerminalNode
	StringFactor() IStringFactorContext
	EXPERIMENTAL() antlr.TerminalNode
	PLATFORM() antlr.TerminalNode
	LIBRARY() antlr.TerminalNode

	// IsHintingDirectiveContext differentiates from other interfaces.
	IsHintingDirectiveContext()
}

type HintingDirectiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHintingDirectiveContext() *HintingDirectiveContext {
	var p = new(HintingDirectiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_hintingDirective
	return p
}

func InitEmptyHintingDirectiveContext(p *HintingDirectiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_hintingDirective
}

func (*HintingDirectiveContext) IsHintingDirectiveContext() {}

func NewHintingDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintingDirectiveContext {
	var p = new(HintingDirectiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_hintingDirective

	return p
}

func (s *HintingDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *HintingDirectiveContext) DEPRECATED() antlr.TerminalNode {
	return s.GetToken(DelphiParserDEPRECATED, 0)
}

func (s *HintingDirectiveContext) StringFactor() IStringFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringFactorContext)
}

func (s *HintingDirectiveContext) EXPERIMENTAL() antlr.TerminalNode {
	return s.GetToken(DelphiParserEXPERIMENTAL, 0)
}

func (s *HintingDirectiveContext) PLATFORM() antlr.TerminalNode {
	return s.GetToken(DelphiParserPLATFORM, 0)
}

func (s *HintingDirectiveContext) LIBRARY() antlr.TerminalNode {
	return s.GetToken(DelphiParserLIBRARY, 0)
}

func (s *HintingDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintingDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HintingDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterHintingDirective(s)
	}
}

func (s *HintingDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitHintingDirective(s)
	}
}

func (p *DelphiParser) HintingDirective() (localctx IHintingDirectiveContext) {
	localctx = NewHintingDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, DelphiParserRULE_hintingDirective)
	var _la int

	p.SetState(2054)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserDEPRECATED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2049)
			p.Match(DelphiParserDEPRECATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2051)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DelphiParserQuotedString || _la == DelphiParserControlString {
			{
				p.SetState(2050)
				p.StringFactor()
			}

		}

	case DelphiParserEXPERIMENTAL, DelphiParserLIBRARY, DelphiParserPLATFORM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2053)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-38)) & ^0x3f) == 0 && ((int64(1)<<(_la-38))&35184405643265) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternalDirectiveContext is an interface to support dynamic dispatch.
type IExternalDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VARARGS() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	ConstExpression() IConstExpressionContext
	AllExternalSpecifier() []IExternalSpecifierContext
	ExternalSpecifier(i int) IExternalSpecifierContext

	// IsExternalDirectiveContext differentiates from other interfaces.
	IsExternalDirectiveContext()
}

type ExternalDirectiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternalDirectiveContext() *ExternalDirectiveContext {
	var p = new(ExternalDirectiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_externalDirective
	return p
}

func InitEmptyExternalDirectiveContext(p *ExternalDirectiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_externalDirective
}

func (*ExternalDirectiveContext) IsExternalDirectiveContext() {}

func NewExternalDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternalDirectiveContext {
	var p = new(ExternalDirectiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_externalDirective

	return p
}

func (s *ExternalDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternalDirectiveContext) VARARGS() antlr.TerminalNode {
	return s.GetToken(DelphiParserVARARGS, 0)
}

func (s *ExternalDirectiveContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *ExternalDirectiveContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DelphiParserEXTERNAL, 0)
}

func (s *ExternalDirectiveContext) ConstExpression() IConstExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstExpressionContext)
}

func (s *ExternalDirectiveContext) AllExternalSpecifier() []IExternalSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExternalSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IExternalSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExternalSpecifierContext); ok {
			tst[i] = t.(IExternalSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *ExternalDirectiveContext) ExternalSpecifier(i int) IExternalSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternalSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternalSpecifierContext)
}

func (s *ExternalDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternalDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterExternalDirective(s)
	}
}

func (s *ExternalDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitExternalDirective(s)
	}
}

func (p *DelphiParser) ExternalDirective() (localctx IExternalDirectiveContext) {
	localctx = NewExternalDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, DelphiParserRULE_externalDirective)
	var _la int

	p.SetState(2070)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 278, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2056)
			p.Match(DelphiParserVARARGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2057)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2058)
			p.Match(DelphiParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2059)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2060)
			p.Match(DelphiParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2061)
			p.ConstExpression()
		}
		p.SetState(2065)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DelphiParserINDEX || _la == DelphiParserNAME {
			{
				p.SetState(2062)
				p.ExternalSpecifier()
			}

			p.SetState(2067)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2068)
			p.Match(DelphiParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternalSpecifierContext is an interface to support dynamic dispatch.
type IExternalSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME() antlr.TerminalNode
	ConstExpression() IConstExpressionContext
	INDEX() antlr.TerminalNode

	// IsExternalSpecifierContext differentiates from other interfaces.
	IsExternalSpecifierContext()
}

type ExternalSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternalSpecifierContext() *ExternalSpecifierContext {
	var p = new(ExternalSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_externalSpecifier
	return p
}

func InitEmptyExternalSpecifierContext(p *ExternalSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_externalSpecifier
}

func (*ExternalSpecifierContext) IsExternalSpecifierContext() {}

func NewExternalSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternalSpecifierContext {
	var p = new(ExternalSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_externalSpecifier

	return p
}

func (s *ExternalSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternalSpecifierContext) NAME() antlr.TerminalNode {
	return s.GetToken(DelphiParserNAME, 0)
}

func (s *ExternalSpecifierContext) ConstExpression() IConstExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstExpressionContext)
}

func (s *ExternalSpecifierContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DelphiParserINDEX, 0)
}

func (s *ExternalSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternalSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterExternalSpecifier(s)
	}
}

func (s *ExternalSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitExternalSpecifier(s)
	}
}

func (p *DelphiParser) ExternalSpecifier() (localctx IExternalSpecifierContext) {
	localctx = NewExternalSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, DelphiParserRULE_externalSpecifier)
	p.SetState(2076)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2072)
			p.Match(DelphiParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2073)
			p.ConstExpression()
		}

	case DelphiParserINDEX:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2074)
			p.Match(DelphiParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2075)
			p.ConstExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDispIDDirectiveContext is an interface to support dynamic dispatch.
type IDispIDDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISPID() antlr.TerminalNode
	Expression() IExpressionContext
	SEMI() antlr.TerminalNode

	// IsDispIDDirectiveContext differentiates from other interfaces.
	IsDispIDDirectiveContext()
}

type DispIDDirectiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDispIDDirectiveContext() *DispIDDirectiveContext {
	var p = new(DispIDDirectiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_dispIDDirective
	return p
}

func InitEmptyDispIDDirectiveContext(p *DispIDDirectiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_dispIDDirective
}

func (*DispIDDirectiveContext) IsDispIDDirectiveContext() {}

func NewDispIDDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DispIDDirectiveContext {
	var p = new(DispIDDirectiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_dispIDDirective

	return p
}

func (s *DispIDDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *DispIDDirectiveContext) DISPID() antlr.TerminalNode {
	return s.GetToken(DelphiParserDISPID, 0)
}

func (s *DispIDDirectiveContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DispIDDirectiveContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DelphiParserSEMI, 0)
}

func (s *DispIDDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DispIDDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DispIDDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterDispIDDirective(s)
	}
}

func (s *DispIDDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitDispIDDirective(s)
	}
}

func (p *DelphiParser) DispIDDirective() (localctx IDispIDDirectiveContext) {
	localctx = NewDispIDDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, DelphiParserRULE_dispIDDirective)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2078)
		p.Match(DelphiParserDISPID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2079)
		p.Expression()
	}
	{
		p.SetState(2080)
		p.Match(DelphiParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentContext is an interface to support dynamic dispatch.
type IIdentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TkIdentifier() antlr.TerminalNode
	AMBER() antlr.TerminalNode
	UsedKeywordsAsNames() IUsedKeywordsAsNamesContext

	// IsIdentContext differentiates from other interfaces.
	IsIdentContext()
}

type IdentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentContext() *IdentContext {
	var p = new(IdentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_ident
	return p
}

func InitEmptyIdentContext(p *IdentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_ident
}

func (*IdentContext) IsIdentContext() {}

func NewIdentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentContext {
	var p = new(IdentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_ident

	return p
}

func (s *IdentContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentContext) TkIdentifier() antlr.TerminalNode {
	return s.GetToken(DelphiParserTkIdentifier, 0)
}

func (s *IdentContext) AMBER() antlr.TerminalNode {
	return s.GetToken(DelphiParserAMBER, 0)
}

func (s *IdentContext) UsedKeywordsAsNames() IUsedKeywordsAsNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsedKeywordsAsNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsedKeywordsAsNamesContext)
}

func (s *IdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterIdent(s)
	}
}

func (s *IdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitIdent(s)
	}
}

func (p *DelphiParser) Ident() (localctx IIdentContext) {
	localctx = NewIdentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, DelphiParserRULE_ident)
	p.SetState(2086)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserTkIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2082)
			p.Match(DelphiParserTkIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserAMBER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2083)
			p.Match(DelphiParserAMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2084)
			p.Match(DelphiParserTkIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DelphiParserADD, DelphiParserANSISTRING, DelphiParserAT, DelphiParserBREAK, DelphiParserCONTAINS, DelphiParserCONTINUE, DelphiParserDEFAULT, DelphiParserEXIT, DelphiParserEXPORT, DelphiParserFINAL, DelphiParserIMPLEMENTS, DelphiParserINDEX, DelphiParserLOCAL, DelphiParserMESSAGE, DelphiParserNAME, DelphiParserOBJECT, DelphiParserOPERATOR, DelphiParserOUT, DelphiParserPOINTER, DelphiParserREAD, DelphiParserREADONLY, DelphiParserREFERENCE, DelphiParserREGISTER, DelphiParserREMOVE, DelphiParserSTORED, DelphiParserSTRICT, DelphiParserSTRING, DelphiParserVARIANT, DelphiParserWRITE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2085)
			p.UsedKeywordsAsNames()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsedKeywordsAsNamesContext is an interface to support dynamic dispatch.
type IUsedKeywordsAsNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME() antlr.TerminalNode
	READONLY() antlr.TerminalNode
	ADD() antlr.TerminalNode
	AT() antlr.TerminalNode
	MESSAGE() antlr.TerminalNode
	POINTER() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	STRING() antlr.TerminalNode
	CONTINUE() antlr.TerminalNode
	READ() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	REGISTER() antlr.TerminalNode
	VARIANT() antlr.TerminalNode
	OPERATOR() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	REFERENCE() antlr.TerminalNode
	CONTAINS() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	BREAK() antlr.TerminalNode
	EXIT() antlr.TerminalNode
	STRICT() antlr.TerminalNode
	OUT() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	ANSISTRING() antlr.TerminalNode
	IMPLEMENTS() antlr.TerminalNode
	STORED() antlr.TerminalNode

	// IsUsedKeywordsAsNamesContext differentiates from other interfaces.
	IsUsedKeywordsAsNamesContext()
}

type UsedKeywordsAsNamesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsedKeywordsAsNamesContext() *UsedKeywordsAsNamesContext {
	var p = new(UsedKeywordsAsNamesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_usedKeywordsAsNames
	return p
}

func InitEmptyUsedKeywordsAsNamesContext(p *UsedKeywordsAsNamesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_usedKeywordsAsNames
}

func (*UsedKeywordsAsNamesContext) IsUsedKeywordsAsNamesContext() {}

func NewUsedKeywordsAsNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsedKeywordsAsNamesContext {
	var p = new(UsedKeywordsAsNamesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_usedKeywordsAsNames

	return p
}

func (s *UsedKeywordsAsNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *UsedKeywordsAsNamesContext) NAME() antlr.TerminalNode {
	return s.GetToken(DelphiParserNAME, 0)
}

func (s *UsedKeywordsAsNamesContext) READONLY() antlr.TerminalNode {
	return s.GetToken(DelphiParserREADONLY, 0)
}

func (s *UsedKeywordsAsNamesContext) ADD() antlr.TerminalNode {
	return s.GetToken(DelphiParserADD, 0)
}

func (s *UsedKeywordsAsNamesContext) AT() antlr.TerminalNode {
	return s.GetToken(DelphiParserAT, 0)
}

func (s *UsedKeywordsAsNamesContext) MESSAGE() antlr.TerminalNode {
	return s.GetToken(DelphiParserMESSAGE, 0)
}

func (s *UsedKeywordsAsNamesContext) POINTER() antlr.TerminalNode {
	return s.GetToken(DelphiParserPOINTER, 0)
}

func (s *UsedKeywordsAsNamesContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DelphiParserINDEX, 0)
}

func (s *UsedKeywordsAsNamesContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DelphiParserDEFAULT, 0)
}

func (s *UsedKeywordsAsNamesContext) STRING() antlr.TerminalNode {
	return s.GetToken(DelphiParserSTRING, 0)
}

func (s *UsedKeywordsAsNamesContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(DelphiParserCONTINUE, 0)
}

func (s *UsedKeywordsAsNamesContext) READ() antlr.TerminalNode {
	return s.GetToken(DelphiParserREAD, 0)
}

func (s *UsedKeywordsAsNamesContext) WRITE() antlr.TerminalNode {
	return s.GetToken(DelphiParserWRITE, 0)
}

func (s *UsedKeywordsAsNamesContext) REGISTER() antlr.TerminalNode {
	return s.GetToken(DelphiParserREGISTER, 0)
}

func (s *UsedKeywordsAsNamesContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(DelphiParserVARIANT, 0)
}

func (s *UsedKeywordsAsNamesContext) OPERATOR() antlr.TerminalNode {
	return s.GetToken(DelphiParserOPERATOR, 0)
}

func (s *UsedKeywordsAsNamesContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(DelphiParserREMOVE, 0)
}

func (s *UsedKeywordsAsNamesContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DelphiParserLOCAL, 0)
}

func (s *UsedKeywordsAsNamesContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(DelphiParserREFERENCE, 0)
}

func (s *UsedKeywordsAsNamesContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(DelphiParserCONTAINS, 0)
}

func (s *UsedKeywordsAsNamesContext) FINAL() antlr.TerminalNode {
	return s.GetToken(DelphiParserFINAL, 0)
}

func (s *UsedKeywordsAsNamesContext) BREAK() antlr.TerminalNode {
	return s.GetToken(DelphiParserBREAK, 0)
}

func (s *UsedKeywordsAsNamesContext) EXIT() antlr.TerminalNode {
	return s.GetToken(DelphiParserEXIT, 0)
}

func (s *UsedKeywordsAsNamesContext) STRICT() antlr.TerminalNode {
	return s.GetToken(DelphiParserSTRICT, 0)
}

func (s *UsedKeywordsAsNamesContext) OUT() antlr.TerminalNode {
	return s.GetToken(DelphiParserOUT, 0)
}

func (s *UsedKeywordsAsNamesContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(DelphiParserOBJECT, 0)
}

func (s *UsedKeywordsAsNamesContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DelphiParserEXPORT, 0)
}

func (s *UsedKeywordsAsNamesContext) ANSISTRING() antlr.TerminalNode {
	return s.GetToken(DelphiParserANSISTRING, 0)
}

func (s *UsedKeywordsAsNamesContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(DelphiParserIMPLEMENTS, 0)
}

func (s *UsedKeywordsAsNamesContext) STORED() antlr.TerminalNode {
	return s.GetToken(DelphiParserSTORED, 0)
}

func (s *UsedKeywordsAsNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsedKeywordsAsNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsedKeywordsAsNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterUsedKeywordsAsNames(s)
	}
}

func (s *UsedKeywordsAsNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitUsedKeywordsAsNames(s)
	}
}

func (p *DelphiParser) UsedKeywordsAsNames() (localctx IUsedKeywordsAsNamesContext) {
	localctx = NewUsedKeywordsAsNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, DelphiParserRULE_usedKeywordsAsNames)
	var _la int

	p.SetState(2091)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserADD, DelphiParserAT, DelphiParserCONTINUE, DelphiParserDEFAULT, DelphiParserINDEX, DelphiParserMESSAGE, DelphiParserNAME, DelphiParserPOINTER, DelphiParserREADONLY, DelphiParserSTRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2088)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72057594050514960) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&281475514105861) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case DelphiParserCONTAINS, DelphiParserFINAL, DelphiParserLOCAL, DelphiParserOPERATOR, DelphiParserREAD, DelphiParserREFERENCE, DelphiParserREGISTER, DelphiParserREMOVE, DelphiParserVARIANT, DelphiParserWRITE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2089)
			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-21)) & ^0x3f) == 0 && ((int64(1)<<(_la-21))&18023194610892801) != 0) || ((int64((_la-93)) & ^0x3f) == 0 && ((int64(1)<<(_la-93))&73014444121) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case DelphiParserANSISTRING, DelphiParserBREAK, DelphiParserEXIT, DelphiParserEXPORT, DelphiParserIMPLEMENTS, DelphiParserOBJECT, DelphiParserOUT, DelphiParserSTORED, DelphiParserSTRICT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2090)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&18015085704282176) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&1649267441697) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentListContext is an interface to support dynamic dispatch.
type IIdentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentListContext differentiates from other interfaces.
	IsIdentListContext()
}

type IdentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentListContext() *IdentListContext {
	var p = new(IdentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_identList
	return p
}

func InitEmptyIdentListContext(p *IdentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_identList
}

func (*IdentListContext) IsIdentListContext() {}

func NewIdentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentListContext {
	var p = new(IdentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_identList

	return p
}

func (s *IdentListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentListContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *IdentListContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *IdentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserCOMMA)
}

func (s *IdentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserCOMMA, i)
}

func (s *IdentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterIdentList(s)
	}
}

func (s *IdentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitIdentList(s)
	}
}

func (p *DelphiParser) IdentList() (localctx IIdentListContext) {
	localctx = NewIdentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, DelphiParserRULE_identList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2093)
		p.Ident()
	}
	p.SetState(2098)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DelphiParserCOMMA {
		{
			p.SetState(2094)
			p.Match(DelphiParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2095)
			p.Ident()
		}

		p.SetState(2100)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentListFlatContext is an interface to support dynamic dispatch.
type IIdentListFlatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentListFlatContext differentiates from other interfaces.
	IsIdentListFlatContext()
}

type IdentListFlatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentListFlatContext() *IdentListFlatContext {
	var p = new(IdentListFlatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_identListFlat
	return p
}

func InitEmptyIdentListFlatContext(p *IdentListFlatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_identListFlat
}

func (*IdentListFlatContext) IsIdentListFlatContext() {}

func NewIdentListFlatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentListFlatContext {
	var p = new(IdentListFlatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_identListFlat

	return p
}

func (s *IdentListFlatContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentListFlatContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *IdentListFlatContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *IdentListFlatContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserCOMMA)
}

func (s *IdentListFlatContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserCOMMA, i)
}

func (s *IdentListFlatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentListFlatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentListFlatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterIdentListFlat(s)
	}
}

func (s *IdentListFlatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitIdentListFlat(s)
	}
}

func (p *DelphiParser) IdentListFlat() (localctx IIdentListFlatContext) {
	localctx = NewIdentListFlatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, DelphiParserRULE_identListFlat)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2101)
		p.Ident()
	}
	p.SetState(2106)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DelphiParserCOMMA {
		{
			p.SetState(2102)
			p.Match(DelphiParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2103)
			p.Ident()
		}

		p.SetState(2108)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelContext is an interface to support dynamic dispatch.
type ILabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TkIdentifier() antlr.TerminalNode
	TkIntNum() antlr.TerminalNode
	TkHexNum() antlr.TerminalNode
	UsedKeywordsAsNames() IUsedKeywordsAsNamesContext

	// IsLabelContext differentiates from other interfaces.
	IsLabelContext()
}

type LabelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelContext() *LabelContext {
	var p = new(LabelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_label
	return p
}

func InitEmptyLabelContext(p *LabelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_label
}

func (*LabelContext) IsLabelContext() {}

func NewLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelContext {
	var p = new(LabelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_label

	return p
}

func (s *LabelContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelContext) TkIdentifier() antlr.TerminalNode {
	return s.GetToken(DelphiParserTkIdentifier, 0)
}

func (s *LabelContext) TkIntNum() antlr.TerminalNode {
	return s.GetToken(DelphiParserTkIntNum, 0)
}

func (s *LabelContext) TkHexNum() antlr.TerminalNode {
	return s.GetToken(DelphiParserTkHexNum, 0)
}

func (s *LabelContext) UsedKeywordsAsNames() IUsedKeywordsAsNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsedKeywordsAsNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsedKeywordsAsNamesContext)
}

func (s *LabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterLabel(s)
	}
}

func (s *LabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitLabel(s)
	}
}

func (p *DelphiParser) Label() (localctx ILabelContext) {
	localctx = NewLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, DelphiParserRULE_label)
	var _la int

	p.SetState(2111)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DelphiParserTkIdentifier, DelphiParserTkIntNum, DelphiParserTkHexNum:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2109)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-183)) & ^0x3f) == 0 && ((int64(1)<<(_la-183))&11) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case DelphiParserADD, DelphiParserANSISTRING, DelphiParserAT, DelphiParserBREAK, DelphiParserCONTAINS, DelphiParserCONTINUE, DelphiParserDEFAULT, DelphiParserEXIT, DelphiParserEXPORT, DelphiParserFINAL, DelphiParserIMPLEMENTS, DelphiParserINDEX, DelphiParserLOCAL, DelphiParserMESSAGE, DelphiParserNAME, DelphiParserOBJECT, DelphiParserOPERATOR, DelphiParserOUT, DelphiParserPOINTER, DelphiParserREAD, DelphiParserREADONLY, DelphiParserREFERENCE, DelphiParserREGISTER, DelphiParserREMOVE, DelphiParserSTORED, DelphiParserSTRICT, DelphiParserSTRING, DelphiParserVARIANT, DelphiParserWRITE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2110)
			p.UsedKeywordsAsNames()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntNumContext is an interface to support dynamic dispatch.
type IIntNumContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TkIntNum() antlr.TerminalNode
	TkHexNum() antlr.TerminalNode

	// IsIntNumContext differentiates from other interfaces.
	IsIntNumContext()
}

type IntNumContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntNumContext() *IntNumContext {
	var p = new(IntNumContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_intNum
	return p
}

func InitEmptyIntNumContext(p *IntNumContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_intNum
}

func (*IntNumContext) IsIntNumContext() {}

func NewIntNumContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntNumContext {
	var p = new(IntNumContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_intNum

	return p
}

func (s *IntNumContext) GetParser() antlr.Parser { return s.parser }

func (s *IntNumContext) TkIntNum() antlr.TerminalNode {
	return s.GetToken(DelphiParserTkIntNum, 0)
}

func (s *IntNumContext) TkHexNum() antlr.TerminalNode {
	return s.GetToken(DelphiParserTkHexNum, 0)
}

func (s *IntNumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntNumContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntNumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterIntNum(s)
	}
}

func (s *IntNumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitIntNum(s)
	}
}

func (p *DelphiParser) IntNum() (localctx IIntNumContext) {
	localctx = NewIntNumContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, DelphiParserRULE_intNum)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2113)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DelphiParserTkIntNum || _la == DelphiParserTkHexNum) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRealNumContext is an interface to support dynamic dispatch.
type IRealNumContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TkRealNum() antlr.TerminalNode

	// IsRealNumContext differentiates from other interfaces.
	IsRealNumContext()
}

type RealNumContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRealNumContext() *RealNumContext {
	var p = new(RealNumContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_realNum
	return p
}

func InitEmptyRealNumContext(p *RealNumContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_realNum
}

func (*RealNumContext) IsRealNumContext() {}

func NewRealNumContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RealNumContext {
	var p = new(RealNumContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_realNum

	return p
}

func (s *RealNumContext) GetParser() antlr.Parser { return s.parser }

func (s *RealNumContext) TkRealNum() antlr.TerminalNode {
	return s.GetToken(DelphiParserTkRealNum, 0)
}

func (s *RealNumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RealNumContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RealNumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterRealNum(s)
	}
}

func (s *RealNumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitRealNum(s)
	}
}

func (p *DelphiParser) RealNum() (localctx IRealNumContext) {
	localctx = NewRealNumContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, DelphiParserRULE_realNum)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2115)
		p.Match(DelphiParserTkRealNum)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamespacedQualifiedIdentContext is an interface to support dynamic dispatch.
type INamespacedQualifiedIdentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdent() IQualifiedIdentContext
	NamespaceName() INamespaceNameContext
	DOT() antlr.TerminalNode

	// IsNamespacedQualifiedIdentContext differentiates from other interfaces.
	IsNamespacedQualifiedIdentContext()
}

type NamespacedQualifiedIdentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespacedQualifiedIdentContext() *NamespacedQualifiedIdentContext {
	var p = new(NamespacedQualifiedIdentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_namespacedQualifiedIdent
	return p
}

func InitEmptyNamespacedQualifiedIdentContext(p *NamespacedQualifiedIdentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_namespacedQualifiedIdent
}

func (*NamespacedQualifiedIdentContext) IsNamespacedQualifiedIdentContext() {}

func NewNamespacedQualifiedIdentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespacedQualifiedIdentContext {
	var p = new(NamespacedQualifiedIdentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_namespacedQualifiedIdent

	return p
}

func (s *NamespacedQualifiedIdentContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespacedQualifiedIdentContext) QualifiedIdent() IQualifiedIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentContext)
}

func (s *NamespacedQualifiedIdentContext) NamespaceName() INamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameContext)
}

func (s *NamespacedQualifiedIdentContext) DOT() antlr.TerminalNode {
	return s.GetToken(DelphiParserDOT, 0)
}

func (s *NamespacedQualifiedIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespacedQualifiedIdentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespacedQualifiedIdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterNamespacedQualifiedIdent(s)
	}
}

func (s *NamespacedQualifiedIdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitNamespacedQualifiedIdent(s)
	}
}

func (p *DelphiParser) NamespacedQualifiedIdent() (localctx INamespacedQualifiedIdentContext) {
	localctx = NewNamespacedQualifiedIdentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, DelphiParserRULE_namespacedQualifiedIdent)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2120)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 285, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2117)
			p.NamespaceName()
		}
		{
			p.SetState(2118)
			p.Match(DelphiParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2122)
		p.QualifiedIdent()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamespaceNameContext is an interface to support dynamic dispatch.
type INamespaceNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsNamespaceNameContext differentiates from other interfaces.
	IsNamespaceNameContext()
}

type NamespaceNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceNameContext() *NamespaceNameContext {
	var p = new(NamespaceNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_namespaceName
	return p
}

func InitEmptyNamespaceNameContext(p *NamespaceNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_namespaceName
}

func (*NamespaceNameContext) IsNamespaceNameContext() {}

func NewNamespaceNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceNameContext {
	var p = new(NamespaceNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_namespaceName

	return p
}

func (s *NamespaceNameContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceNameContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *NamespaceNameContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *NamespaceNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserDOT)
}

func (s *NamespaceNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserDOT, i)
}

func (s *NamespaceNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterNamespaceName(s)
	}
}

func (s *NamespaceNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitNamespaceName(s)
	}
}

func (p *DelphiParser) NamespaceName() (localctx INamespaceNameContext) {
	localctx = NewNamespaceNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, DelphiParserRULE_namespaceName)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2124)
		p.Ident()
	}
	p.SetState(2129)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 286, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2125)
				p.Match(DelphiParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2126)
				p.Ident()
			}

		}
		p.SetState(2131)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 286, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedIdentContext is an interface to support dynamic dispatch.
type IQualifiedIdentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsQualifiedIdentContext differentiates from other interfaces.
	IsQualifiedIdentContext()
}

type QualifiedIdentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedIdentContext() *QualifiedIdentContext {
	var p = new(QualifiedIdentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_qualifiedIdent
	return p
}

func InitEmptyQualifiedIdentContext(p *QualifiedIdentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DelphiParserRULE_qualifiedIdent
}

func (*QualifiedIdentContext) IsQualifiedIdentContext() {}

func NewQualifiedIdentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedIdentContext {
	var p = new(QualifiedIdentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DelphiParserRULE_qualifiedIdent

	return p
}

func (s *QualifiedIdentContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedIdentContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedIdentContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *QualifiedIdentContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(DelphiParserDOT)
}

func (s *QualifiedIdentContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(DelphiParserDOT, i)
}

func (s *QualifiedIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedIdentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedIdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.EnterQualifiedIdent(s)
	}
}

func (s *QualifiedIdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DelphiListener); ok {
		listenerT.ExitQualifiedIdent(s)
	}
}

func (p *DelphiParser) QualifiedIdent() (localctx IQualifiedIdentContext) {
	localctx = NewQualifiedIdentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, DelphiParserRULE_qualifiedIdent)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2137)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 287, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2132)
				p.Ident()
			}
			{
				p.SetState(2133)
				p.Match(DelphiParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2139)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 287, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(2140)
		p.Ident()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
